<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="./style.css"></link><link rel="icon" href="./favicon.svg"></link><link rel="mask-icon" href="./favicon.svg" color="#000000"></link><link rel="prefetch" href=".//declarations/declaration-data.bmp" as="image"></link><title>Tactics</title><script defer="true" src="./mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="./";</script><script type="module" src="./jump-src.js"></script><script type="module" src="./search.js"></script><script type="module" src="./expand-nav.js"></script><script type="module" src="./how-about.js"></script><script type="module" src="./instances.js"></script><script type="module" src="./importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Tactics</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='./search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p><a href="#¬´tactic#adaptation_note_¬ª">#adaptation_note</a></p><p><a href="#Mathlib.Tactic.¬´tactic#check__¬ª">#check</a></p><p><a href="#Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª">#count_heartbeats</a></p><p><a href="#Mathlib.Tactic.Find.¬´tactic#find_¬ª">#find</a></p><p><a href="#LeanSearchClient.leansearch_search_tactic">#leansearch</a></p><p><a href="#LeanSearchClient.just_loogle_tactic">#loogle</a></p><p><a href="#LeanSearchClient.loogle_tactic">#loogle</a></p><p><a href="#LeanSearchClient.search_tactic">#search</a></p><p><a href="#LeanSearchClient.statesearch_search_tactic">#statesearch</a></p><p><a href="#Lean.Parser.Tactic.paren">(</a></p><p><a href="#Lean.cdot">.</a></p><p><a href="#Lean.Parser.Tactic.¬´tactic_&lt;;&gt;_¬ª">&lt;;&gt;</a></p><p><a href="#Batteries.Tactic.seq_focus">&lt;;&gt;</a></p><p><a href="#Lean.Parser.Tactic.nestedTactic">Lean.Parser.Tactic.nestedTactic</a></p><p><a href="#Batteries.Tactic.tactic_">_</a></p><p><a href="#Mathlib.Tactic.Abel.abel">abel</a></p><p><a href="#Batteries.Tactic.tacticAbsurd_">absurd</a></p><p><a href="#Mathlib.Tactic.acChange">ac_change</a></p><p><a href="#Lean.Parser.Tactic.tacticAc_nf_">ac_nf</a></p><p><a href="#Lean.Parser.Tactic.acNf0">ac_nf0</a></p><p><a href="#Lean.Parser.Tactic.acRfl">ac_rfl</a></p><p><a href="#Lean.Parser.Tactic.tacticAdmit">admit</a></p><p><a href="#Aesop.Frontend.Parser.aesopTactic">aesop</a></p><p><a href="#Aesop.Frontend.Parser.aesopTactic?">aesop?</a></p><p><a href="#Aesop.tacticAesop_unfold_">aesop_unfold</a></p><p><a href="#Aesop.tacticAesop_unfold_At_">aesop_unfold</a></p><p><a href="#Mathlib.Tactic.tacticAlgebraize__">algebraize</a></p><p><a href="#Mathlib.Tactic.tacticAlgebraize_only__">algebraize_only</a></p><p><a href="#Lean.Parser.Tactic.allGoals">all_goals</a></p><p><a href="#Lean.Parser.Tactic.tacticAnd_intros">and_intros</a></p><p><a href="#Lean.Parser.Tactic.anyGoals">any_goals</a></p><p><a href="#Mathlib.Tactic.tacticApply_At_">apply</a></p><p><a href="#Lean.Parser.Tactic.apply">apply</a></p><p><a href="#Lean.Parser.Tactic.apply?">apply?</a></p><p><a href="#Lean.Parser.Tactic.applyAssumption">apply_assumption</a></p><p><a href="#Lean.Elab.Tactic.Ext.applyExtTheorem">apply_ext_theorem</a></p><p><a href="#Mathlib.Tactic.applyFun">apply_fun</a></p><p><a href="#Lean.Parser.Tactic.tacticApply_mod_cast_">apply_mod_cast</a></p><p><a href="#Mathlib.Tactic.tacticApply_rewrite___">apply_rewrite</a></p><p><a href="#Lean.Parser.Tactic.applyRfl">apply_rfl</a></p><p><a href="#Lean.Parser.Tactic.applyRules">apply_rules</a></p><p><a href="#Mathlib.Tactic.applyRwSeq">apply_rw</a></p><p><a href="#Array.tacticArray_get_dec">array_get_dec</a></p><p><a href="#Array.tacticArray_mem_dec">array_mem_dec</a></p><p><a href="#Lean.Parser.Tactic.as_aux_lemma">as_aux_lemma</a></p><p><a href="#Lean.Parser.Tactic.assumption">assumption</a></p><p><a href="#Mathlib.Tactic.tacticAssumption'">assumption'</a></p><p><a href="#Lean.Parser.Tactic.tacticAssumption_mod_cast_">assumption_mod_cast</a></p><p><a href="#Lean.Parser.Tactic.attemptAll">attempt_all</a></p><p><a href="#Lean.Parser.Tactic.attemptAllPar">attempt_all_par</a></p><p><a href="#Mathlib.Tactic.Group.aux_group‚ÇÅ">aux_group‚ÇÅ</a></p><p><a href="#Mathlib.Tactic.Group.aux_group‚ÇÇ">aux_group‚ÇÇ</a></p><p><a href="#tacticBddDefault">bddDefault</a></p><p><a href="#Mathlib.Tactic.betaReduceStx">beta_reduce</a></p><p><a href="#Mathlib.Tactic.Borelize.tacticBorelize___">borelize</a></p><p><a href="#¬´tacticBound[_]¬ª">bound</a></p><p><a href="#Lean.Parser.Tactic.bvCheck">bv_check</a></p><p><a href="#Lean.Parser.Tactic.bvDecideMacro">bv_decide</a></p><p><a href="#Lean.Parser.Tactic.bvTraceMacro">bv_decide?</a></p><p><a href="#Lean.Parser.Tactic.bvNormalizeMacro">bv_normalize</a></p><p><a href="#Lean.Parser.Tactic.tacticBv_omega">bv_omega</a></p><p><a href="#¬´tacticBy_cases_:_¬ª">by_cases</a></p><p><a href="#Mathlib.Tactic.ByCases.byCases!">by_cases!</a></p><p><a href="#Batteries.Tactic.byContra">by_contra</a></p><p><a href="#Mathlib.Tactic.ByContra.byContra!">by_contra!</a></p><p><a href="#Lean.calcTactic">calc</a></p><p><a href="#Lean.Elab.Tactic.tacticCalc?">calc?</a></p><p><a href="#cancelDenoms">cancel_denoms</a></p><p><a href="#Batteries.Tactic.casePatt">case</a></p><p><a href="#Lean.Parser.Tactic.case">case</a></p><p><a href="#Lean.Parser.Tactic.case'">case'</a></p><p><a href="#Batteries.Tactic.casePatt'">case'</a></p><p><a href="#Lean.Parser.Tactic.cases">cases</a></p><p><a href="#Mathlib.Tactic.casesType">cases_type</a></p><p><a href="#Mathlib.Tactic.casesM">casesm</a></p><p><a href="#cfcContTac">cfc_cont_tac</a></p><p><a href="#cfcTac">cfc_tac</a></p><p><a href="#cfcZeroTac">cfc_zero_tac</a></p><p><a href="#Lean.Parser.Tactic.change">change</a></p><p><a href="#Mathlib.Tactic.Choose.choose">choose</a></p><p><a href="#Lean.Parser.Tactic.classical">classical</a></p><p><a href="#tacticClean_wf">clean_wf</a></p><p><a href="#Lean.Elab.Tactic.clearExceptTactic">clear</a></p><p><a href="#Lean.Parser.Tactic.clear">clear</a></p><p><a href="#Mathlib.Tactic.clear!">clear!</a></p><p><a href="#Mathlib.Tactic.clear_">clear_</a></p><p><a href="#Mathlib.Tactic.clearAuxDecl">clear_aux_decl</a></p><p><a href="#Lean.Parser.Tactic.clearValue">clear_value</a></p><p><a href="#tacticCompareOfLessAndEq_rfl">compareOfLessAndEq_rfl</a></p><p><a href="#Mathlib.Tactic.ComputeDegree.computeDegree">compute_degree</a></p><p><a href="#Batteries.Tactic.congrConfigWith">congr</a></p><p><a href="#Lean.Parser.Tactic.congr">congr</a></p><p><a href="#Batteries.Tactic.congrConfig">congr</a></p><p><a href="#Congr!.congr!">congr!</a></p><p><a href="#Mathlib.Tactic.congrM">congrm</a></p><p><a href="#tacticCongrm?">congrm?</a></p><p><a href="#Lean.Parser.Tactic.constructor">constructor</a></p><p><a href="#Mathlib.Tactic.constructorM">constructorm</a></p><p><a href="#tacticContinuity">continuity</a></p><p><a href="#tacticContinuity?">continuity?</a></p><p><a href="#Lean.Parser.Tactic.contradiction">contradiction</a></p><p><a href="#Mathlib.Tactic.Contrapose.contrapose">contrapose</a></p><p><a href="#Mathlib.Tactic.Contrapose.contrapose!">contrapose!</a></p><p><a href="#Lean.Parser.Tactic.Conv.conv">conv</a></p><p><a href="#Lean.Parser.Tactic.Conv.convTactic">conv'</a></p><p><a href="#Mathlib.Tactic.Conv.tacticConv?">conv?</a></p><p><a href="#Mathlib.Tactic.Conv.convLHS">conv_lhs</a></p><p><a href="#Mathlib.Tactic.Conv.convRHS">conv_rhs</a></p><p><a href="#Mathlib.Tactic.convert">convert</a></p><p><a href="#Mathlib.Tactic.convertTo">convert_to</a></p><p><a href="#Lean.Parser.Tactic.cutsat">cutsat</a></p><p><a href="#Lean.Parser.Tactic.dbgTrace">dbg_trace</a></p><p><a href="#Lean.Parser.Tactic.decide">decide</a></p><p><a href="#tacticDecreasing_tactic">decreasing_tactic</a></p><p><a href="#tacticDecreasing_trivial">decreasing_trivial</a></p><p><a href="#tacticDecreasing_trivial_pre_omega">decreasing_trivial_pre_omega</a></p><p><a href="#tacticDecreasing_with_">decreasing_with</a></p><p><a href="#Lean.Parser.Tactic.delta">delta</a></p><p><a href="#tacticDeriving_LawfulEq_tactic">deriving_LawfulEq_tactic</a></p><p><a href="#tacticDeriving_LawfulEq_tactic_step">deriving_LawfulEq_tactic_step</a></p><p><a href="#DerivingHelpers.tacticDeriving_ReflEq_tactic">deriving_ReflEq_tactic</a></p><p><a href="#Lean.Parser.Tactic.done">done</a></p><p><a href="#Lean.Parser.Tactic.dsimp">dsimp</a></p><p><a href="#Lean.Parser.Tactic.dsimpAutoUnfold">dsimp!</a></p><p><a href="#Lean.Parser.Tactic.dsimpTrace">dsimp?</a></p><p><a href="#Lean.Parser.Tactic.tacticDsimp?!_">dsimp?!</a></p><p><a href="#Batteries.Tactic.tacticEapply_">eapply</a></p><p><a href="#tacticEconstructor">econstructor</a></p><p><a href="#Lean.Parser.Tactic.eqRefl">eq_refl</a></p><p><a href="#Lean.Parser.Tactic.tacticErw___">erw</a></p><p><a href="#Mathlib.Tactic.Erw?.erw?">erw?</a></p><p><a href="#Mathlib.Tactic.etaExpandStx">eta_expand</a></p><p><a href="#Mathlib.Tactic.etaReduceStx">eta_reduce</a></p><p><a href="#Mathlib.Tactic.etaStructStx">eta_struct</a></p><p><a href="#Lean.Parser.Tactic.exact">exact</a></p><p><a href="#Lean.Parser.Tactic.exact?">exact?</a></p><p><a href="#Lean.Parser.Tactic.tacticExact_mod_cast_">exact_mod_cast</a></p><p><a href="#Batteries.Tactic.exacts">exacts</a></p><p><a href="#Lean.Parser.Tactic.tacticExfalso">exfalso</a></p><p><a href="#Lean.Parser.Tactic.¬´tacticExists_,,¬ª">exists</a></p><p><a href="#Mathlib.Tactic.¬´tacticExistsi_,,¬ª">existsi</a></p><p><a href="#Lean.Parser.Tactic.exposeNames">expose_names</a></p><p><a href="#Lean.Elab.Tactic.Ext.ext">ext</a></p><p><a href="#Lean.Elab.Tactic.Ext.tacticExt1___">ext1</a></p><p><a href="#Mathlib.Tactic.ExtractGoal.extractGoal">extract_goal</a></p><p><a href="#Lean.Parser.Tactic.extractLets">extract_lets</a></p><p><a href="#Lean.Parser.Tactic.fail">fail</a></p><p><a href="#Mathlib.Tactic.failIfNoProgress">fail_if_no_progress</a></p><p><a href="#Lean.Parser.Tactic.failIfSuccess">fail_if_success</a></p><p><a href="#Lean.Parser.Tactic.falseOrByContra">false_or_by_contra</a></p><p><a href="#Batteries.Tactic.tacticFapply_">fapply</a></p><p><a href="#tacticFconstructor">fconstructor</a></p><p><a href="#Mathlib.Tactic.FieldSimp.field">field</a></p><p><a href="#Mathlib.Tactic.FieldSimp.fieldSimp">field_simp</a></p><p><a href="#Mathlib.Tactic.FieldSimp.tacticField_simp_discharge">field_simp_discharge</a></p><p><a href="#Mathlib.Tactic.filterUpwards">filter_upwards</a></p><p><a href="#Lean.Elab.Tactic.finCases">fin_cases</a></p><p><a href="#Fin.tacticFin_omega">fin_omega</a></p><p><a href="#Mathlib.Tactic.Find.tacticFind">find</a></p><p><a href="#finiteness">finiteness</a></p><p><a href="#Lean.Parser.Tactic.first">first</a></p><p><a href="#Lean.Parser.Tactic.firstPar">first_par</a></p><p><a href="#Lean.Parser.Tactic.focus">focus</a></p><p><a href="#Aesop.Frontend.tacticForward____">forward</a></p><p><a href="#Aesop.Frontend.tacticForward?____">forward?</a></p><p><a href="#Lean.Parser.Tactic.funCases">fun_cases</a></p><p><a href="#Lean.Parser.Tactic.funInduction">fun_induction</a></p><p><a href="#Mathlib.Meta.FunProp.funPropTacStx">fun_prop</a></p><p><a href="#tacticFunext___">funext</a></p><p><a href="#Mathlib.Tactic.GCongr.tacticGcongr___With___">gcongr</a></p><p><a href="#Mathlib.Tactic.GCongr.tacticGcongr_discharger">gcongr_discharger</a></p><p><a href="#Lean.Parser.Tactic.generalize">generalize</a></p><p><a href="#Batteries.Tactic.generalizeProofsElab">generalize_proofs</a></p><p><a href="#tacticGet_elem_tactic">get_elem_tactic</a></p><p><a href="#tacticGet_elem_tactic_extensible">get_elem_tactic_extensible</a></p><p><a href="#tacticGet_elem_tactic_trivial">get_elem_tactic_trivial</a></p><p><a href="#Mathlib.Tactic.grewriteSeq">grewrite</a></p><p><a href="#Lean.Parser.Tactic.grind">grind</a></p><p><a href="#Lean.Parser.Tactic.grindTrace">grind?</a></p><p><a href="#Lean.Parser.Tactic.grobner">grobner</a></p><p><a href="#Mathlib.Tactic.Group.group">group</a></p><p><a href="#Mathlib.Tactic.grwSeq">grw</a></p><p><a href="#Lean.Parser.Tactic.guardExpr">guard_expr</a></p><p><a href="#guardGoalNums">guard_goal_nums</a></p><p><a href="#Lean.Parser.Tactic.guardHyp">guard_hyp</a></p><p><a href="#guardHypNums">guard_hyp_nums</a></p><p><a href="#Lean.Parser.Tactic.guardTarget">guard_target</a></p><p><a href="#Lean.Parser.Tactic.tacticHave__">have</a></p><p><a href="#Lean.Parser.Tactic.tacticHave'">have'</a></p><p><a href="#Lean.Parser.Tactic.tacticHaveI__">haveI</a></p><p><a href="#Mathlib.Tactic.Hint.hintStx">hint</a></p><p><a href="#Lean.Parser.Tactic.unknown">ident</a></p><p><a href="#Lean.Parser.Tactic.tacIfThenElse">if</a></p><p><a href="#Lean.Parser.Tactic.induction">induction</a></p><p><a href="#Lean.Parser.Tactic.tacticInfer_instance">infer_instance</a></p><p><a href="#Mathlib.Tactic.inferOptParam">infer_param</a></p><p><a href="#Lean.Elab.Tactic.inhabit">inhabit</a></p><p><a href="#Lean.Parser.Tactic.injection">injection</a></p><p><a href="#Lean.Parser.Tactic.injections">injections</a></p><p><a href="#Mathlib.Tactic.intervalCases">interval_cases</a></p><p><a href="#Lean.Parser.Tactic.intro">intro</a></p><p><a href="#Lean.Parser.Tactic.intros">intros</a></p><p><a href="#Mathlib.Tactic.introv">introv</a></p><p><a href="#Filter.tacticIsBoundedDefault">isBoundedDefault</a></p><p><a href="#Lean.Parser.Tactic.tacticIterate____">iterate</a></p><p><a href="#Lean.Parser.Tactic.left">left</a></p><p><a href="#Lean.Parser.Tactic.tacticLet__">let</a></p><p><a href="#Lean.Parser.Tactic.letrec">let rec</a></p><p><a href="#Lean.Parser.Tactic.tacticLet'__">let'</a></p><p><a href="#Lean.Parser.Tactic.tacticLetI__">letI</a></p><p><a href="#Lean.Parser.Tactic.letToHave">let_to_have</a></p><p><a href="#Lean.Parser.Tactic.lia">lia</a></p><p><a href="#Mathlib.Tactic.lift">lift</a></p><p><a href="#Lean.Parser.Tactic.liftLets">lift_lets</a></p><p><a href="#Mathlib.Tactic.linarith">linarith</a></p><p><a href="#Mathlib.Tactic.linarith?">linarith?</a></p><p><a href="#Mathlib.Tactic.LinearCombination.linearCombination">linear_combination</a></p><p><a href="#Batteries.Tactic.¬´tacticMap_tacs[_;]¬ª">map_tacs</a></p><p><a href="#Lean.Parser.Tactic.massumptionMacro">massumption</a></p><p><a href="#Lean.Parser.Tactic.match">match</a></p><p><a href="#Mathlib.Tactic.Module.tacticMatch_scalars">match_scalars</a></p><p><a href="#Mathlib.Tactic.tacticMatch_target_">match_target</a></p><p><a href="#Lean.Parser.Tactic.mcasesMacro">mcases</a></p><p><a href="#Lean.Parser.Tactic.mclearMacro">mclear</a></p><p><a href="#Lean.Parser.Tactic.mconstructorMacro">mconstructor</a></p><p><a href="#Lean.Parser.Tactic.mdup">mdup</a></p><p><a href="#Mathlib.Tactic.measurability">measurability</a></p><p><a href="#Mathlib.Tactic.measurability?">measurability?</a></p><p><a href="#Lean.Parser.Tactic.mexactMacro">mexact</a></p><p><a href="#Lean.Parser.Tactic.mexfalsoMacro">mexfalso</a></p><p><a href="#Lean.Parser.Tactic.mexistsMacro">mexists</a></p><p><a href="#Tactic.MfldSetTac.mfldSetTac">mfld_set_tac</a></p><p><a href="#Lean.Parser.Tactic.mframeMacro">mframe</a></p><p><a href="#Lean.Parser.Tactic.mhaveMacro">mhave</a></p><p><a href="#Lean.Parser.Tactic.mintroMacro">mintro</a></p><p><a href="#Lean.Parser.Tactic.mleaveMacro">mleave</a></p><p><a href="#Lean.Parser.Tactic.mleftMacro">mleft</a></p><p><a href="#Mathlib.Tactic.Module.tacticModule">module</a></p><p><a href="#Mathlib.Tactic.ComputeDegree.monicityMacro">monicity</a></p><p><a href="#Mathlib.Tactic.Monotonicity.mono">mono</a></p><p><a href="#Lean.Parser.Tactic.mpureMacro">mpure</a></p><p><a href="#Lean.Parser.Tactic.mpureIntroMacro">mpure_intro</a></p><p><a href="#Lean.Parser.Tactic.mrefineMacro">mrefine</a></p><p><a href="#Lean.Parser.Tactic.mrenameIMacro">mrename_i</a></p><p><a href="#Lean.Parser.Tactic.mreplaceMacro">mreplace</a></p><p><a href="#Lean.Parser.Tactic.mrevertMacro">mrevert</a></p><p><a href="#Lean.Parser.Tactic.mrightMacro">mright</a></p><p><a href="#Lean.Parser.Tactic.mspecMacro">mspec</a></p><p><a href="#Lean.Parser.Tactic.mspecNoBind">mspec_no_bind</a></p><p><a href="#Lean.Parser.Tactic.mspecNoSimp">mspec_no_simp</a></p><p><a href="#Lean.Parser.Tactic.mspecializeMacro">mspecialize</a></p><p><a href="#Lean.Parser.Tactic.mspecializePureMacro">mspecialize_pure</a></p><p><a href="#Lean.Parser.Tactic.mstartMacro">mstart</a></p><p><a href="#Lean.Parser.Tactic.mstopMacro">mstop</a></p><p><a href="#Lean.Parser.Tactic.mvcgenMacro">mvcgen</a></p><p><a href="#Lean.Parser.Tactic.mvcgenHint">mvcgen?</a></p><p><a href="#Lean.Parser.Tactic.tacticMvcgen_trivial">mvcgen_trivial</a></p><p><a href="#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible">mvcgen_trivial_extensible</a></p><p><a href="#Lean.Parser.Tactic.nativeDecide">native_decide</a></p><p><a href="#Lean.Parser.Tactic.¬´tacticNext_=&gt;_¬ª">next</a></p><p><a href="#Mathlib.Tactic.nlinarith">nlinarith</a></p><p><a href="#Lean.Parser.Tactic.tacticNofun">nofun</a></p><p><a href="#Lean.Parser.Tactic.¬´tacticNomatch_,,¬ª">nomatch</a></p><p><a href="#Mathlib.Tactic.NoncommRing.noncomm_ring">noncomm_ring</a></p><p><a href="#Mathlib.Tactic.Nontriviality.nontriviality">nontriviality</a></p><p><a href="#Lean.Parser.Tactic.tacticNorm_cast__">norm_cast</a></p><p><a href="#Lean.Parser.Tactic.normCast0">norm_cast0</a></p><p><a href="#Mathlib.Tactic.normNum">norm_num</a></p><p><a href="#Mathlib.Tactic.normNum1">norm_num1</a></p><p><a href="#Mathlib.Tactic.tacticNth_grewrite_____">nth_grewrite</a></p><p><a href="#Mathlib.Tactic.tacticNth_grw_____">nth_grw</a></p><p><a href="#Mathlib.Tactic.tacticNth_rewrite_____">nth_rewrite</a></p><p><a href="#Mathlib.Tactic.tacticNth_rw_____">nth_rw</a></p><p><a href="#Mathlib.Tactic.LibrarySearch.observe">observe</a></p><p><a href="#Lean.Parser.Tactic.obtain">obtain</a></p><p><a href="#Lean.Parser.Tactic.omega">omega</a></p><p><a href="#Batteries.Tactic.¬´tacticOn_goal-_=&gt;_¬ª">on_goal</a></p><p><a href="#Lean.Parser.Tactic.open">open</a></p><p><a href="#Mathlib.Tactic.Order.tacticOrder_">order</a></p><p><a href="#Mathlib.Tactic.Order.order_core">order_core</a></p><p><a href="#Mathlib.Tactic.Peel.peel">peel</a></p><p><a href="#Batteries.Tactic.¬´tacticPick_goal-_¬ª">pick_goal</a></p><p><a href="#plausibleSyntax">plausible</a></p><p><a href="#Mathlib.Tactic.Positivity.positivity">positivity</a></p><p><a href="#Mathlib.Tactic.Push.pull">pull</a></p><p><a href="#Mathlib.Tactic.Push.pushStx">push</a></p><p><a href="#Lean.Parser.Tactic.pushCast">push_cast</a></p><p><a href="#Mathlib.Tactic.Push.push_neg">push_neg</a></p><p><a href="#Lean.Parser.Tactic.rcases">rcases</a></p><p><a href="#Batteries.Tactic.rcongr">rcongr</a></p><p><a href="#Mathlib.Tactic.tacticRecover_">recover</a></p><p><a href="#Mathlib.Tactic.tacticReduce__">reduce</a></p><p><a href="#Lean.Parser.Tactic.refine">refine</a></p><p><a href="#Lean.Parser.Tactic.refine'">refine'</a></p><p><a href="#Lean.Parser.Tactic.tacticRefine_lift_">refine_lift</a></p><p><a href="#Lean.Parser.Tactic.tacticRefine_lift'_">refine_lift'</a></p><p><a href="#Mathlib.Tactic.refoldLetStx">refold_let</a></p><p><a href="#Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª">rel</a></p><p><a href="#Lean.Parser.Tactic.rename">rename</a></p><p><a href="#Mathlib.Tactic.rename'">rename'</a></p><p><a href="#Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª">rename_bvar</a></p><p><a href="#Lean.Parser.Tactic.renameI">rename_i</a></p><p><a href="#Lean.Parser.Tactic.tacticRepeat_">repeat</a></p><p><a href="#Lean.Parser.Tactic.repeat'">repeat'</a></p><p><a href="#Mathlib.Tactic.tacticRepeat1_">repeat1</a></p><p><a href="#Lean.Parser.Tactic.repeat1'">repeat1'</a></p><p><a href="#Lean.Parser.Tactic.replace">replace</a></p><p><a href="#Lean.Parser.Tactic.revert">revert</a></p><p><a href="#Lean.Parser.Tactic.rewriteSeq">rewrite</a></p><p><a href="#Mathlib.Tactic.DepRewrite.depRewriteSeq">rewrite!</a></p><p><a href="#Lean.Parser.Tactic.tacticRfl">rfl</a></p><p><a href="#Lean.Parser.Tactic.tacticRfl'">rfl'</a></p><p><a href="#Lean.Parser.Tactic.right">right</a></p><p><a href="#Mathlib.Tactic.RingNF.ring">ring</a></p><p><a href="#Mathlib.Tactic.Ring.ring1">ring1</a></p><p><a href="#Mathlib.Tactic.RingNF.ringNF">ring_nf</a></p><p><a href="#Lean.Parser.Tactic.rintro">rintro</a></p><p><a href="#Lean.Parser.Tactic.rotateLeft">rotate_left</a></p><p><a href="#Lean.Parser.Tactic.rotateRight">rotate_right</a></p><p><a href="#Mathlib.Tactic.rsuffices">rsuffices</a></p><p><a href="#Lean.Parser.Tactic.runTac">run_tac</a></p><p><a href="#Lean.Parser.Tactic.rwSeq">rw</a></p><p><a href="#Mathlib.Tactic.DepRewrite.depRwSeq">rw!</a></p><p><a href="#Lean.Parser.Tactic.rewrites?">rw?</a></p><p><a href="#Mathlib.Tactic.LibraryRewrite.tacticRw??">rw??</a></p><p><a href="#Lean.Parser.Tactic.tacticRw_mod_cast___">rw_mod_cast</a></p><p><a href="#Lean.Parser.Tactic.tacticRwa__">rwa</a></p><p><a href="#Aesop.Frontend.saturate">saturate</a></p><p><a href="#Aesop.Frontend.saturate?">saturate?</a></p><p><a href="#Mathlib.Tactic.Says.says">says</a></p><p><a href="#Mathlib.Tactic.setTactic">set</a></p><p><a href="#Lean.Parser.Tactic.set_option">set_option</a></p><p><a href="#Lean.Parser.Tactic.show">show</a></p><p><a href="#Lean.Parser.Tactic.showTerm">show_term</a></p><p><a href="#Lean.Parser.Tactic.simp">simp</a></p><p><a href="#Lean.Parser.Tactic.simpAutoUnfold">simp!</a></p><p><a href="#Lean.Parser.Tactic.simpTrace">simp?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimp?!_">simp?!</a></p><p><a href="#Lean.Parser.Tactic.simpAll">simp_all</a></p><p><a href="#Lean.Parser.Tactic.simpAllAutoUnfold">simp_all!</a></p><p><a href="#Lean.Parser.Tactic.simpAllTrace">simp_all?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimp_all?!_">simp_all?!</a></p><p><a href="#Lean.Parser.Tactic.simpAllArith">simp_all_arith</a></p><p><a href="#Lean.Parser.Tactic.simpAllArithBang">simp_all_arith!</a></p><p><a href="#Lean.Parser.Tactic.simpArith">simp_arith</a></p><p><a href="#Lean.Parser.Tactic.simpArithBang">simp_arith!</a></p><p><a href="#Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª">simp_intro</a></p><p><a href="#Mathlib.Tactic.tacticSimp_rw___">simp_rw</a></p><p><a href="#tacticSimp_wf">simp_wf</a></p><p><a href="#Lean.Parser.Tactic.simpa">simpa</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa!_">simpa!</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa?_">simpa?</a></p><p><a href="#Lean.Parser.Tactic.tacticSimpa?!_">simpa?!</a></p><p><a href="#List.tacticSizeOf_list_dec">sizeOf_list_dec</a></p><p><a href="#Lean.Parser.Tactic.skip">skip</a></p><p><a href="#Lean.Parser.Tactic.sleep">sleep</a></p><p><a href="#Lean.solveTactic">solve</a></p><p><a href="#Lean.Parser.Tactic.solveByElim">solve_by_elim</a></p><p><a href="#Lean.Parser.Tactic.tacticSorry">sorry</a></p><p><a href="#Lean.Parser.Tactic.specialize">specialize</a></p><p><a href="#Mathlib.Tactic.TautoSet.specialize_all">specialize_all</a></p><p><a href="#Lean.Parser.Tactic.split">split</a></p><p><a href="#Batteries.Tactic.tacticSplit_ands">split_ands</a></p><p><a href="#Mathlib.Tactic.splitIfs">split_ifs</a></p><p><a href="#Lean.Parser.Tactic.tacticStop_">stop</a></p><p><a href="#Mathlib.Tactic.subsingletonStx">subsingleton</a></p><p><a href="#Lean.Parser.Tactic.subst">subst</a></p><p><a href="#Lean.Parser.Tactic.substEqs">subst_eqs</a></p><p><a href="#Lean.Parser.Tactic.substVars">subst_vars</a></p><p><a href="#Mathlib.Tactic.Substs.substs">substs</a></p><p><a href="#Mathlib.Tactic.successIfFailWithMsg">success_if_fail_with_msg</a></p><p><a href="#Lean.Parser.Tactic.tacticSuffices_">suffices</a></p><p><a href="#Lean.Parser.Tactic.suggestions">suggestions</a></p><p><a href="#Batteries.Tactic.tacticSwap">swap</a></p><p><a href="#Mathlib.Tactic.¬´tacticSwap_var__,,¬ª">swap_var</a></p><p><a href="#Lean.Parser.Tactic.symm">symm</a></p><p><a href="#Lean.Parser.Tactic.symmSaturate">symm_saturate</a></p><p><a href="#Mathlib.Tactic.Tauto.tauto">tauto</a></p><p><a href="#Mathlib.Tactic.TautoSet.tacticTauto_set">tauto_set</a></p><p><a href="#Mathlib.Tactic.TFAE.tfaeFinish">tfae_finish</a></p><p><a href="#Mathlib.Tactic.TFAE.tfaeHave">tfae_have</a></p><p><a href="#Set.tacticToFinite_tac">toFinite_tac</a></p><p><a href="#Set.tacticTo_encard_tac">to_encard_tac</a></p><p><a href="#Lean.Parser.Tactic.trace">trace</a></p><p><a href="#Lean.Parser.Tactic.traceMessage">trace</a></p><p><a href="#Lean.Parser.Tactic.traceState">trace_state</a></p><p><a href="#Batteries.Tactic.tacticTrans___">trans</a></p><p><a href="#Batteries.Tactic.tacticTransitivity___">transitivity</a></p><p><a href="#Batteries.Tactic.triv">triv</a></p><p><a href="#Lean.Parser.Tactic.tacticTrivial">trivial</a></p><p><a href="#Lean.Parser.Tactic.tacticTry_">try</a></p><p><a href="#Lean.Parser.Tactic.tryTrace">try?</a></p><p><a href="#Lean.Parser.Tactic.tryResult">try_suggestions</a></p><p><a href="#Mathlib.Tactic.tacticTry_this__">try_this</a></p><p><a href="#tacticType_check_">type_check</a></p><p><a href="#Lean.Parser.Tactic.unfold">unfold</a></p><p><a href="#Mathlib.Tactic.InteractiveUnfold.tacticUnfold?">unfold?</a></p><p><a href="#Mathlib.Tactic.unfoldProjsStx">unfold_projs</a></p><p><a href="#Lean.Parser.Tactic.tacticUnhygienic_">unhygienic</a></p><p><a href="#Tactic.Interactive.tacticUnit_interval">unit_interval</a></p><p><a href="#Batteries.Tactic.unreachable">unreachable!</a></p><p><a href="#Mathlib.Tactic.useSyntax">use</a></p><p><a href="#Mathlib.Tactic.tacticUse_discharger">use_discharger</a></p><p><a href="#tacticUse_finite_instance">use_finite_instance</a></p><p><a href="#MeasureTheory.tacticVolume_tac">volume_tac</a></p><p><a href="#Lean.Server.Test.Cancel.tacticWait_for_unblock_async">wait_for_unblock_async</a></p><p><a href="#Mathlib.Tactic.tacticWhnf__">whnf</a></p><p><a href="#Lean.Parser.Tactic.withReducible">with_reducible</a></p><p><a href="#Lean.Parser.Tactic.withReducibleAndInstances">with_reducible_and_instances</a></p><p><a href="#Lean.Parser.Tactic.withUnfoldingAll">with_unfolding_all</a></p><p><a href="#Lean.Parser.Tactic.withUnfoldingNone">with_unfolding_none</a></p><p><a href="#Mathlib.Tactic.wlog">wlog</a></p><p><a href="#Mathlib.Tactic.Zify.zify">zify</a></p><p><a href="#¬´tactic‚àé¬ª">‚àé</a></p></nav><main>
<p>The tactic language is a special-purpose programming language for constructing proofs, indicated using the keyword <code>by</code>.</p><div id="¬´tactic#adaptation_note_¬ª"><h2>#adaptation_note</h2><p><p><code>#adaptation_note /-- comment -/</code> adds an adaptation note to the current file.
Adaptation notes are comments that are used to indicate that a piece of code
has been changed to accommodate a change in Lean core.
They typically require further action/maintenance to be taken in the future.</p><p>This syntax works as a command, or inline in tactic or term mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/AdaptationNote.html#¬´tactic#adaptation_note_¬ª">Mathlib.Tactic.AdaptationNote</a></dd></dl></div><div id="Mathlib.Tactic.¬´tactic#check__¬ª"><h2>#check</h2><p><p><code>#check t</code> elaborates the term <code>t</code> and then pretty prints it with its type as <code>e : ty</code>.</p><p>If <code>t</code> is an identifier, then it pretty prints a type declaration form
for the global constant <code>t</code> instead.
Use <code>#check (t)</code> to pretty print it as an elaborated expression.</p><p>Like the <code>#check</code> command, the <code>#check</code> tactic allows stuck typeclass instance problems.
These become metavariables in the output.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Check.html#Mathlib.Tactic.¬´tactic#check__¬ª">Mathlib.Tactic.Check</a></dd></dl></div><div id="Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª"><h2>#count_heartbeats</h2><p><p><code>#count_heartbeats tac</code> counts the heartbeats used by the tactic sequence <code>tac</code>
and prints an info line with the number of heartbeats.</p><ul><li><code>#count_heartbeats! n in tac</code>, where <code>n</code> is an optional natural number literal, runs <code>tac</code>
<code>n</code> times on the same goal while counting the heartbeats, and prints an info line with range and
standard deviation. <code>n</code> can be left out, and defaults to 10.</li></ul><p>Example:</p><pre><code>example : 1 + 1 = 2 := by
  -- The next line will print an info message of this format; the exact number may vary.
  -- info: 4646
  #count_heartbeats simp

example : 1 + 1 = 2 := by
  -- The next line will print an info message of this format; the exact numbers may vary.
  -- info: Min: 4 Max: 4 StdDev: 2%
  #count_heartbeats! 37 in simp
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Util/CountHeartbeats.html#Mathlib.CountHeartbeats.¬´tactic#count_heartbeats_¬ª">Mathlib.Util.CountHeartbeats</a></dd></dl></div><div id="Mathlib.Tactic.Find.¬´tactic#find_¬ª"><h2>#find</h2><p><p><code>#find t</code> finds definitions and theorems whose result type matches the term <code>t</code>, and prints them as
info lines. Use holes in <code>t</code> to indicate arbitrary subexpressions, for example <code>#find _ ‚àß _</code> will
match any conjunction. <code>#find</code> is also available as a command.
<code>#find</code> will not affect the goal by itself and should be removed from the finished proof.</p><p>There is also the <code>find</code> tactic which looks for lemmas which are <code>apply</code>able against the current
goal.</p><p>Examples:</p><pre><code class="language-lean">#find _ + _ = _ + _
#find ?n + _ = _ + ?n
#find (_ : Nat) + _ = _ + _
#find <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí <a href="./Init/Prelude.html#Nat">Nat</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Find.html#Mathlib.Tactic.Find.¬´tactic#find_¬ª">Mathlib.Tactic.Find</a></dd></dl></div><div id="LeanSearchClient.leansearch_search_tactic"><h2>#leansearch</h2><p><p>Search <a href="https://leansearch.net/">LeanSearch</a> from within Lean.
Queries should be a string that ends with a <code>.</code> or <code>?</code>. This works as a command, as a term
and as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.</p><pre><code class="language-lean">#leansearch &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;

example := #leansearch &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;

example : 3 ‚â§ 5 := by
  #leansearch &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;
  sorry
</code></pre><p>You can modify the LeanSearch URL by setting the <code>LEANSEARCHCLIENT_LEANSEARCH_API_URL</code> environment variable.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./LeanSearchClient/Syntax.html#LeanSearchClient.leansearch_search_tactic">LeanSearchClient.Syntax</a></dd></dl></div><div id="LeanSearchClient.just_loogle_tactic"><h2>#loogle</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./LeanSearchClient/LoogleSyntax.html#LeanSearchClient.just_loogle_tactic">LeanSearchClient.LoogleSyntax</a></dd></dl></div><div id="LeanSearchClient.loogle_tactic"><h2>#loogle</h2><p><p>Search <a href="https://loogle.lean-lang.org/json">Loogle</a> from within Lean. This can be used as a command, term or tactic as in the following examples. In the case of a tactic, only valid tactics are displayed.</p><pre><code class="language-lean">#loogle <a href="./Init/Prelude.html#List">List</a> ?a ‚Üí ?a

example := #loogle <a href="./Init/Prelude.html#List">List</a> ?a ‚Üí ?a

example : 3 ‚â§ 5 := by
  #loogle <a href="./Init/Prelude.html#Nat.succ_le_succ">Nat.succ_le_succ</a>
  sorry

</code></pre><h2 id="Loogle-Usage" class="markdown-heading">Loogle Usage <a class="hover-link" href="#Loogle-Usage">#</a></h2><p>Loogle finds definitions and lemmas in various ways:</p><p>By constant:
üîç Real.sin
finds all lemmas whose statement somehow mentions the sine function.</p><p>By lemma name substring:
üîç &quot;differ&quot;
finds all lemmas that have &quot;differ&quot; somewhere in their lemma name.</p><p>By subexpression:
üîç _ * (_ ^ _)
finds all lemmas whose statements somewhere include a product where the second argument is raised to some power.</p><p>The pattern can also be non-linear, as in
üîç Real.sqrt ?a * Real.sqrt ?a</p><p>If the pattern has parameters, they are matched in any order. Both of these will find List.map:
üîç (?a -&gt; ?b) -&gt; List ?a -&gt; List ?b
üîç List ?a -&gt; (?a -&gt; ?b) -&gt; List ?b</p><p>By main conclusion:
üîç |- tsum _ = _ * tsum _
finds all lemmas where the conclusion (the subexpression to the right of all ‚Üí and ‚àÄ) has the given shape.</p><p>As before, if the pattern has parameters, they are matched against the hypotheses of the lemma in any order; for example,
üîç |- _ &lt; _ ‚Üí tsum _ &lt; tsum _
will find tsum_lt_tsum even though the hypothesis f i &lt; g i is not the last.</p><p>If you pass more than one such search filter, separated by commas Loogle will return lemmas which match all of them. The search
üîç Real.sin, &quot;two&quot;, tsum, _ * _, _ ^ _, |- _ &lt; _ ‚Üí _
would find all lemmas which mention the constants Real.sin and tsum, have &quot;two&quot; as a substring of the lemma name, include a product and a power somewhere in the type, and have a hypothesis of the form _ &lt; _ (if there were any such lemmas). Metavariables (?a) are assigned independently in each filter.</p><p>You can modify the Loogle server URL by setting the <code>LEANSEARCHCLIENT_LOOGLE_API_URL</code> environment variable.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./LeanSearchClient/LoogleSyntax.html#LeanSearchClient.loogle_tactic">LeanSearchClient.LoogleSyntax</a></dd></dl></div><div id="LeanSearchClient.search_tactic"><h2>#search</h2><p><p>Search from within Lean, depending on the option <code><a href="./LeanSearchClient/Basic.html#leansearchclient.backend">leansearchclient.backend</a></code> (currently only leansearch).
Queries should be a string that ends with a <code>.</code> or <code>?</code>. This works as a command, as a term
and as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.</p><pre><code class="language-lean">#search &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;

example := #search &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;

example : 3 ‚â§ 5 := by
  #search &quot;If a natural number n is less than m, then the successor of n is less than the successor of m.&quot;
  sorry

In tactic mode, if the query string is not supplied, then [LeanStateSearch](https://premise-search.com) is queried based on the goal state.
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./LeanSearchClient/Syntax.html#LeanSearchClient.search_tactic">LeanSearchClient.Syntax</a></dd></dl></div><div id="LeanSearchClient.statesearch_search_tactic"><h2>#statesearch</h2><p><p>Search <a href="https://premise-search.com">LeanStateSearch</a> from within Lean.
Your current main goal is sent as query. The revision to search can be set
using the <code><a href="./LeanSearchClient/Basic.html#statesearch.revision">statesearch.revision</a></code> option. The number of results can be set
using the <code><a href="./LeanSearchClient/Basic.html#statesearch.queries">statesearch.queries</a></code> option.</p><p>Hint: If you want to modify the query, you need to use the web interface.</p><pre><code class="language-lean">set_option <a href="./LeanSearchClient/Basic.html#statesearch.queries">statesearch.queries</a> 1
set_option <a href="./LeanSearchClient/Basic.html#statesearch.revision">statesearch.revision</a> &quot;v4.16.0&quot;

example : 0 ‚â§ 1 := by
  #statesearch
  sorry
</code></pre><p>You can modify the LeanStateSearch URL by setting the <code>LEANSEARCHCLIENT_LEANSTATESEARCH_API_URL</code> environment variable.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./LeanSearchClient/Syntax.html#LeanSearchClient.statesearch_search_tactic">LeanSearchClient.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.paren"><h2>(</h2><p><p><code>(tacs)</code> executes a list of tactics in sequence, without requiring that
the goal be closed at the end like <code>¬∑ tacs</code>. Like <code>by</code> itself, the tactics
can be either separated by newlines or <code>;</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.paren">Init.Tactics</a></dd></dl></div><div id="Lean.cdot"><h2>.</h2><p><p><code>¬∑ tac</code> focuses on the main goal and tries to solve it using <code>tac</code>, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.cdot">Init.NotationExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.¬´tactic_&lt;;&gt;_¬ª"><h2>&lt;;&gt;</h2><p><p><code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal,
concatenating all goals produced by <code>tac'</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.¬´tactic_&lt;;&gt;_¬ª">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.seq_focus"><h2>&lt;;&gt;</h2><p><p><code>t &lt;;&gt; [t1; t2; ...; tn]</code> focuses on the first goal and applies <code>t</code>, which should result in <code>n</code>
subgoals. It then applies each <code>ti</code> to the corresponding goal and collects the resulting
subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.seq_focus">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Lean.Parser.Tactic.nestedTactic"><h2>Lean.Parser.Tactic.nestedTactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.nestedTactic">Lean.Parser.Tactic</a></dd></dl></div><div id="Batteries.Tactic.tactic_"><h2>_</h2><p><p><code>_</code> in tactic position acts like the <code>done</code> tactic: it fails and gives the list
of goals if there are any. It is useful as a placeholder after starting a tactic block
such as <code>by _</code> to make it syntactically correct and show the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tactic_">Batteries.Tactic.Init</a></dd></dl></div><div id="Mathlib.Tactic.Abel.abel"><h2>abel</h2><p><p><code>abel</code> solves equations in the language of <em>additive</em>, commutative monoids and groups.</p><p><code>abel</code> and its variants work as both tactics and conv tactics.</p><ul><li><code>abel1</code> fails if the target is not an equality that is provable by the axioms of
commutative monoids/groups.</li><li><code>abel_nf</code> rewrites all group expressions into a normal form.<ul><li><code>abel_nf at h</code> rewrites in a hypothesis.</li><li><code>abel_nf (config := cfg)</code> allows for additional configuration:<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>).</li><li><code>zetaDelta</code>: if true, local <code>let</code> variables can be unfolded (overridden by <code>!</code>).</li><li><code>recursive</code>: if true, <code>abel_nf</code> also recurses into atoms.</li></ul></li></ul></li><li><code>abel!</code>, <code>abel1!</code>, <code>abel_nf!</code> use a more aggressive reducibility setting to identify atoms.</li></ul><p>Examples:</p><pre><code>example [AddCommMonoid Œ±] (a b : Œ±) : a + (b + a) = a + a + b := by abel
example [AddCommGroup Œ±] (a : Œ±) : (3 : ‚Ñ§) ‚Ä¢ a = a + (2 : ‚Ñ§) ‚Ä¢ a := by abel
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Abel.html#Mathlib.Tactic.Abel.abel">Mathlib.Tactic.Abel</a></dd></dl></div><div id="Batteries.Tactic.tacticAbsurd_"><h2>absurd</h2><p><p>Given a proof <code>h</code> of <code>p</code>, <code><a href="./Init/Prelude.html#absurd">absurd</a> h</code> changes the goal to <code>‚ä¢ ¬¨ p</code>.
If <code>p</code> is a negation <code>¬¨q</code> then the goal is changed to <code>‚ä¢ q</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticAbsurd_">Batteries.Tactic.Init</a></dd></dl></div><div id="Mathlib.Tactic.acChange"><h2>ac_change</h2><p><p><code>ac_change t</code> on a goal <code>‚ä¢ t'</code> changes the goal to <code>‚ä¢ t</code> and adds new goals for proving the equality
<code>t' = t</code> using congruence, then tries proving these goals by associativity and commutativity. The
goals are created like <code>congr!</code> would.
In other words, <code>ac_change t</code> is like <code>convert_to t</code> followed by <code>ac_refl</code>.</p><p>Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>t</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert_to</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><ul><li><code>ac_change t using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence
is applied. For example, if the main goal is <code>‚ä¢ Prime ((a * b + 1) + c)</code>,
then <code>ac_change Prime ((1 + a * b) + c) using 2</code> solves the side goals, and
<code>ac_change Prime ((1 + a * b) + c) using 3</code> (or more) results in two (impossible) goals
<code>‚ä¢ 1 = a * b</code> and <code>‚ä¢ a * b = 1</code>.
The default value for <code>n</code> is 1.</li></ul><p>Example:</p><pre><code class="language-lean">example (a b c d e f g N : ‚Ñï) : (a + b) + (c + d) + (e + f) + g ‚â§ N := by
  ac_change a + d + e + f + c + g + b ‚â§ _
  -- ‚ä¢ a + d + e + f + c + g + b ‚â§ N
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange">Mathlib.Tactic.Convert</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAc_nf_"><h2>ac_nf</h2><p><p><code>ac_nf</code> normalizes equalities up to application of an associative and commutative operator.</p><ul><li><code>ac_nf</code> normalizes all hypotheses and the goal target of the goal.</li><li><code>ac_nf at l</code> normalizes at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>‚ä¢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li></ul><pre><code>instance : <a href="./Init/Core.html#Std.Associative">Std.Associative</a> (Œ± := Nat) (.+.) := ‚ü®Nat.add_assoc‚ü©
instance : <a href="./Init/Core.html#Std.Commutative">Std.Commutative</a> (Œ± := Nat) (.+.) := ‚ü®Nat.add_comm‚ü©

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by
 ac_nf
 -- goal: a + (b + (c + d)) = a + (b + (c + d))
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAc_nf_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.acNf0"><h2>ac_nf0</h2><p><p>Implementation of <code>ac_nf</code> (the full <code>ac_nf</code> calls <code><a href="./Init/Core.html#trivial">trivial</a></code> afterwards).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.acNf0">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.acRfl"><h2>ac_rfl</h2><p><p><code>ac_rfl</code> proves equalities up to application of an associative and commutative operator.</p><pre><code>instance : <a href="./Init/Core.html#Std.Associative">Std.Associative</a> (Œ± := Nat) (.+.) := ‚ü®Nat.add_assoc‚ü©
instance : <a href="./Init/Core.html#Std.Commutative">Std.Commutative</a> (Œ± := Nat) (.+.) := ‚ü®Nat.add_comm‚ü©

example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.acRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAdmit"><h2>admit</h2><p><p><code>admit</code> is a synonym for <code>sorry</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Init.Tactics</a></dd></dl></div><div id="Aesop.Frontend.Parser.aesopTactic"><h2>aesop</h2><p><p><code>aesop &lt;clause&gt;*</code> tries to solve the current goal by applying a set of rules
registered with the <code>@[aesop]</code> attribute. See <a href="https://github.com/JLimperg/aesop#readme">its
README</a> for a tutorial and a
reference.</p><p>The variant <code>aesop?</code> prints the proof it found as a <code>Try this</code> suggestion.</p><p>Clauses can be used to customise the behaviour of an Aesop call. Available
clauses are:</p><ul><li><code>(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)</code> adds a rule. <code>&lt;phase&gt;</code> is
<code>unsafe</code>, <code>safe</code> or <code>norm</code>. <code>&lt;priority&gt;</code> is a percentage for unsafe rules and
an integer for safe and norm rules. <code>&lt;rule&gt;</code> is the name of a declaration or
local hypothesis. <code>&lt;builder&gt;</code> is the rule builder used to turn <code>&lt;rule&gt;</code> into
an Aesop rule. Example: <code>(add unsafe 50% apply Or.inl)</code>.</li><li><code>(erase &lt;rule&gt;)</code> disables a globally registered Aesop rule. Example: <code>(erase Aesop.BuiltinRules.assumption)</code>.</li><li><code>(rule_sets := [&lt;ruleset&gt;,*])</code> enables or disables named sets of rules for
this Aesop call. Example: <code>(rule_sets := [-builtin, MyRuleSet])</code>.</li><li><code>(config { &lt;opt&gt; := &lt;value&gt; })</code> adjusts Aesop's search options. See
<code><a href="./Aesop/Options/Public.html#Aesop.Options">Aesop.Options</a></code>.</li><li><code>(simp_config { &lt;opt&gt; := &lt;value&gt; })</code> adjusts options for Aesop's built-in
<code>simp</code> rule. The given options are directly passed to <code>simp</code>. For example,
<code>(simp_config := { zeta := false })</code> makes Aesop use
<code>simp (config := { zeta := false })</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Tactic.html#Aesop.Frontend.Parser.aesopTactic">Aesop.Frontend.Tactic</a></dd></dl></div><div id="Aesop.Frontend.Parser.aesopTactic?"><h2>aesop?</h2><p><p><code>aesop &lt;clause&gt;*</code> tries to solve the current goal by applying a set of rules
registered with the <code>@[aesop]</code> attribute. See <a href="https://github.com/JLimperg/aesop#readme">its
README</a> for a tutorial and a
reference.</p><p>The variant <code>aesop?</code> prints the proof it found as a <code>Try this</code> suggestion.</p><p>Clauses can be used to customise the behaviour of an Aesop call. Available
clauses are:</p><ul><li><code>(add &lt;phase&gt; &lt;priority&gt; &lt;builder&gt; &lt;rule&gt;)</code> adds a rule. <code>&lt;phase&gt;</code> is
<code>unsafe</code>, <code>safe</code> or <code>norm</code>. <code>&lt;priority&gt;</code> is a percentage for unsafe rules and
an integer for safe and norm rules. <code>&lt;rule&gt;</code> is the name of a declaration or
local hypothesis. <code>&lt;builder&gt;</code> is the rule builder used to turn <code>&lt;rule&gt;</code> into
an Aesop rule. Example: <code>(add unsafe 50% apply Or.inl)</code>.</li><li><code>(erase &lt;rule&gt;)</code> disables a globally registered Aesop rule. Example: <code>(erase Aesop.BuiltinRules.assumption)</code>.</li><li><code>(rule_sets := [&lt;ruleset&gt;,*])</code> enables or disables named sets of rules for
this Aesop call. Example: <code>(rule_sets := [-builtin, MyRuleSet])</code>.</li><li><code>(config { &lt;opt&gt; := &lt;value&gt; })</code> adjusts Aesop's search options. See
<code><a href="./Aesop/Options/Public.html#Aesop.Options">Aesop.Options</a></code>.</li><li><code>(simp_config { &lt;opt&gt; := &lt;value&gt; })</code> adjusts options for Aesop's built-in
<code>simp</code> rule. The given options are directly passed to <code>simp</code>. For example,
<code>(simp_config := { zeta := false })</code> makes Aesop use
<code>simp (config := { zeta := false })</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Tactic.html#Aesop.Frontend.Parser.aesopTactic?">Aesop.Frontend.Tactic</a></dd></dl></div><div id="Aesop.tacticAesop_unfold_"><h2>aesop_unfold</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Util/Tactic/Unfold.html#Aesop.tacticAesop_unfold_">Aesop.Util.Tactic.Unfold</a></dd></dl></div><div id="Aesop.tacticAesop_unfold_At_"><h2>aesop_unfold</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Util/Tactic/Unfold.html#Aesop.tacticAesop_unfold_At_">Aesop.Util.Tactic.Unfold</a></dd></dl></div><div id="Mathlib.Tactic.tacticAlgebraize__"><h2>algebraize</h2><p><p>Tactic that, given <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code>s, adds the corresponding <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> and (if possible)
<code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances, as well as <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> corresponding to <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code> properties available
as hypotheses.</p><p>Example: given <code>f : A ‚Üí+* B</code> and <code>g : B ‚Üí+* C</code>, and <code>hf : f.FiniteType</code>, <code>algebraize [f, g]</code> will
add the instances <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> A B</code>, <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> B C</code>, and <code>Algebra.FiniteType A B</code>.</p><p>See the <code>algebraize</code> tag for instructions on what properties can be added.</p><p>The tactic also comes with a configuration option <code>properties</code>. If set to <code>true</code> (default), the
tactic searches through the local context for <code><a href="./Mathlib/Algebra/Ring/Hom/Defs.html#RingHom">RingHom</a></code> properties that can be converted to
<code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> properties. The macro <code>algebraize_only</code> calls
<code>algebraize -properties</code>,
so in other words it only adds <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> and <code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Algebraize.html#Mathlib.Tactic.tacticAlgebraize__">Mathlib.Tactic.Algebraize</a></dd></dl></div><div id="Mathlib.Tactic.tacticAlgebraize_only__"><h2>algebraize_only</h2><p><p>Version of <code>algebraize</code>, which only adds <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a></code> instances and <code><a href="./Mathlib/Algebra/Group/Action/Defs.html#IsScalarTower">IsScalarTower</a></code> instances,
but does not try to add any instances about any properties tagged with
<code>@[algebraize]</code>, like for example <code><a href="./Mathlib/Data/Finite/Defs.html#Finite">Finite</a></code> or <code>IsIntegral</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Algebraize.html#Mathlib.Tactic.tacticAlgebraize_only__">Mathlib.Tactic.Algebraize</a></dd></dl></div><div id="Lean.Parser.Tactic.allGoals"><h2>all_goals</h2><p><p><code>all_goals tac</code> runs <code>tac</code> on each goal, concatenating the resulting goals.
If the tactic fails on any goal, the entire <code>all_goals</code> tactic fails.</p><p>See also <code>any_goals tac</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.allGoals">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAnd_intros"><h2>and_intros</h2><p><p><code>and_intros</code> applies <code><a href="./Init/Prelude.html#And.intro">And.intro</a></code> until it does not make progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAnd_intros">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.anyGoals"><h2>any_goals</h2><p><p><code>any_goals tac</code> applies the tactic <code>tac</code> to every goal,
concatenating the resulting goals for successful tactic applications.
If the tactic fails on all of the goals, the entire <code>any_goals</code> tactic fails.</p><p>This tactic is like <code>all_goals try tac</code> except that it fails if none of the applications of <code>tac</code> succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.anyGoals">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.tacticApply_At_"><h2>apply</h2><p><p><code>apply t at i</code> uses forward reasoning with <code>t</code> at the hypothesis <code>i</code>.
Explicitly, if <code>t : Œ±‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±·µ¢ ‚Üí ‚ãØ ‚Üí Œ±‚Çô</code> and <code>i</code> has type <code>Œ±·µ¢</code>, then this tactic adds
metavariables/goals for any terms of <code>Œ±‚±º</code> for <code>j = 1, ‚Ä¶, i-1</code>,
then replaces the type of <code>i</code> with <code>Œ±·µ¢‚Çä‚ÇÅ ‚Üí ‚ãØ ‚Üí Œ±‚Çô</code> by applying those metavariables and the
original <code>i</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ApplyAt.html#Mathlib.Tactic.tacticApply_At_">Mathlib.Tactic.ApplyAt</a></dd></dl></div><div id="Lean.Parser.Tactic.apply"><h2>apply</h2><p><p><code>apply e</code> tries to match the current goal against the conclusion of <code>e</code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code>apply</code> tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.apply">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.apply?"><h2>apply?</h2><p><p>Searches environment for definitions or theorems that can refine the goal using <code>apply</code>
with conditions resolved when possible with <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used when closing the goal.</p><p>Use <code>+grind</code> to enable <code>grind</code> as a fallback discharger for subgoals.
Use <code>+try?</code> to enable <code>try?</code> as a fallback discharger for subgoals.
Use <code>-star</code> to disable fallback to star-indexed lemmas.
Use <code>+all</code> to collect all successful lemmas instead of stopping at the first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.apply?">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.applyAssumption"><h2>apply_assumption</h2><p><p><code>apply_assumption</code> looks for an assumption of the form <code>... ‚Üí ‚àÄ _, ... ‚Üí head</code>
where <code>head</code> matches the current goal.</p><p>You can specify additional rules to apply using <code>apply_assumption [...]</code>.
By default <code>apply_assumption</code> will also try <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code>, and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.
If you don't want these, or don't want to use all hypotheses, use <code>apply_assumption only [...]</code>.
You can use <code>apply_assumption [-h]</code> to omit a local hypothesis.
You can use <code>apply_assumption using [a‚ÇÅ, ...]</code> to use all lemmas which have been labelled
with the attributes <code>a·µ¢</code> (these attributes must be created using <code>register_label_attr</code>).</p><p><code>apply_assumption</code> will use consequences of local hypotheses obtained via <code>symm</code>.</p><p>If <code>apply_assumption</code> fails, it will call <code>exfalso</code> and try again.
Thus if there is an assumption of the form <code>P ‚Üí ¬¨ Q</code>, the new tactic state
will have two goals, <code>P</code> and <code>Q</code>.</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...}) lemmas</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyAssumption">Init.Tactics</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.applyExtTheorem"><h2>apply_ext_theorem</h2><p><p>Apply a single extensionality theorem to the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.applyExtTheorem">Init.Ext</a></dd></dl></div><div id="Mathlib.Tactic.applyFun"><h2>apply_fun</h2><p><p>Apply a function to an equality or inequality in either a local hypothesis or the goal.</p><ul><li>If we have <code>h : a = b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a = f b</code>.</li><li>If we have <code>h : a ‚â§ b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a ‚â§ f b</code>,
and create a subsidiary goal <code><a href="./Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> f</code>.
<code>apply_fun</code> will automatically attempt to discharge this subsidiary goal using <code>mono</code>,
or an explicit solution can be provided with <code>apply_fun f at h using P</code>, where <code>P : <a href="./Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> f</code>.</li><li>If we have <code>h : a &lt; b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a &lt; f b</code>,
and create a subsidiary goal <code><a href="./Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> f</code> and behaves as in the previous case.</li><li>If we have <code>h : a ‚â† b</code>, then <code>apply_fun f at h</code> will replace this with <code>h : f a ‚â† f b</code>,
and create a subsidiary goal <code>Injective f</code> and behaves as in the previous two cases.</li><li>If the goal is <code>a ‚â† b</code>, <code>apply_fun f</code> will replace this with <code>f a ‚â† f b</code>.</li><li>If the goal is <code>a = b</code>, <code>apply_fun f</code> will replace this with <code>f a = f b</code>,
and create a subsidiary goal <code>injective f</code>.
<code>apply_fun</code> will automatically attempt to discharge this subsidiary goal using local hypotheses,
or if <code>f</code> is actually an <code><a href="./Mathlib/Logic/Equiv/Defs.html#Equiv">Equiv</a></code>,
or an explicit solution can be provided with <code>apply_fun f using P</code>, where <code>P : Injective f</code>.</li><li>If the goal is <code>a ‚â§ b</code> (or similarly for <code>a &lt; b</code>), and <code>f</code> is actually an <code><a href="./Mathlib/Order/Hom/Basic.html#OrderIso">OrderIso</a></code>,
<code>apply_fun f</code> will replace the goal with <code>f a ‚â§ f b</code>.
If <code>f</code> is anything else (e.g. just a function, or an <code><a href="./Mathlib/Logic/Equiv/Defs.html#Equiv">Equiv</a></code>), <code>apply_fun</code> will fail.</li></ul><p>Typical usage is:</p><pre><code class="language-lean">open Function

example (X Y Z : Type) (f : X ‚Üí Y) (g : Y ‚Üí Z) (H : Injective &lt;| g ‚àò f) :
    Injective f := by
  intro x x' h
  apply_fun g at h
  exact H h
</code></pre><p>The function <code>f</code> is handled similarly to how it would be handled by <code>refine</code> in that <code>f</code> can contain
placeholders. Named placeholders (like <code>?a</code> or <code>?_</code>) will produce new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ApplyFun.html#Mathlib.Tactic.applyFun">Mathlib.Tactic.ApplyFun</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticApply_mod_cast_"><h2>apply_mod_cast</h2><p><p>Normalize casts in the goal and the given expression, then <code>apply</code> the expression to the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticApply_mod_cast_">Init.TacticsExtra</a></dd></dl></div><div id="Mathlib.Tactic.tacticApply_rewrite___"><h2>apply_rewrite</h2><p><p><code>apply_rewrite [rules]</code> is a shorthand for <code>grewrite +implicationHyp [rules]</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticApply_rewrite___">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Lean.Parser.Tactic.applyRfl"><h2>apply_rfl</h2><p><p>The same as <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, but without trying <code>eq_refl</code> at the end.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.applyRules"><h2>apply_rules</h2><p><p><code>apply_rules [l‚ÇÅ, l‚ÇÇ, ...]</code> tries to solve the main goal by iteratively
applying the list of lemmas <code>[l‚ÇÅ, l‚ÇÇ, ...]</code> or by applying a local hypothesis.
If <code>apply</code> generates new goals, <code>apply_rules</code> iteratively tries to solve those goals.
You can use <code>apply_rules [-h]</code> to omit a local hypothesis.</p><p><code>apply_rules</code> will also use <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.
These can be disabled, as can local hypotheses, by using <code>apply_rules only [...]</code>.</p><p>You can use <code>apply_rules using [a‚ÇÅ, ...]</code> to use all lemmas which have been labelled
with the attributes <code>a·µ¢</code> (these attributes must be created using <code>register_label_attr</code>).</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...})</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p><p><code>apply_rules</code> will try calling <code>symm</code> on hypotheses and <code>exfalso</code> on the goal as needed.
This can be disabled with <code>apply_rules (config := {symm := false, exfalso := false})</code>.</p><p>You can bound the iteration depth using the syntax <code>apply_rules (config := {maxDepth := n})</code>.</p><p>Unlike <code>solve_by_elim</code>, <code>apply_rules</code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.applyRules">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.applyRwSeq"><h2>apply_rw</h2><p><p><code>apply_rw [rules]</code> is a shorthand for <code>grw +implicationHyp [rules]</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.applyRwSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Array.tacticArray_get_dec"><h2>array_get_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that
<code>sizeOf arr[i] &lt; sizeOf arr</code>, which is useful for well founded recursions
over a nested inductive like <code>inductive T | mk : <a href="./Init/Prelude.html#Array">Array</a> T ‚Üí T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/Array/Mem.html#Array.tacticArray_get_dec">Init.Data.Array.Mem</a></dd></dl></div><div id="Array.tacticArray_mem_dec"><h2>array_mem_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that <code>sizeOf a &lt; sizeOf arr</code>
provided that <code>a ‚àà arr</code> which is useful for well founded recursions over a nested inductive like
<code>inductive T | mk : <a href="./Init/Prelude.html#Array">Array</a> T ‚Üí T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/Array/Mem.html#Array.tacticArray_mem_dec">Init.Data.Array.Mem</a></dd></dl></div><div id="Lean.Parser.Tactic.as_aux_lemma"><h2>as_aux_lemma</h2><p><p><code>as_aux_lemma =&gt; tac</code> does the same as <code>tac</code>, except that it wraps the resulting expression
into an auxiliary lemma. In some cases, this significantly reduces the size of expressions
because the proof term is not duplicated.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.as_aux_lemma">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.assumption"><h2>assumption</h2><p><p><code>assumption</code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‚Äπt‚Ä∫</code> term notation, which is a shorthand for <code>show t by assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.assumption">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.tacticAssumption'"><h2>assumption'</h2><p><p>Try calling <code>assumption</code> on all goals; succeeds if it closes at least one goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticAssumption'">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticAssumption_mod_cast_"><h2>assumption_mod_cast</h2><p><p><code>assumption_mod_cast</code> is a variant of <code>assumption</code> that solves the goal
using a hypothesis. Unlike <code>assumption</code>, it first pre-processes the goal and
each hypothesis to move casts as far outwards as possible, so it can be used
in more situations.</p><p>Concretely, it runs <code>norm_cast</code> on the goal. For each local hypothesis <code>h</code>, it also
normalizes <code>h</code> with <code>norm_cast</code> and tries to use that to close the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticAssumption_mod_cast_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.attemptAll"><h2>attempt_all</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.attemptAll">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.attemptAllPar"><h2>attempt_all_par</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code> with parallel execution.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.attemptAllPar">Init.Try</a></dd></dl></div><div id="Mathlib.Tactic.Group.aux_group‚ÇÅ"><h2>aux_group‚ÇÅ</h2><p><p>Auxiliary tactic for the <code>group</code> tactic. Calls the simplifier only.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.aux_group‚ÇÅ">Mathlib.Tactic.Group</a></dd></dl></div><div id="Mathlib.Tactic.Group.aux_group‚ÇÇ"><h2>aux_group‚ÇÇ</h2><p><p>Auxiliary tactic for the <code>group</code> tactic. Calls <code>ring_nf</code> to normalize exponents.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.aux_group‚ÇÇ">Mathlib.Tactic.Group</a></dd></dl></div><div id="tacticBddDefault"><h2>bddDefault</h2><p><p>Sets are automatically bounded or cobounded in complete lattices. To use the same statements
in complete and conditionally complete lattices but let automation fill automatically the
boundedness proofs in complete lattices, we use the tactic <code>bddDefault</code> in the statements,
in the form <code>(hA : <a href="./Mathlib/Order/Bounds/Defs.html#BddAbove">BddAbove</a> A := by bddDefault)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Bounds/Basic.html#tacticBddDefault">Mathlib.Order.Bounds.Basic</a></dd></dl></div><div id="Mathlib.Tactic.betaReduceStx"><h2>beta_reduce</h2><p><p><code>beta_reduce at loc</code> completely beta reduces the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>This means that whenever there is an applied lambda expression such as
<code>(fun x =&gt; f x) y</code> then the argument is substituted into the lambda expression
yielding an expression such as <code>f y</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.Borelize.tacticBorelize___"><h2>borelize</h2><p><p>The behaviour of <code>borelize Œ±</code> depends on the existing assumptions on <code>Œ±</code>.</p><ul><li>if <code>Œ±</code> is a topological space with instances <code>[MeasurableSpace Œ±] [BorelSpace Œ±]</code>, then
<code>borelize Œ±</code> replaces the former instance by <code><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#borel">borel</a> Œ±</code>;</li><li>otherwise, <code>borelize Œ±</code> adds instances <code><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#borel">borel</a> Œ± : <a href="./Mathlib/MeasureTheory/MeasurableSpace/Defs.html#MeasurableSpace">MeasurableSpace</a> Œ±</code> and <code>‚ü®rfl‚ü© : <a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#BorelSpace">BorelSpace</a> Œ±</code>.</li></ul><p>Finally, <code>borelize Œ± Œ≤ Œ≥</code> runs <code>borelize Œ±; borelize Œ≤; borelize Œ≥</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.html#Mathlib.Tactic.Borelize.tacticBorelize___">Mathlib.MeasureTheory.Constructions.BorelSpace.Basic</a></dd></dl></div><div id="¬´tacticBound[_]¬ª"><h2>bound</h2><p><p><code>bound</code> tactic for proving inequalities via straightforward recursion on expression structure.</p><p>An example use case is</p><pre><code>-- Calc example: A weak lower bound for `z ‚Ü¶ z^2 + c`
<a href="./Mathlib/Tactic/Lemma.html#lemma">lemma</a> le_sqr_add (c z : ‚Ñù) (cz : ‚Äñc‚Äñ ‚â§ ‚Äñz‚Äñ) (z3 : 3 ‚â§ ‚Äñz‚Äñ) :
    2 * ‚Äñz‚Äñ ‚â§ ‚Äñz^2 + c‚Äñ := by
  calc ‚Äñz^2 + c‚Äñ
    _ ‚â• ‚Äñz^2‚Äñ - ‚Äñc‚Äñ := by bound
    _ ‚â• ‚Äñz^2‚Äñ - ‚Äñz‚Äñ := by  bound
    _ ‚â• (‚Äñz‚Äñ - 1) * ‚Äñz‚Äñ := by
      rw [mul_comm, mul_sub_one, ‚Üê pow_two, ‚Üê norm_pow]
    _ ‚â• 2 * ‚Äñz‚Äñ := by bound
</code></pre><p><code>bound</code> is built on top of <code>aesop</code>, and uses</p><ol><li>Apply lemmas registered via the <code>@[bound]</code> attribute</li><li>Forward lemmas registered via the <code>@[bound_forward]</code> attribute</li><li>Local hypotheses from the context</li><li>Optionally: additional hypotheses provided as <code>bound [h‚ÇÄ, h‚ÇÅ]</code> or similar. These are added to the
context as if by <code>have := h·µ¢</code>.</li></ol><p>The functionality of <code>bound</code> overlaps with <code>positivity</code> and <code>gcongr</code>, but can jump back and forth
between <code>0 ‚â§ x</code> and <code>x ‚â§ y</code>-type inequalities.  For example, <code>bound</code> proves
<code>0 ‚â§ c ‚Üí b ‚â§ a ‚Üí 0 ‚â§ a * c - b * c</code>
by turning the goal into <code>b * c ‚â§ a * c</code>, then using <code><a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#mul_le_mul_of_nonneg_right">mul_le_mul_of_nonneg_right</a></code>.  <code>bound</code> also
contains lemmas for goals of the form <code>1 ‚â§ x, 1 &lt; x, x ‚â§ 1, x &lt; 1</code>.  Conversely, <code>gcongr</code> can prove
inequalities for more types of relations, supports all <code>positivity</code> functionality, and is likely
faster since it is more specialized (not built atop <code>aesop</code>).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Bound.html#¬´tacticBound[_]¬ª">Mathlib.Tactic.Bound</a></dd></dl></div><div id="Lean.Parser.Tactic.bvCheck"><h2>bv_check</h2><p><p>This tactic works just like <code>bv_decide</code> but skips calling a SAT solver by using a proof that is
already stored on disk. It is called with the name of an LRAT file in the same directory as the
current Lean file:</p><pre><code>bv_check &quot;proof.lrat&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/BVDecide/Syntax.html#Lean.Parser.Tactic.bvCheck">Std.Tactic.BVDecide.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.bvDecideMacro"><h2>bv_decide</h2><p><p>Close fixed-width <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> and <code><a href="./Init/Prelude.html#Bool">Bool</a></code> goals by obtaining a proof from an external SAT solver and
verifying it inside Lean. The solvable goals are currently limited to</p><ul><li>the Lean equivalent of <a href="https://smt-lib.org/logics-all.shtml#QF_BV"><code>QF_BV</code></a></li><li>automatically splitting up <code>structure</code>s that contain information about <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> or <code><a href="./Init/Prelude.html#Bool">Bool</a></code></li></ul><pre><code class="language-lean">example : ‚àÄ (a b : <a href="./Init/Prelude.html#BitVec">BitVec</a> 64), (a &amp;&amp;&amp; b) + (a ^^^ b) = a ||| b := by
  intros
  bv_decide
</code></pre><p>If <code>bv_decide</code> encounters an unknown definition it will be treated like an unconstrained <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code>
variable. Sometimes this enables solving goals despite not understanding the definition because
the precise properties of the definition do not matter in the specific proof.</p><p>If <code>bv_decide</code> fails to close a goal it provides a counter-example, containing assignments for all
terms that were considered as variables.</p><p>In order to avoid calling a SAT solver every time, the proof can be cached with <code>bv_decide?</code>.</p><p>If solving your problem relies inherently on using associativity or commutativity, consider enabling
the <code>bv.ac_nf</code> option.</p><p>Note: <code>bv_decide</code> uses <code>ofReduceBool</code> and thus trusts the correctness of the code generator.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvDecideMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.bvTraceMacro"><h2>bv_decide?</h2><p><p>Suggest a proof script for a <code>bv_decide</code> tactic call. Useful for caching LRAT proofs.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvTraceMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.bvNormalizeMacro"><h2>bv_normalize</h2><p><p>Run the normalization procedure of <code>bv_decide</code> only. Sometimes this is enough to solve basic
<code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> goals already.</p><p>Note: include <code>import Std.Tactic.BVDecide</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.bvNormalizeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticBv_omega"><h2>bv_omega</h2><p><p><code>bv_omega</code> is <code>omega</code> with an additional preprocessor that turns statements about <code><a href="./Init/Prelude.html#BitVec">BitVec</a></code> into statements about <code><a href="./Init/Prelude.html#Nat">Nat</a></code>.
Currently the preprocessor is implemented as <code>try simp only [bitvec_to_nat] at *</code>.
<code>bitvec_to_nat</code> is a <code>@[simp]</code> attribute that you can (cautiously) add to more theorems.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticBv_omega">Init.Tactics</a></dd></dl></div><div id="¬´tacticBy_cases_:_¬ª"><h2>by_cases</h2><p><p><code>by_cases (h :)? p</code> splits the main goal into two cases, assuming <code>h : p</code> in the first branch, and <code>h : ¬¨ p</code> in the second branch.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/ByCases.html#¬´tacticBy_cases_:_¬ª">Init.ByCases</a></dd></dl></div><div id="Mathlib.Tactic.ByCases.byCases!"><h2>by_cases!</h2><p><p><code>by_cases! h : p</code> runs the <code><a href="./Mathlib/Logic/Basic.html#by_cases">by_cases</a> h : p</code> tactic, followed by
<code>push_neg at h</code> in the second subgoal. For example,</p><ul><li><code>by_cases! h : a &lt; b</code> creates one goal with hypothesis <code>h : a &lt; b</code> and
another with <code>h : b ‚â§ a</code>.</li><li><code>by_cases! h : a ‚â† b</code> creates one goal with hypothesis <code>h : a ‚â† b</code> and
another with <code>h : a = b</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ByCases.html#Mathlib.Tactic.ByCases.byCases!">Mathlib.Tactic.ByCases</a></dd></dl></div><div id="Batteries.Tactic.byContra"><h2>by_contra</h2><p><p><code>by_contra h</code> proves <code>‚ä¢ p</code> by contradiction,
introducing a hypothesis <code>h : ¬¨p</code> and proving <code><a href="./Init/Prelude.html#False">False</a></code>.</p><ul><li>If <code>p</code> is a negation <code>¬¨q</code>, <code>h : q</code> will be introduced instead of <code>¬¨¬¨q</code>.</li><li>If <code>p</code> is decidable, it uses <code><a href="./Init/Core.html#Decidable.byContradiction">Decidable.byContradiction</a></code> instead of <code><a href="./Init/Classical.html#Classical.byContradiction">Classical.byContradiction</a></code>.</li><li>If <code>h</code> is omitted, the introduced variable will be called <code>this</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.byContra">Batteries.Tactic.Init</a></dd></dl></div><div id="Mathlib.Tactic.ByContra.byContra!"><h2>by_contra!</h2><p><p>If the target of the main goal is a proposition <code>p</code>,
<code>by_contra!</code> reduces the goal to proving <code><a href="./Init/Prelude.html#False">False</a></code> using the additional hypothesis <code>this : ¬¨ p</code>.
<code>by_contra! h</code> can be used to name the hypothesis <code>h : ¬¨ p</code>.
The hypothesis <code>¬¨ p</code> will be normalized using <code>push_neg</code>.
For instance, <code>¬¨ a &lt; b</code> will be changed to <code>b ‚â§ a</code>.
<code>by_contra!</code> can be used with <code>rcases</code> patterns.
For instance, <code>by_contra! <a href="./Init/Prelude.html#rfl">rfl</a></code> on <code>‚ä¢ s.<a href="./Init/Prelude.html#Nonempty">Nonempty</a></code> will substitute the equality <code>s = ‚àÖ</code>,
and <code>by_contra! ‚ü®hp, hq‚ü©</code> on <code>‚ä¢ ¬¨ p ‚à® ¬¨ q</code> will introduce <code>hp : p</code> and <code>hq : q</code>.
<code>by_contra! h : q</code> will normalize negations in <code>¬¨ p</code>, normalize negations in <code>q</code>,
and then check that the two normalized forms are equal.
The resulting hypothesis is the pre-normalized form, <code>q</code>.
If the name <code>h</code> is not explicitly provided, then <code>this</code> will be used as name.
This tactic uses classical reasoning.
It is a variant on the tactic <code><a href="./Mathlib/Logic/Basic.html#by_contra">by_contra</a></code>.
Examples:</p><pre><code class="language-lean">example : 1 &lt; 2 := by
  by_contra! h
  -- h : 2 ‚â§ 1 ‚ä¢ <a href="./Init/Prelude.html#False">False</a>

example : 1 &lt; 2 := by
  by_contra! h : ¬¨ 1 &lt; 2
  -- h : ¬¨ 1 &lt; 2 ‚ä¢ <a href="./Init/Prelude.html#False">False</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ByContra.html#Mathlib.Tactic.ByContra.byContra!">Mathlib.Tactic.ByContra</a></dd></dl></div><div id="Lean.calcTactic"><h2>calc</h2><p><p>Step-wise reasoning over transitive relations.</p><pre><code>calc
  a = b := pab
  b = c := pbc
  ...
  y = z := pyz
</code></pre><p>proves <code>a = z</code> from the given step-wise proofs. <code>=</code> can be replaced with any
relation implementing the typeclass <code><a href="./Init/Prelude.html#Trans">Trans</a></code>. Instead of repeating the right-
hand sides, subsequent left-hand sides can be replaced with <code>_</code>.</p><pre><code>calc
  a = b := pab
  _ = c := pbc
  ...
  _ = z := pyz
</code></pre><p>It is also possible to write the <em>first</em> relation as <code>&lt;lhs&gt;\n  _ = &lt;rhs&gt; := &lt;proof&gt;</code>. This is useful for aligning relation symbols, especially on longer
identifiers:</p><pre><code>calc abc
  _ = bce := pabce
  _ = cef := pbcef
  ...
  _ = xyz := pwxyz
</code></pre><p><code>calc</code> works as a term, as a tactic or as a <code>conv</code> tactic.</p><p>See <a href="https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs">Theorem Proving in Lean 4</a> for more information.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.calcTactic">Init.NotationExtra</a></dd></dl></div><div id="Lean.Elab.Tactic.tacticCalc?"><h2>calc?</h2><p><p>Create a <code>calc</code> proof.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/Calc.html#Lean.Elab.Tactic.tacticCalc?">Mathlib.Tactic.Widget.Calc</a></dd></dl></div><div id="cancelDenoms"><h2>cancel_denoms</h2><p><p><code>cancel_denoms</code> attempts to remove numerals from the denominators of fractions.
It works on propositions that are field-valued inequalities.</p><pre><code class="language-lean">variable [LinearOrderedField Œ±] (a b c : Œ±)

example (h : a / 5 + b / 4 &lt; c) : 4*a + 5*b &lt; 20*c := by
  cancel_denoms at h
  exact h

example (h : a &gt; 0) : a / 5 &gt; 0 := by
  cancel_denoms
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CancelDenoms/Core.html#cancelDenoms">Mathlib.Tactic.CancelDenoms.Core</a></dd></dl></div><div id="Batteries.Tactic.casePatt"><h2>case</h2><p><ul><li><p><code>case _ : t =&gt; tac</code> finds the first goal that unifies with <code>t</code> and then solves it
using <code>tac</code> or else fails. Like <code>show</code>, it changes the type of the goal to <code>t</code>.
The <code>_</code> can optionally be a case tag, in which case it only looks at goals
whose tag would be considered by <code>case</code> (goals with an exact tag match,
followed by goals with the tag as a suffix, followed by goals with the tag as a prefix).</p></li><li><p><code>case _ n‚ÇÅ ... n‚Çò : t =&gt; tac</code> additionally names the <code>m</code> most recent hypotheses with
inaccessible names to the given names. The names are renamed before matching against <code>t</code>.
The <code>_</code> can optionally be a case tag.</p></li><li><p><code>case _ : t := e</code> is short for <code>case _ : t =&gt; exact e</code>.</p></li><li><p><code>case _ : t‚ÇÅ | _ : t‚ÇÇ | ... =&gt; tac</code>
is equivalent to <code>(case _ : t‚ÇÅ =&gt; tac); (case _ : t‚ÇÇ =&gt; tac); ...</code>
but with all matching done on the original list of goals --
each goal is consumed as they are matched, so patterns may repeat or overlap.</p></li><li><p><code>case _ : t</code> will make the matched goal be the first goal.
<code>case _ : t‚ÇÅ | _ : t‚ÇÇ | ...</code> makes the matched goals be the first goals in the given order.</p></li><li><p><code>case _ : t := _</code> and <code>case _ : t := ?m</code> are the same as <code>case _ : t</code> but in the <code>?m</code> case the
goal tag is changed to <code>m</code>.
In particular, the goal becomes metavariable <code>?m</code>.</p></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt">Batteries.Tactic.Case</a></dd></dl></div><div id="Lean.Parser.Tactic.case"><h2>case</h2><p><ul><li><code>case tag =&gt; tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>,
or else fails.</li><li><code>case tag x‚ÇÅ ... x‚Çô =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses
with inaccessible names to the given names.</li><li><code>case tag‚ÇÅ | tag‚ÇÇ =&gt; tac</code> is equivalent to <code>(case tag‚ÇÅ =&gt; tac); (case tag‚ÇÇ =&gt; tac)</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.case">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.case'"><h2>case'</h2><p><p><code>case'</code> is similar to the <code>case tag =&gt; tac</code> tactic, but does not ensure the goal
has been solved after applying <code>tac</code>, nor admits the goal if <code>tac</code> failed.
Recall that <code>case</code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.case'">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.casePatt'"><h2>case'</h2><p><p><code>case' _ : t =&gt; tac</code> is similar to the <code>case _ : t =&gt; tac</code> tactic,
but it does not ensure the goal has been solved after applying <code>tac</code>,
nor does it admit the goal if <code>tac</code> failed.
Recall that <code>case</code> closes the goal using <code>sorry</code> when <code>tac</code> fails,
and the tactic execution is not interrupted.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Case.html#Batteries.Tactic.casePatt'">Batteries.Tactic.Case</a></dd></dl></div><div id="Lean.Parser.Tactic.cases"><h2>cases</h2><p><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code>cases x</code> splits the main goal, producing one goal for each constructor of the
inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well.
<code>cases</code> detects unreachable cases and closes them automatically.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code>cases n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypothesis <code>h : P (Nat.succ a)</code> and target <code>Q (Nat.succ a)</code>.
Here the name <code>a</code> is chosen automatically and is not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul><li><code>cases e</code>, where <code>e</code> is an expression instead of a variable, generalizes <code>e</code> in the goal,
and then cases on the resulting variable.</li><li>Given <code>as : <a href="./Init/Prelude.html#List">List</a> Œ±</code>, <code>cases as with | nil =&gt; tac‚ÇÅ | cons a as' =&gt; tac‚ÇÇ</code>,
uses tactic <code>tac‚ÇÅ</code> for the <code>nil</code> case, and <code>tac‚ÇÇ</code> for the <code>cons</code> case,
and <code>a</code> and <code>as'</code> are used as names for the new variables introduced.</li><li><code>cases h : e</code>, where <code>e</code> is a variable or an expression,
performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each goal,
where <code>...</code> is the constructor instance for that particular case.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.cases">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.casesType"><h2>cases_type</h2><p><p><code>cases_type I</code> searches for a hypothesis <code>h : type</code> where <code>I</code> has the form <code>(I ...)</code>, and splits the
main goal by cases on <code>h</code>. <code>cases_type p</code> fails if no hypothesis type has the identifier <code>I</code> as its
head symbol.</p><ul><li><code>cases_type I_1 ... I_n</code> searches for a hypothesis <code>h : type</code> where <code>type</code> has one or more of
<code>I_1</code>, ..., <code>I_n</code> as its head symbol, and splits the main goal by cases on <code>h</code>.</li><li><code>cases_type* I</code> repeatedly performs case splits until no more hypothesis type has <code>I</code> as its head
symbol. This shorthand for <code>¬∑ repeat cases_type I</code>.</li><li><code>cases_type! p</code> and <code>cases_type!* p</code> skip a hypothesis if the main goal would be replaced with two
or more subgoals.</li></ul><p>Example:</p><pre><code>example (h : a ‚àß b ‚à® c ‚àß d) (h2 : e ‚àß f) : <a href="./Init/Prelude.html#True">True</a> := by
  -- The following tactic destructs all conjunctions and disjunctions in the current context.
  cases_type* <a href="./Init/Prelude.html#Or">Or</a> <a href="./Init/Prelude.html#And">And</a>
  ¬∑ clear ‚Äπa‚Ä∫ ‚Äπb‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; (fail_if_success clear ‚Äπc‚Ä∫); <a href="./Init/Core.html#trivial">trivial</a>
  ¬∑ clear ‚Äπc‚Ä∫ ‚Äπd‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; <a href="./Init/Core.html#trivial">trivial</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesType">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="Mathlib.Tactic.casesM"><h2>casesm</h2><p><p><code>casesm p</code> searches for the first hypothesis <code>h : type</code> where <code>type</code> matches the term <code>p</code>,
and splits the main goal by cases on <code>h</code>. Use holes in <code>p</code> to indicate arbitrary subexpressions,
for example <code>casesm _ ‚àß _</code> will match any conjunction. <code>casesm p</code> fails if no hypothesis type
matches <code>p</code>.</p><ul><li><code>casesm p_1, ..., p_n</code> searches for a hypothesis <code>h : type</code> where <code>type</code> matches one or more of
the given patterns <code>p_1</code>, ... <code>p_n</code>, and splits the main goal by cases on <code>h</code>.</li><li><code>casesm* p</code> repeatedly performs case splits until no more hypothesis type matches <code>p</code>.
This is a more efficient and compact version of <code>¬∑ repeat casesm p</code>.
It is more efficient because the pattern is compiled once.</li><li><code>casesm! p</code> and <code>casesm!* p</code> skip a hypothesis if the main goal would be replaced with two or more
subgoals.</li></ul><p>Example:</p><pre><code>example (h : a ‚àß b ‚à® c ‚àß d) (h2 : e ‚àß f) : <a href="./Init/Prelude.html#True">True</a> := by
  -- The following tactic destructs all conjunctions and disjunctions in the current context.
  casesm* _‚à®_, _‚àß_
  ¬∑ clear ‚Äπa‚Ä∫ ‚Äπb‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; (fail_if_success clear ‚Äπc‚Ä∫); <a href="./Init/Core.html#trivial">trivial</a>
  ¬∑ clear ‚Äπc‚Ä∫ ‚Äπd‚Ä∫ ‚Äπe‚Ä∫ ‚Äπf‚Ä∫; <a href="./Init/Core.html#trivial">trivial</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.casesM">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="cfcContTac"><h2>cfc_cont_tac</h2><p><p>A tactic used to automatically discharge goals relating to the continuous functional calculus,
specifically concerning continuity of the functions involved.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcContTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="cfcTac"><h2>cfc_tac</h2><p><p>A tactic used to automatically discharge goals relating to the continuous functional calculus,
specifically whether the element satisfies the predicate.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="cfcZeroTac"><h2>cfc_zero_tac</h2><p><p>A tactic used to automatically discharge goals relating to the non-unital continuous functional
calculus, specifically concerning whether <code>f 0 = 0</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ContinuousFunctionalCalculus.html#cfcZeroTac">Mathlib.Tactic.ContinuousFunctionalCalculus</a></dd></dl></div><div id="Lean.Parser.Tactic.change"><h2>change</h2><p><ul><li><code>change tgt'</code> will change the goal from <code>tgt</code> to <code>tgt'</code>,
assuming these are definitionally equal.</li><li><code>change t' at h</code> will change hypothesis <code>h : t</code> to have type <code>t'</code>, assuming
assuming <code>t</code> and <code>t'</code> are definitionally equal.</li><li><code>change a with b</code> will change occurrences of <code>a</code> to <code>b</code> in the goal,
assuming <code>a</code> and <code>b</code> are definitionally equal.</li><li><code>change a with b at h</code> similarly changes <code>a</code> to <code>b</code> in the type of hypothesis <code>h</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.change">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Choose.choose"><h2>choose</h2><p><ul><li><p><code>choose a b h h' using hyp</code> takes a hypothesis <code>hyp</code> of the form
<code>‚àÄ (x : X) (y : Y), ‚àÉ (a : A) (b : B), P x y a b ‚àß Q x y a b</code>
for some <code>P Q : X ‚Üí Y ‚Üí A ‚Üí B ‚Üí Prop</code> and outputs
into context a function <code>a : X ‚Üí Y ‚Üí A</code>, <code>b : X ‚Üí Y ‚Üí B</code> and two assumptions:
<code>h : ‚àÄ (x : X) (y : Y), P x y (a x y) (b x y)</code> and
<code>h' : ‚àÄ (x : X) (y : Y), Q x y (a x y) (b x y)</code>. It also works with dependent versions.</p></li><li><p><code>choose! a b h h' using hyp</code> does the same, except that it will remove dependency of
the functions on propositional arguments if possible. For example if <code>Y</code> is a proposition
and <code>A</code> and <code>B</code> are nonempty in the above example then we will instead get
<code>a : X ‚Üí A</code>, <code>b : X ‚Üí B</code>, and the assumptions
<code>h : ‚àÄ (x : X) (y : Y), P x y (a x) (b x)</code> and
<code>h' : ‚àÄ (x : X) (y : Y), Q x y (a x) (b x)</code>.</p></li></ul><p>The <code>using hyp</code> part can be omitted,
which will effectively cause <code>choose</code> to start with an <code>intro hyp</code>.</p><p>Like <code>intro</code>, the <code>choose</code> tactic supports type annotations to specify the expected type
of the introduced variables. This is useful for documentation and for catching mistakes early:</p><pre><code>example (h : ‚àÉ n : ‚Ñï, n &gt; 0) : <a href="./Init/Prelude.html#True">True</a> := by
  choose (n : ‚Ñï) (hn : n &gt; 0) using h
  <a href="./Init/Core.html#trivial">trivial</a>
</code></pre><p>If the provided type does not match the actual type, an error is raised.</p><p>Examples:</p><pre><code>example (h : ‚àÄ n m : ‚Ñï, ‚àÉ i j, m = n + i ‚à® m + j = n) : <a href="./Init/Prelude.html#True">True</a> := by
  choose i j h using h
  guard_hyp i : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  guard_hyp j : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
  guard_hyp h : ‚àÄ (n m : ‚Ñï), m = n + i n m ‚à® m + j n m = n
  <a href="./Init/Core.html#trivial">trivial</a>
</code></pre><pre><code>example (h : ‚àÄ i : ‚Ñï, i &lt; 7 ‚Üí ‚àÉ j, i &lt; j ‚àß j &lt; i+i) : <a href="./Init/Prelude.html#True">True</a> := by
  choose! f h h' using h
  guard_hyp f : ‚Ñï ‚Üí ‚Ñï
  guard_hyp h : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí i &lt; f i
  guard_hyp h' : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí f i &lt; i + i
  <a href="./Init/Core.html#trivial">trivial</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose">Mathlib.Tactic.Choose</a></dd></dl></div><div id="Lean.Parser.Tactic.classical"><h2>classical</h2><p><p><code>classical tacs</code> runs <code>tacs</code> in a scope where <code><a href="./Init/Classical.html#Classical.propDecidable">Classical.propDecidable</a></code> is a low priority
local instance.</p><p>Note that <code>classical</code> is a scoping tactic: it adds the instance only within the
scope of the tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.classical">Init.Tactics</a></dd></dl></div><div id="tacticClean_wf"><h2>clean_wf</h2><p><p>This tactic is used internally by lean before presenting the proof obligations from a well-founded
definition to the user via <code>decreasing_by</code>. It is not necessary to use this tactic manually.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticClean_wf">Init.WFTactics</a></dd></dl></div><div id="Lean.Elab.Tactic.clearExceptTactic"><h2>clear</h2><p><p>Clears all hypotheses it can, except those provided after a minus sign. Example:</p><pre><code>  clear * - h‚ÇÅ h‚ÇÇ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ClearExcept.html#Lean.Elab.Tactic.clearExceptTactic">Mathlib.Tactic.ClearExcept</a></dd></dl></div><div id="Lean.Parser.Tactic.clear"><h2>clear</h2><p><p><code>clear x...</code> removes the given hypotheses, or fails if there are remaining
references to a hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.clear">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.clear!"><h2>clear!</h2><p><p>A variant of <code>clear</code> which clears not only the given hypotheses but also any other hypotheses
depending on them</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ClearExclamation.html#Mathlib.Tactic.clear!">Mathlib.Tactic.ClearExclamation</a></dd></dl></div><div id="Mathlib.Tactic.clear_"><h2>clear_</h2><p><p>Clear all hypotheses starting with <code>_</code>, like <code>_match</code> and <code>_let_match</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Clear_.html#Mathlib.Tactic.clear_">Mathlib.Tactic.Clear_</a></dd></dl></div><div id="Mathlib.Tactic.clearAuxDecl"><h2>clear_aux_decl</h2><p><p>This tactic clears all auxiliary declarations from the context.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearAuxDecl">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Lean.Parser.Tactic.clearValue"><h2>clear_value</h2><p><ul><li><p><code>clear_value x...</code> clears the values of the given local definitions.
A local definition <code>x : Œ± := v</code> becomes a hypothesis <code>x : Œ±</code>.</p></li><li><p><code>clear_value (h : x = _)</code> adds a hypothesis <code>h : x = v</code> before clearing the value of <code>x</code>.
This is short for <code>have h : x = v := rfl; clear_value x</code>.
Any value definitionally equal to <code>v</code> can be used in place of <code>_</code>.</p></li><li><p><code>clear_value *</code> clears values of all hypotheses that can be cleared.
Fails if none can be cleared.</p></li></ul><p>These syntaxes can be combined. For example, <code>clear_value x y *</code> ensures that <code>x</code> and <code>y</code> are cleared
while trying to clear all other local definitions,
and <code>clear_value (hx : x = _) y * with hx</code> does the same while first adding the <code>hx : x = v</code> hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.clearValue">Init.Tactics</a></dd></dl></div><div id="tacticCompareOfLessAndEq_rfl"><h2>compareOfLessAndEq_rfl</h2><p><p>This attempts to prove that a given instance of <code>compare</code> is equal to <code><a href="./Init/Data/Ord/Basic.html#compareOfLessAndEq">compareOfLessAndEq</a></code> by
introducing the arguments and trying the following approaches in order:</p><ol><li>seeing if <code><a href="./Init/Prelude.html#rfl">rfl</a></code> works</li><li>seeing if the <code>compare</code> at hand is nonetheless essentially <code><a href="./Init/Data/Ord/Basic.html#compareOfLessAndEq">compareOfLessAndEq</a></code>, but, because of
implicit arguments, requires us to unfold the defs and split the <code>if</code>s in the definition of
<code><a href="./Init/Data/Ord/Basic.html#compareOfLessAndEq">compareOfLessAndEq</a></code></li><li>seeing if we can split by cases on the arguments, then see if the defs work themselves out
(useful when <code>compare</code> is defined via a <code>match</code> statement, as it is for <code><a href="./Init/Prelude.html#Bool">Bool</a></code>)</li></ol></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Defs/LinearOrder.html#tacticCompareOfLessAndEq_rfl">Mathlib.Order.Defs.LinearOrder</a></dd></dl></div><div id="Mathlib.Tactic.ComputeDegree.computeDegree"><h2>compute_degree</h2><p><p><code>compute_degree</code> is a tactic to solve goals of the form</p><ul><li><code>natDegree f = d</code>,</li><li><code>degree f = d</code>,</li><li><code>natDegree f ‚â§ d</code> (or <code>&lt;</code>),</li><li><code>degree f ‚â§ d</code> (or <code>&lt;</code>),</li><li><code>coeff f d = r</code>, if <code>d</code> is the degree of <code>f</code>.</li></ul><p>The tactic may leave goals of the form <code>d' = d</code>, <code>d' ‚â§ d</code>, <code>d' &lt; d</code>, or <code>r ‚â† 0</code>, where <code>d'</code> in <code>‚Ñï</code>
or <code><a href="./Mathlib/Order/TypeTags.html#WithBot">WithBot</a> ‚Ñï</code> is the tactic's guess of the degree, and <code>r</code> is the coefficient's guess of the
leading coefficient of <code>f</code>.</p><p><code>compute_degree</code> applies <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> to the left-hand side of all side goals, trying to close them.</p><p>The variant <code>compute_degree!</code> first applies <code>compute_degree</code>.
Then it uses <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> on all the remaining goals and tries <code>assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ComputeDegree.html#Mathlib.Tactic.ComputeDegree.computeDegree">Mathlib.Tactic.ComputeDegree</a></dd></dl></div><div id="Batteries.Tactic.congrConfigWith"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>‚ä¢ f as = f bs</code> and <code>‚ä¢ f as ‚âç f bs</code>.</p><ul><li><code><a href="./Init/Prelude.html#congr">congr</a> n</code> controls the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>‚ä¢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>‚ä¢ x = y</code> and <code>‚ä¢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>‚ä¢ x + y = y + x</code>.</li><li>If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.</li><li>You can use <code><a href="./Init/Prelude.html#congr">congr</a> with p (: n)?</code> to call <code>ext p (: n)?</code> to all subgoals generated by <code><a href="./Init/Prelude.html#congr">congr</a></code>.
For example, if the goal is <code>‚ä¢ f '' s = g '' s</code> then <code><a href="./Init/Prelude.html#congr">congr</a> with x</code> generates the goal
<code>x : Œ± ‚ä¢ f x = g x</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfigWith">Batteries.Tactic.Congr</a></dd></dl></div><div id="Lean.Parser.Tactic.congr"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>‚ä¢ f as = f bs</code> and <code>‚ä¢ f as ‚âç f bs</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>‚ä¢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>‚ä¢ x = y</code> and <code>‚ä¢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>‚ä¢ x + y = y + x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.congr">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.congrConfig"><h2>congr</h2><p><p>Apply congruence (recursively) to goals of the form <code>‚ä¢ f as = f bs</code> and <code>‚ä¢ f as ‚âç f bs</code>.
The optional parameter is the depth of the recursive applications.
This is useful when <code><a href="./Init/Prelude.html#congr">congr</a></code> is too aggressive in breaking down the goal.
For example, given <code>‚ä¢ f (g (x + y)) = f (g (y + x))</code>,
<code><a href="./Init/Prelude.html#congr">congr</a></code> produces the goals <code>‚ä¢ x = y</code> and <code>‚ä¢ y = x</code>,
while <code><a href="./Init/Prelude.html#congr">congr</a> 2</code> produces the intended <code>‚ä¢ x + y = y + x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.congrConfig">Batteries.Tactic.Congr</a></dd></dl></div><div id="Congr!.congr!"><h2>congr!</h2><p><p><code>congr!</code> tries to prove the main goal by repeatedly applying congruence rules. For example, on a
goal of the form <code>‚ä¢ f a1 a2 ... = f b1 b2 ...</code>, <code>congr!</code> will make new goals <code>‚ä¢ a1 = b1</code>,
<code>‚ä¢ a2 = b2</code>, ...</p><p><code>congr!</code> is a more powerful version of the <code><a href="./Init/Prelude.html#congr">congr</a></code> tactic that uses congruence lemmas (tagged with
<code>@[congr]</code>), reflexivity rules (tagged with <code>@[refl]</code>) and proof discharging strategies. The full
list of congruence proof strategies is documented in the module <code><a href="./Mathlib/Tactic/CongrExclamation.html">Mathlib.Tactic.CongrExclamation</a></code>.
The <code>congr!</code> tactic is used by the <code>convert</code> and <code>convert_to</code> tactics.</p><ul><li><code>congr! n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence is
applied. For example, if the main goal is <code>n + n + 1 = 2 * n + 1</code>, then <code>congr! 1</code> results in one
goal, <code>‚ä¢ n + n = 2 * n</code>, and <code>congr! 2</code> (or more) results in two (impossible) goals
<code>‚ä¢ <a href="./Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a> = <a href="./Init/Prelude.html#HMul.hMul">HMul.hMul</a></code> and <code>‚ä¢ n = 2</code>.
By default, the depth is unlimited.</li><li><code>congr! with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>congr! (config := cfg)</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.congr!">Mathlib.Tactic.CongrExclamation</a></dd></dl></div><div id="Mathlib.Tactic.congrM"><h2>congrm</h2><p><p><code>congrm e</code> is a tactic for proving goals of the form <code>lhs = rhs</code>, <code>lhs ‚Üî rhs</code>, <code>lhs ‚âç rhs</code>,
or <code>R lhs rhs</code> when <code>R</code> is a reflexive relation.
The expression <code>e</code> is a pattern containing placeholders <code>?_</code>,
and this pattern is matched against <code>lhs</code> and <code>rhs</code> simultaneously.
These placeholders generate new goals that state that corresponding subexpressions
in <code>lhs</code> and <code>rhs</code> are equal.
If the placeholders have names, such as <code>?m</code>, then the new goals are given tags with those names.</p><p>Examples:</p><pre><code class="language-lean">example {a b c d : ‚Ñï} :
    <a href="./Init/Prelude.html#Nat.pred">Nat.pred</a> a.succ * (d + (c + a.pred)) = <a href="./Init/Prelude.html#Nat.pred">Nat.pred</a> b.succ * (b + (c + d.pred)) := by
  congrm <a href="./Init/Prelude.html#Nat.pred">Nat.pred</a> (Nat.succ ?h1) * (?h2 + ?h3)
  /-  Goals left:
  case h1 ‚ä¢ a = b
  case h2 ‚ä¢ d = b
  case h3 ‚ä¢ c + a.pred = c + d.pred
  -/
  sorry
  sorry
  sorry

example {a b : ‚Ñï} (h : a = b) : (fun y : ‚Ñï =&gt; ‚àÄ z, a + a = z) = (fun x =&gt; ‚àÄ z, b + a = z) := by
  congrm fun x =&gt; ‚àÄ w, ?_ + a = w
  -- ‚ä¢ a = b
  exact h
</code></pre><p>The <code>congrm</code> command is a convenient frontend to <code>congr(...)</code> congruence quotations.
If the goal is an equality, <code>congrm e</code> is equivalent to <code>refine congr(e')</code> where <code>e'</code> is
built from <code>e</code> by replacing each placeholder <code>?m</code> by <code>$(?m)</code>.
The pattern <code>e</code> is allowed to contain <code>$(...)</code> expressions to immediately substitute
equality proofs into the congruence, just like for congruence quotations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CongrM.html#Mathlib.Tactic.congrM">Mathlib.Tactic.CongrM</a></dd></dl></div><div id="tacticCongrm?"><h2>congrm?</h2><p><p>Display a widget panel allowing to generate a <code>congrm</code> call with holes specified by selecting
subexpressions in the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/CongrM.html#tacticCongrm?">Mathlib.Tactic.Widget.CongrM</a></dd></dl></div><div id="Lean.Parser.Tactic.constructor"><h2>constructor</h2><p><p>If the main goal's target type is an inductive type, <code>constructor</code> solves it with
the first matching constructor, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.constructor">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.constructorM"><h2>constructorm</h2><p><p><code>constructorm p_1, ..., p_n</code>, where the main goal has type <code>type</code>, applies the first matching
constructor for <code>type</code>, if <code>type</code> matches one of the given patterns. If <code>type</code> does not match any
of the patterns, <code>constructorm</code> fails.</p><ul><li><code>constructorm* p_1, ..., p_n</code> repeatedly applies a constructor until the goal no longer matches
<code>p_1</code>, ..., <code>p_n</code>. This is a more efficient and compact version of
<code>¬∑ repeat constructorm p_1, ..., p_n</code>. It is more efficient because the pattern is compiled once.</li></ul><p>Examples:</p><pre><code>example : <a href="./Init/Prelude.html#True">True</a> ‚àß (True ‚à® True) := by
  constructorm* _ ‚à® _, _ ‚àß _, <a href="./Init/Prelude.html#True">True</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/CasesM.html#Mathlib.Tactic.constructorM">Mathlib.Tactic.CasesM</a></dd></dl></div><div id="tacticContinuity"><h2>continuity</h2><p><p>The tactic <code>continuity</code> solves goals of the form <code>Continuous f</code> by applying lemmas tagged with the
<code>continuity</code> user attribute.</p><p><code>fun_prop</code> is a (usually more powerful) alternative to <code>continuity</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Continuity.html#tacticContinuity">Mathlib.Tactic.Continuity</a></dd></dl></div><div id="tacticContinuity?"><h2>continuity?</h2><p><p>The tactic <code>continuity</code> solves goals of the form <code>Continuous f</code> by applying lemmas tagged with the
<code>continuity</code> user attribute.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Continuity.html#tacticContinuity?">Mathlib.Tactic.Continuity</a></dd></dl></div><div id="Lean.Parser.Tactic.contradiction"><h2>contradiction</h2><p><p><code>contradiction</code> closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.</p><ul><li>Inductive type/family with no applicable constructors<pre><code class="language-lean">example (h : False) : p := by contradiction
</code></pre></li><li>Injectivity of constructors<pre><code class="language-lean">example (h : none = some true) : p := by contradiction  --
</code></pre></li><li>Decidable false proposition<pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by contradiction
</code></pre></li><li>Contradictory hypotheses<pre><code class="language-lean">example (h : p) (h' : ¬¨ p) : q := by contradiction
</code></pre></li><li>Other simple contradictions such as<pre><code class="language-lean">example (x : Nat) (h : x ‚â† x) : p := by contradiction
</code></pre></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.contradiction">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Contrapose.contrapose"><h2>contrapose</h2><p><p>Transforms the goal into its contrapositive.</p><ul><li><code>contrapose</code> turns a goal <code>P ‚Üí Q</code> into <code>¬¨ Q ‚Üí ¬¨ P</code> and it turns a goal <code>P ‚Üî Q</code> into <code>¬¨ P ‚Üî ¬¨ Q</code></li><li><code>contrapose h</code> first reverts the local assumption <code>h</code>, and then uses <code>contrapose</code> and <code>intro h</code></li><li><code>contrapose h with new_h</code> uses the name <code>new_h</code> for the introduced hypothesis</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Contrapose.html#Mathlib.Tactic.Contrapose.contrapose">Mathlib.Tactic.Contrapose</a></dd></dl></div><div id="Mathlib.Tactic.Contrapose.contrapose!"><h2>contrapose!</h2><p><p>Transforms the goal into its contrapositive and pushes negations in the result.
Usage matches <code>contrapose</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Contrapose.html#Mathlib.Tactic.Contrapose.contrapose!">Mathlib.Tactic.Contrapose</a></dd></dl></div><div id="Lean.Parser.Tactic.Conv.conv"><h2>conv</h2><p><p><code>conv =&gt; ...</code> allows the user to perform targeted rewriting on a goal or hypothesis,
by focusing on particular subexpressions.</p><p>See <a href="https://lean-lang.org/theorem_proving_in_lean4/conv.html">https://lean-lang.org/theorem_proving_in_lean4/conv.html</a> for more details.</p><p>Basic forms:</p><ul><li><code>conv =&gt; cs</code> will rewrite the goal with conv tactics <code>cs</code>.</li><li><code>conv at h =&gt; cs</code> will rewrite hypothesis <code>h</code>.</li><li><code>conv in pat =&gt; cs</code> will rewrite the first subexpression matching <code>pat</code> (see <code>pattern</code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Conv.html#Lean.Parser.Tactic.Conv.conv">Init.Conv</a></dd></dl></div><div id="Lean.Parser.Tactic.Conv.convTactic"><h2>conv'</h2><p><p>Executes the given conv block without converting regular goal into a <code>conv</code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Conv.html#Lean.Parser.Tactic.Conv.convTactic">Init.Conv</a></dd></dl></div><div id="Mathlib.Tactic.Conv.tacticConv?"><h2>conv?</h2><p><p>Display a widget panel allowing to generate a <code>conv</code> call zooming to the subexpression selected
in the goal or in the type of a local hypothesis or let-decl.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/Conv.html#Mathlib.Tactic.Conv.tacticConv?">Mathlib.Tactic.Widget.Conv</a></dd></dl></div><div id="Mathlib.Tactic.Conv.convLHS"><h2>conv_lhs</h2><p><p><code>conv_lhs =&gt; cs</code> runs the <code>conv</code> tactic sequence <code>cs</code> on the left hand side of the target.</p><p>In general, for an <code>n</code>-ary operator as the target, it traverses into the second to last argument.
It is a synonym for <code>conv =&gt; arg -2; cs</code>.</p><ul><li><code>conv_lhs at h =&gt; cs</code> runs <code>cs</code> on the left hand side of hypothesis <code>h</code>.</li><li><code>conv_lhs in pat =&gt; cs</code> first looks for a subexpression matching <code>pat</code> (see also the <code>pattern</code>
conv tactic) and then traverses into the left hand side of this subexpression.
This syntax also supports the <code>occs</code> clause for the pattern.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convLHS">Mathlib.Tactic.Conv</a></dd></dl></div><div id="Mathlib.Tactic.Conv.convRHS"><h2>conv_rhs</h2><p><p><code>conv_rhs =&gt; cs</code> runs the <code>conv</code> tactic sequence <code>cs</code> on the right hand side of the target.</p><p>In general, for an <code>n</code>-ary operator as the target, it traverses into the last argument.
It is a synonym for <code>conv =&gt; arg -1; cs</code>.</p><ul><li><code>conv_rhs at h =&gt; cs</code> runs <code>cs</code> on the right hand side of hypothesis <code>h</code>.</li><li><code>conv_rhs in pat =&gt; cs</code> first looks for a subexpression matching <code>pat</code> (see the <code>pattern</code>
conv tactic) and then traverses into the right hand side of this subexpression.
This syntax also supports the <code>occs</code> clause for the pattern.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Conv.html#Mathlib.Tactic.Conv.convRHS">Mathlib.Tactic.Conv</a></dd></dl></div><div id="Mathlib.Tactic.convert"><h2>convert</h2><p><p><code>convert e</code>, where the term <code>e</code> is inferred to have type <code>t</code>, replaces the main goal <code>‚ä¢ t'</code> with new
goals for proving the equality <code>t' = t</code> using congruence. The goals are created like <code>congr!</code> would.
Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>e</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><p>See also <code>convert_to t</code>, where <code>t</code> specifies the expected type, instead of a proof term of type <code>t</code>.
In other words, <code>convert_to t</code> works like <code>convert (?_ : t)</code>. Both tactics use the same options.</p><ul><li><code>convert ‚Üê e</code> creates equality goals in the opposite direction (with the goal type on the right).</li><li><code>convert e using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence is
applied. For example, if the main goal is <code>‚ä¢ Prime (n + n + 1)</code> and <code>e : Prime (2 * n + 1)</code>, then
<code>convert e using 2</code> results in one goal, <code>‚ä¢ n + n = 2 * n</code>, and <code>convert e using 3</code> (or more)
results in two (impossible) goals <code>‚ä¢ <a href="./Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a> = <a href="./Init/Prelude.html#HMul.hMul">HMul.hMul</a></code> and <code>‚ä¢ n = 2</code>.
By default, the depth is unlimited.</li><li><code>convert e with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>convert (config := cfg) e</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul><p>Examples:</p><pre><code class="language-lean">-- `convert using` controls the depth of congruence.
example {n : ‚Ñï} (e : Prime (2 * n + 1)) :
    Prime (n + n + 1) := by
  convert e using 2
  -- <a href="./Init/Prelude.html#One">One</a> goal: ‚ä¢ n + n = 2 * n
  ring
</code></pre><pre><code class="language-lean">-- `convert` can fail where `exact` succeeds.
example (h : p 0) : p 1 := by
  fail_if_success
    convert h -- fails, left-over goal 1 = 0
    done
  exact h -- succeeds

```lean
-- `convert with` names introduced variables.
example (p q : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí Prop) (h : ‚àÄ Œµ &gt; 0, p Œµ) :
    ‚àÄ Œµ &gt; 0, q Œµ := by
  convert h using 2 with Œµ hŒµ
  -- Goal now looks like:
  -- hŒµ : Œµ &gt; 0
  -- ‚ä¢ q Œµ ‚Üî p Œµ
  sorry


</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert">Mathlib.Tactic.Convert</a></dd></dl></div><div id="Mathlib.Tactic.convertTo"><h2>convert_to</h2><p><p><code>convert_to t</code> on a goal <code>‚ä¢ t'</code> changes the goal to <code>‚ä¢ t</code> and adds new goals for proving the
equality <code>t' = t</code> using congruence. The goals are created like <code>congr!</code> would.
Any remaining congruence goals come before the main goal.
Like <code>refine e</code>, any holes (<code>?_</code> or <code>?x</code>) in <code>t</code> that are not solved by unification are converted
into new goals, using the hole's name, if any, as the goal case name.
Like <code>congr!</code>, <code>convert_to</code> introduces variables while applying congruence rules. These can be
pattern-matched, like <code>rintro</code> would, using the <code>with</code> keyword.</p><p><code>convert e</code>, where <code>e</code> is a term of type <code>t</code>, uses <code>e</code> to close the new main goal. In other words,
<code>convert e</code> works like <code>convert_to t; refine e</code>. Both tactics use the same options.</p><ul><li><code>convert_to ty at h</code> changes the type of the local hypothesis <code>h</code> to <code>ty</code>. If later local
hypotheses or the goal depend on <code>h</code>, then <code>convert_to t at h</code> may leave a copy of <code>h</code>.</li><li><code>convert_to ‚Üê t</code> creates equality goals in the opposite direction (with the original goal type on
the right).</li><li><code>convert_to t using n</code>, where <code>n</code> is a positive numeral, controls the depth with which congruence
is applied. For example, if the main goal is <code>‚ä¢ Prime (n + n + 1)</code>,
then <code>convert_to Prime (2 * n + 1) using 2</code> results in one goal, <code>‚ä¢ n + n = 2 * n</code>, and
<code>convert_to Prime (2 * n + 1) using 3</code> (or more) results in two (impossible) goals
<code>‚ä¢ <a href="./Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a> = <a href="./Init/Prelude.html#HMul.hMul">HMul.hMul</a></code> and <code>‚ä¢ n = 2</code>.
The default value for <code>n</code> is 1.</li><li><code>convert_to t with x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> names or pattern-matches the variables introduced by
congruence rules, like <code>rintro x ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© (z‚ÇÅ | z‚ÇÇ)</code> would.</li><li><code>convert_to (config := cfg) t</code> uses the configuration options in <code>cfg</code> to control the congruence
rules (see <code><a href="./Mathlib/Tactic/CongrExclamation.html#Congr!.Config">Congr!.Config</a></code>).</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo">Mathlib.Tactic.Convert</a></dd></dl></div><div id="Lean.Parser.Tactic.cutsat"><h2>cutsat</h2><p><p><code>cutsat</code> solves linear integer arithmetic goals.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>lia</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p><p><strong>Deprecated</strong>: Use <code>lia</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.cutsat">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dbgTrace"><h2>dbg_trace</h2><p><p><code>dbg_trace &quot;foo&quot;</code> prints <code>foo</code> when elaborated.
Useful for debugging tactic control flow:</p><pre><code>example : <a href="./Init/Prelude.html#False">False</a> ‚à® <a href="./Init/Prelude.html#True">True</a> := by
  first
  | apply Or.inl; trivial; dbg_trace &quot;left&quot;
  | apply Or.inr; trivial; dbg_trace &quot;right&quot;
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.decide"><h2>decide</h2><p><p><code>decide</code> attempts to prove the main goal (with target type <code>p</code>) by synthesizing an instance of <code><a href="./Init/Prelude.html#Decidable">Decidable</a> p</code>
and then reducing that instance to evaluate the truth value of <code>p</code>.
If it reduces to <code>isTrue h</code>, then <code>h</code> is a proof of <code>p</code> that closes the goal.</p><p>The target is not allowed to contain local variables or metavariables.
If there are local variables, you can first try using the <code>revert</code> tactic with these local variables to move them into the target,
or you can use the <code>+revert</code> option, described below.</p><p>Options:</p><ul><li><code>decide +revert</code> begins by reverting local variables that the target depends on,
after cleaning up the local context of irrelevant variables.
A variable is <em>relevant</em> if it appears in the target, if it appears in a relevant variable,
or if it is a proposition that refers to a relevant variable.</li><li><code>decide +kernel</code> uses kernel for reduction instead of the elaborator.
It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,
and (2) it reduces the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance only once instead of twice.</li><li><code>decide +native</code> uses the native code compiler (<code>#eval</code>) to evaluate the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance,
admitting the result via the <code><a href="./Init/Core.html#Lean.ofReduceBool">Lean.ofReduceBool</a></code> axiom.
This can be significantly more efficient than using reduction, but it is at the cost of increasing the size
of the trusted code base.
Namely, it depends on the correctness of the Lean compiler and all definitions with an <code>@[implemented_by]</code> attribute.
Like with <code>+kernel</code>, the <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance is evaluated only once.</li></ul><p>Limitation: In the default mode or <code>+kernel</code> mode, since <code>decide</code> uses reduction to evaluate the term,
<code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.
Reduction can also get stuck on <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instances with <code><a href="./Init/Prelude.html#Eq.rec">Eq.rec</a></code> terms.
These can appear in instances defined using tactics (such as <code>rw</code> and <code>simp</code>).
To avoid this, create such instances using definitions such as <code><a href="./Init/PropLemmas.html#decidable_of_iff">decidable_of_iff</a></code> instead.</p><h2 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Proving inequalities:</p><pre><code class="language-lean">example : 2 + 2 ‚â† 5 := by decide
</code></pre><p>Trying to prove a false proposition:</p><pre><code class="language-lean">example : 1 ‚â† 1 := by decide
/-
tactic 'decide' proved that the proposition
  1 ‚â† 1
is false
-/
</code></pre><p>Trying to prove a proposition whose <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance fails to reduce</p><pre><code class="language-lean">opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  <a href="./Init/Prelude.html#Classical.choice">Classical.choice</a> ‚ãØ
rather than to the 'isTrue' constructor.
-/
</code></pre><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><p>For equality goals for types with decidable equality, usually <code><a href="./Init/Prelude.html#rfl">rfl</a></code> can be used in place of <code>decide</code>.</p><pre><code class="language-lean">example : 1 + 1 = 2 := by decide
example : 1 + 1 = 2 := by <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.decide">Init.Tactics</a></dd></dl></div><div id="tacticDecreasing_tactic"><h2>decreasing_tactic</h2><p><p><code>decreasing_tactic</code> is called by default on well-founded recursions in order
to synthesize a proof that recursive calls decrease along the selected
well founded relation. It can be locally overridden by using <code>decreasing_by tac</code>
on the recursive definition, and it can also be globally extended by adding
more definitions for <code>decreasing_tactic</code> (or <code>decreasing_trivial</code>,
which this tactic calls).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_tactic">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_trivial"><h2>decreasing_trivial</h2><p><p>Extensible helper tactic for <code>decreasing_tactic</code>. This handles the &quot;base case&quot;
reasoning after applying lexicographic order lemmas.
It can be extended by adding more macro definitions, e.g.</p><pre><code>macro_rules | `(tactic| decreasing_trivial) =&gt; `(tactic| linarith)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_trivial">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_trivial_pre_omega"><h2>decreasing_trivial_pre_omega</h2><p><p>Variant of <code>decreasing_trivial</code> that does not use <code>omega</code>, intended to be used in core modules
before <code>omega</code> is available.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_trivial_pre_omega">Init.WFTactics</a></dd></dl></div><div id="tacticDecreasing_with_"><h2>decreasing_with</h2><p><p>Constructs a proof of decreasing along a well founded relation, by simplifying, then applying
lexicographic order lemmas and finally using <code>ts</code> to solve the base case. If it fails,
it prints a message to help the user diagnose an ill-founded recursive definition.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticDecreasing_with_">Init.WFTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.delta"><h2>delta</h2><p><p><code>delta id1 id2 ...</code> delta-expands the definitions <code>id1</code>, <code>id2</code>, ....
This is a low-level tactic, it will expose how recursive definitions have been
compiled by Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.delta">Init.Tactics</a></dd></dl></div><div id="tacticDeriving_LawfulEq_tactic"><h2>deriving_LawfulEq_tactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#tacticDeriving_LawfulEq_tactic">Init.LawfulBEqTactics</a></dd></dl></div><div id="tacticDeriving_LawfulEq_tactic_step"><h2>deriving_LawfulEq_tactic_step</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#tacticDeriving_LawfulEq_tactic_step">Init.LawfulBEqTactics</a></dd></dl></div><div id="DerivingHelpers.tacticDeriving_ReflEq_tactic"><h2>deriving_ReflEq_tactic</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/LawfulBEqTactics.html#DerivingHelpers.tacticDeriving_ReflEq_tactic">Init.LawfulBEqTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.done"><h2>done</h2><p><p><code>done</code> succeeds iff there are no remaining goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.done">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimp"><h2>dsimp</h2><p><p>The <code>dsimp</code> tactic is the definitional simplifier. It is similar to <code>simp</code> but only
applies theorems that hold by reflexivity. Thus, the result is guaranteed to be
definitionally equal to the input.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dsimp">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimpAutoUnfold"><h2>dsimp!</h2><p><p><code>dsimp!</code> is shorthand for <code>dsimp</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.dsimpAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.dsimpTrace"><h2>dsimp?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.dsimpTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticDsimp?!_"><h2>dsimp?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticDsimp?!_">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticEapply_"><h2>eapply</h2><p><p><code>eapply e</code> is like <code>apply e</code> but it does not add subgoals for variables that appear
in the types of other goals. Note that this can lead to a failure where there are
no goals remaining but there are still metavariables in the term:</p><pre><code>example (h : ‚àÄ x : Nat, x = x ‚Üí True) : <a href="./Init/Prelude.html#True">True</a> := by
  eapply h
  <a href="./Init/Prelude.html#rfl">rfl</a>
  -- no goals
-- (kernel) declaration has metavariables '_example'
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticEapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="tacticEconstructor"><h2>econstructor</h2><p><p><code>econstructor</code> is like <code>constructor</code>
(it calls <code>apply</code> using the first matching constructor of an inductive datatype)
except only non-dependent premises are added as new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Constructor.html#tacticEconstructor">Mathlib.Tactic.Constructor</a></dd></dl></div><div id="Lean.Parser.Tactic.eqRefl"><h2>eq_refl</h2><p><p><code>eq_refl</code> is equivalent to <code>exact <a href="./Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.eqRefl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticErw___"><h2>erw</h2><p><p><code>erw [rules]</code> is a shorthand for <code>rw (transparency := .default) [rules]</code>.
This does rewriting up to unfolding of regular definitions (by comparison to regular <code>rw</code>
which only unfolds <code>@[reducible]</code> definitions).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.tacticErw___">Init.Meta</a></dd></dl></div><div id="Mathlib.Tactic.Erw?.erw?"><h2>erw?</h2><p><p><code>erw? [r, ...]</code> calls <code>erw [r, ...]</code> (at hypothesis <code>h</code> if written <code>erw [r, ...] at h</code>),
and then attempts to identify any subexpression which would block the use of <code>rw</code> instead.
It does so by identifying subexpressions which are defeq, but not at reducible transparency.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.erw?">Mathlib.Tactic.ErwQuestion</a></dd></dl></div><div id="Mathlib.Tactic.etaExpandStx"><h2>eta_expand</h2><p><p><code>eta_expand at loc</code> eta expands all sub-expressions at the given location.
It also beta reduces any applications of eta expanded terms, so it puts it
into an eta-expanded &quot;normal form.&quot;
This also exists as a <code>conv</code>-mode tactic.</p><p>For example, if <code>f</code> takes two arguments, then <code>f</code> becomes <code>fun x y =&gt; f x y</code>
and <code>f x</code> becomes <code>fun y =&gt; f x y</code>.</p><p>This can be useful to turn, for example, a raw <code><a href="./Init/Prelude.html#HAdd.hAdd">HAdd.hAdd</a></code> into <code>fun x y =&gt; x + y</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.etaReduceStx"><h2>eta_reduce</h2><p><p><code>eta_reduce at loc</code> eta reduces all sub-expressions at the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>For example, <code>fun x y =&gt; f x y</code> becomes <code>f</code> after eta reduction.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.etaStructStx"><h2>eta_struct</h2><p><p><code>eta_struct at loc</code> transforms structure constructor applications such as <code>S.mk x.1 ... x.n</code>
(pretty printed as, for example, <code>{a := x.a, b := x.b, ...}</code>) into <code>x</code>.
This also exists as a <code>conv</code>-mode tactic.</p><p>The transformation is known as eta reduction for structures, and it yields definitionally
equal expressions.</p><p>For example, given <code>x : Œ± √ó Œ≤</code>, then <code>(x.1, x.2)</code> becomes <code>x</code> after this transformation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Lean.Parser.Tactic.exact"><h2>exact</h2><p><p><code>exact e</code> closes the main goal if its target type matches that of <code>e</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exact">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.exact?"><h2>exact?</h2><p><p>Searches environment for definitions or theorems that can solve the goal using <code>exact</code>
with conditions resolved by <code>solve_by_elim</code>.</p><p>The optional <code>using</code> clause provides identifiers in the local context that must be
used by <code>exact?</code> when closing the goal.  This is most useful if there are multiple
ways to resolve the goal, and one wants to guide which lemma is used.</p><p>Use <code>+grind</code> to enable <code>grind</code> as a fallback discharger for subgoals.
Use <code>+try?</code> to enable <code>try?</code> as a fallback discharger for subgoals.
Use <code>-star</code> to disable fallback to star-indexed lemmas (like <code><a href="./Init/Core.html#Empty.elim">Empty.elim</a></code>, <code><a href="./Init/Prelude.html#And.left">And.left</a></code>).
Use <code>+all</code> to collect all successful lemmas instead of stopping at the first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exact?">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticExact_mod_cast_"><h2>exact_mod_cast</h2><p><p>Normalize casts in the goal and the given expression, then close the goal with <code>exact</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticExact_mod_cast_">Init.TacticsExtra</a></dd></dl></div><div id="Batteries.Tactic.exacts"><h2>exacts</h2><p><p>Like <code>exact</code>, but takes a list of terms and checks that all goals are discharged after the tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.exacts">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticExfalso"><h2>exfalso</h2><p><p><code>exfalso</code> converts a goal <code>‚ä¢ tgt</code> into <code>‚ä¢ <a href="./Init/Prelude.html#False">False</a></code> by applying <code><a href="./Init/Prelude.html#False.elim">False.elim</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticExfalso">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.¬´tacticExists_,,¬ª"><h2>exists</h2><p><p><code>exists e‚ÇÅ, e‚ÇÇ, ...</code> is shorthand for <code>refine ‚ü®e‚ÇÅ, e‚ÇÇ, ...‚ü©; try <a href="./Init/Core.html#trivial">trivial</a></code>.
It is useful for existential goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.¬´tacticExists_,,¬ª">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticExistsi_,,¬ª"><h2>existsi</h2><p><p><code>existsi e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> applies the tactic <code>refine ‚ü®e‚ÇÅ, e‚ÇÇ, ‚ãØ, ?_‚ü©</code>. It's purpose is to instantiate
existential quantifiers.</p><p>Examples:</p><pre><code class="language-lean">example : ‚àÉ x : Nat, x = x := by
  existsi 42
  <a href="./Init/Prelude.html#rfl">rfl</a>

example : ‚àÉ x : Nat, ‚àÉ y : Nat, x = y := by
  existsi 42, 42
  <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ExistsI.html#Mathlib.Tactic.¬´tacticExistsi_,,¬ª">Mathlib.Tactic.ExistsI</a></dd></dl></div><div id="Lean.Parser.Tactic.exposeNames"><h2>expose_names</h2><p><p><code>expose_names</code> renames all inaccessible variables with accessible names, making them available
for reference in generated tactics. However, this renaming introduces machine-generated names
that are not fully under user control. <code>expose_names</code> is primarily intended as a preamble for
auto-generated end-game tactic scripts. It is also useful as an alternative to
<code>set_option tactic.hygienic false</code>. If explicit control over renaming is needed in the
middle of a tactic script, consider using structured tactic scripts with
<code>match .. with</code>, <code>induction .. with</code>, or <code>intro</code> with explicit user-defined names,
as well as tactics such as <code>next</code>, <code>case</code>, and <code>rename_i</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.exposeNames">Init.Tactics</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.ext"><h2>ext</h2><p><p>Applies extensionality lemmas that are registered with the <code>@[ext]</code> attribute.</p><ul><li><code>ext pat*</code> applies extensionality theorems as much as possible,
using the patterns <code>pat*</code> to introduce the variables in extensionality theorems using <code>rintro</code>.
For example, the patterns are used to name the variables introduced by lemmas such as <code><a href="./Init/Core.html#funext">funext</a></code>.</li><li>Without patterns,<code>ext</code> applies extensionality lemmas as much
as possible but introduces anonymous hypotheses whenever needed.</li><li><code>ext pat* : n</code> applies ext theorems only up to depth <code>n</code>.</li></ul><p>The <code>ext1 pat*</code> tactic is like <code>ext pat*</code> except that it only applies a single extensionality theorem.</p><p>Unused patterns will generate warning.
Patterns that don't match the variables will typically result in the introduction of anonymous hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.ext">Init.Ext</a></dd></dl></div><div id="Lean.Elab.Tactic.Ext.tacticExt1___"><h2>ext1</h2><p><p><code>ext1 pat*</code> is like <code>ext pat*</code> except that it only applies a single extensionality theorem rather
than recursively applying as many extensionality theorems as possible.</p><p>The <code>pat*</code> patterns are processed using the <code>rintro</code> tactic.
If no patterns are supplied, then variables are introduced anonymously using the <code>intros</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Ext.html#Lean.Elab.Tactic.Ext.tacticExt1___">Init.Ext</a></dd></dl></div><div id="Mathlib.Tactic.ExtractGoal.extractGoal"><h2>extract_goal</h2><p><ul><li><p><code>extract_goal</code> formats the current goal as a stand-alone theorem or definition after
cleaning up the local context of irrelevant variables.
A variable is <em>relevant</em> if (1) it occurs in the target type, (2) there is a relevant variable
that depends on it, or (3) the type of the variable is a proposition that depends on a
relevant variable.</p><p>If the target is <code><a href="./Init/Prelude.html#False">False</a></code>, then for convenience <code>extract_goal</code> includes all variables.</p></li><li><p><code>extract_goal *</code> formats the current goal without cleaning up the local context.</p></li><li><p><code>extract_goal a b c ...</code> formats the current goal after removing everything that the given
variables <code>a</code>, <code>b</code>, <code>c</code>, ... do not depend on.</p></li><li><p><code>extract_goal ... using name</code> uses the name <code>name</code> for the theorem or definition rather than
the autogenerated name.</p></li></ul><p>The tactic tries to produce an output that can be copy-pasted and just work,
but its success depends on whether the expressions are amenable
to being unambiguously pretty printed.</p><p>The tactic responds to pretty printing options.
For example, <code>set_option pp.all true in extract_goal</code> gives the <code>pp.all</code> form.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ExtractGoal.html#Mathlib.Tactic.ExtractGoal.extractGoal">Mathlib.Tactic.ExtractGoal</a></dd></dl></div><div id="Lean.Parser.Tactic.extractLets"><h2>extract_lets</h2><p><p>Extracts <code>let</code> and <code>have</code> expressions from within the target or a local hypothesis,
introducing new local definitions.</p><ul><li><code>extract_lets</code> extracts all the lets from the target.</li><li><code>extract_lets x y z</code> extracts all the lets from the target and uses <code>x</code>, <code>y</code>, and <code>z</code> for the first names.
Using <code>_</code> for a name leaves it unnamed.</li><li><code>extract_lets x y z at h</code> operates on the local hypothesis <code>h</code> instead of the target.</li></ul><p>For example, given a local hypotheses if the form <code>h : let x := v; b x</code>, then <code>extract_lets z at h</code>
introduces a new local definition <code>z := v</code> and changes <code>h</code> to be <code>h : b z</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.extractLets">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.fail"><h2>fail</h2><p><p><code>fail msg</code> is a tactic that always fails, and produces an error using the given message.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.fail">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.failIfNoProgress"><h2>fail_if_no_progress</h2><p><p><code>fail_if_no_progress tacs</code> evaluates <code>tacs</code>, and fails if no progress is made on the main goal
or the local context at reducible transparency.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FailIfNoProgress.html#Mathlib.Tactic.failIfNoProgress">Mathlib.Tactic.FailIfNoProgress</a></dd></dl></div><div id="Lean.Parser.Tactic.failIfSuccess"><h2>fail_if_success</h2><p><p><code>fail_if_success t</code> fails if the tactic <code>t</code> succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.falseOrByContra"><h2>false_or_by_contra</h2><p><p>Changes the goal to <code><a href="./Init/Prelude.html#False">False</a></code>, retaining as much information as possible:</p><ul><li>If the goal is <code><a href="./Init/Prelude.html#False">False</a></code>, do nothing.</li><li>If the goal is an implication or a function type, introduce the argument and restart.
(In particular, if the goal is <code>x ‚â† y</code>, introduce <code>x = y</code>.)</li><li>Otherwise, for a propositional goal <code>P</code>, replace it with <code>¬¨ ¬¨ P</code>
(attempting to find a <code><a href="./Init/Prelude.html#Decidable">Decidable</a></code> instance, but otherwise falling back to working classically)
and introduce <code>¬¨ P</code>.</li><li>For a non-propositional goal use <code><a href="./Init/Prelude.html#False.elim">False.elim</a></code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.falseOrByContra">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticFapply_"><h2>fapply</h2><p><p><code>fapply e</code> is like <code>apply e</code> but it adds goals in the order they appear,
rather than putting the dependent goals first.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticFapply_">Batteries.Tactic.Init</a></dd></dl></div><div id="tacticFconstructor"><h2>fconstructor</h2><p><p><code>fconstructor</code> is like <code>constructor</code>
(it calls <code>apply</code> using the first matching constructor of an inductive datatype)
except that it does not reorder goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Constructor.html#tacticFconstructor">Mathlib.Tactic.Constructor</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.field"><h2>field</h2><p><p>The <code>field</code> tactic proves equality goals in (semi-)fields. For example:</p><pre><code>example {x y : ‚Ñö} (hx : x + y ‚â† 0) : x / (x + y) + y / (x + y) = 1 := by
  field
example {a b : ‚Ñù} (ha : a ‚â† 0) : a / (a * b) - 1 / b = 0 := by field
</code></pre><p>The scope of the tactic is equality goals which are <em>universal</em>, in the sense that they are true in
any field in which the appropriate denominators don't vanish. (That is, they are consequences purely
of the field axioms.)</p><p>Checking the nonvanishing of the necessary denominators is done using a variety of tricks -- in
particular this part of the reasoning is non-universal, i.e. can be specific to the field at hand
(order properties, explicit <code>‚â† 0</code> hypotheses, <code><a href="./Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a></code> if that is known, etc).  The user can also
provide additional terms to help with the nonzeroness proofs. For example:</p><pre><code>example {K : Type*} [Field K] (hK : ‚àÄ x : K, x ^ 2 + 1 ‚â† 0) (x : K) :
    1 / (x ^ 2 + 1) + x ^ 2 / (x ^ 2 + 1) = 1 := by
  field [hK]
</code></pre><p>The <code>field</code> tactic is built from the tactics <code>field_simp</code> (which clears the denominators) and <code>ring</code>
(which proves equality goals universally true in commutative (semi-)rings). If <code>field</code> fails to
prove your goal, you may still be able to prove your goal by running the <code>field_simp</code> and <code>ring_nf</code>
normalizations in some order.  For example, this statement:</p><pre><code>example {a b : ‚Ñö} (H : b + a ‚â† 0) : a / (a + b) + b / (b + a) = 1
</code></pre><p>is not proved by <code>field</code> but is proved by <code>ring_nf at *; field</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Field.html#Mathlib.Tactic.FieldSimp.field">Mathlib.Tactic.Field</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.fieldSimp"><h2>field_simp</h2><p><p>The goal of <code>field_simp</code> is to bring expressions in (semi-)fields over a common denominator, i.e. to
reduce them to expressions of the form <code>n / d</code> where neither <code>n</code> nor <code>d</code> contains any division
symbol. For example, <code>x / (1 - y) / (1 + y / (1 - y))</code> is reduced to <code>x / (1 - y + y)</code>:</p><pre><code>example (x y z : ‚Ñö) (hy : 1 - y ‚â† 0) :
    ‚åäx / (1 - y) / (1 + y / (1 - y))‚åã &lt; 3 := by
  field_simp
  -- new goal: `‚ä¢ ‚åäx / (1 - y + y)‚åã &lt; 3`
</code></pre><p>The <code>field_simp</code> tactic will also clear denominators in field <em>(in)equalities</em>, by
cross-multiplying. For example, <code>field_simp</code> will clear the <code>x</code> denominators in the following
equation:</p><pre><code>example {K : Type*} [Field K] {x : K} (hx0 : x ‚â† 0) :
    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by
  field_simp
  -- new goal: `‚ä¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`
</code></pre><p>A very common pattern is <code>field_simp; ring</code> (clear denominators, then the resulting goal is
solvable by the axioms of a commutative ring). The finishing tactic <code>field</code> is a shorthand for this
pattern.</p><p>Cancelling and combining denominators will generally require checking &quot;nonzeroness&quot;/&quot;positivity&quot;
side conditions. The <code>field_simp</code> tactic attempts to discharge these, and will omit such steps if it
cannot discharge the corresponding side conditions. The discharger will try, among other things,
<code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> and <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>, and will also use any nonzeroness/positivity proofs included explicitly
(e.g. <code>field_simp [hx]</code>). If your expression is not completely reduced by <code>field_simp</code>, check the
denominators of the resulting expression and provide proofs that they are nonzero/positive to enable
further progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp">Mathlib.Tactic.FieldSimp</a></dd></dl></div><div id="Mathlib.Tactic.FieldSimp.tacticField_simp_discharge"><h2>field_simp_discharge</h2><p><p>Discharge strategy for the <code>field_simp</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FieldSimp/Discharger.html#Mathlib.Tactic.FieldSimp.tacticField_simp_discharge">Mathlib.Tactic.FieldSimp.Discharger</a></dd></dl></div><div id="Mathlib.Tactic.filterUpwards"><h2>filter_upwards</h2><p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô]</code> replaces a goal of the form <code>s ‚àà f</code> and terms
<code>h‚ÇÅ : t‚ÇÅ ‚àà f, ‚ãØ, h‚Çô : t‚Çô ‚àà f</code> with <code>‚àÄ x, x ‚àà t‚ÇÅ ‚Üí ‚ãØ ‚Üí x ‚àà t‚Çô ‚Üí x ‚àà s</code>.
The list is an optional parameter, <code>[]</code> being its default value.</p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ</code> is a short form for
<code>{ filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô], intro a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ }</code>.</p><p><code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] using e</code> is a short form for
<code>{ filter_upwards [h1, ‚ãØ, hn], exact e }</code>.</p><p>Combining both shortcuts is done by writing <code>filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ using e</code>.
Note that in this case, the <code>a·µ¢</code> terms can be used in <code>e</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Filter/Defs.html#Mathlib.Tactic.filterUpwards">Mathlib.Order.Filter.Defs</a></dd></dl></div><div id="Lean.Elab.Tactic.finCases"><h2>fin_cases</h2><p><p><code>fin_cases h</code> performs case analysis on a hypothesis of the form
<code>h : A</code>, where <code>[Fintype A]</code> is available, or
<code>h : a ‚àà A</code>, where <code>A : <a href="./Mathlib/Data/Finset/Defs.html#Finset">Finset</a> X</code>, <code>A : <a href="./Mathlib/Data/Multiset/Defs.html#Multiset">Multiset</a> X</code> or <code>A : <a href="./Init/Prelude.html#List">List</a> X</code>.</p><p>As an example, in</p><pre><code>example (f : ‚Ñï ‚Üí Prop) (p : <a href="./Init/Prelude.html#Fin">Fin</a> 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by
  fin_cases p; simp
  all_goals assumption
</code></pre><p>after <code>fin_cases p; simp</code>, there are three goals, <code>f 0</code>, <code>f 1</code>, and <code>f 2</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FinCases.html#Lean.Elab.Tactic.finCases">Mathlib.Tactic.FinCases</a></dd></dl></div><div id="Fin.tacticFin_omega"><h2>fin_omega</h2><p><p>Preprocessor for <code>omega</code> to handle inequalities in <code><a href="./Init/Prelude.html#Fin">Fin</a></code>.
Note that this involves a lot of case splitting, so may be slow.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Fin/Basic.html#Fin.tacticFin_omega">Mathlib.Data.Fin.Basic</a></dd></dl></div><div id="Mathlib.Tactic.Find.tacticFind"><h2>find</h2><p><p><code>find</code> finds definitions and theorems whose result type matches the current goal exactly,
and prints them as info lines.
In other words, <code>find</code> lists definitions and theorems that are <code>apply</code>able against the current goal.
<code>find</code> will not affect the goal by itself and should be removed from the finished proof.</p><p>For a command or tactic that takes the type to search for as an argument, see <code>#find</code>.</p><p>Example:</p><pre><code class="language-lean">example : <a href="./Init/Prelude.html#True">True</a> := by
  find
  -- True.intro: <a href="./Init/Prelude.html#True">True</a>
  -- trivial: <a href="./Init/Prelude.html#True">True</a>
  -- ...
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Find.html#Mathlib.Tactic.Find.tacticFind">Mathlib.Tactic.Find</a></dd></dl></div><div id="finiteness"><h2>finiteness</h2><p><p><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> proves goals of the form <code>*** &lt; ‚àû</code> and (equivalently) <code>*** ‚â† ‚àû</code> in the extended
nonnegative reals (<code>‚Ñù‚â•0‚àû</code>). Supports passing additional expressions as local hypotheses.</p><ul><li><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness?">finiteness?</a></code> additionally shows the proof that <code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> found</li><li><code><a href="./Mathlib/Tactic/Finiteness.html#finiteness_nonterminal">finiteness_nonterminal</a></code> is a version of <code><a href="./Mathlib/Tactic/Finiteness.html#finiteness">finiteness</a></code> that may (but doesn't have to) close the
goal.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Finiteness.html#finiteness">Mathlib.Tactic.Finiteness</a></dd></dl></div><div id="Lean.Parser.Tactic.first"><h2>first</h2><p><p><code>first | tac | ...</code> runs each <code>tac</code> until one succeeds, or else fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.first">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.firstPar"><h2>first_par</h2><p><p>Helper internal tactic for implementing the tactic <code>try?</code> with parallel execution, returning first success.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.firstPar">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.focus"><h2>focus</h2><p><p><code>focus tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>¬∑ tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.focus">Init.Tactics</a></dd></dl></div><div id="Aesop.Frontend.tacticForward____"><h2>forward</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Saturate.html#Aesop.Frontend.tacticForward____">Aesop.Frontend.Saturate</a></dd></dl></div><div id="Aesop.Frontend.tacticForward?____"><h2>forward?</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Saturate.html#Aesop.Frontend.tacticForward?____">Aesop.Frontend.Saturate</a></dd></dl></div><div id="Lean.Parser.Tactic.funCases"><h2>fun_cases</h2><p><p>The <code>fun_cases</code> tactic is a convenience wrapper of the <code>cases</code> tactic when using a functional
cases principle.</p><p>The tactic invocation</p><pre><code>fun_cases f x ... y ...`
</code></pre><p>is equivalent to</p><pre><code>cases y, ... using f.fun_cases_unfolding x ...
</code></pre><p>where the arguments of <code>f</code> are used as arguments to <code>f.fun_cases_unfolding</code> or targets of the case
analysis, as appropriate.</p><p>The form</p><pre><code>fun_cases f
</code></pre><p>(with no arguments to <code>f</code>) searches the goal for a unique eligible application of <code>f</code>, and uses
these arguments. An application of <code>f</code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p><p>The form <code>fun_cases f x y with | case1 =&gt; tac‚ÇÅ | case2 x' ih =&gt; tac‚ÇÇ</code> works like with <code>cases</code>.</p><p>Under <code>set_option tactic.fun_induction.unfolding true</code> (the default), <code>fun_induction</code> uses the
<code>f.fun_cases_unfolding</code> theorem, which will try to automatically unfold the call to <code>f</code> in
the goal. With <code>set_option tactic.fun_induction.unfolding false</code>, it uses <code>f.fun_cases</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.funCases">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.funInduction"><h2>fun_induction</h2><p><p>The <code>fun_induction</code> tactic is a convenience wrapper around the <code>induction</code> tactic to use the
functional induction principle.</p><p>The tactic invocation</p><pre><code>fun_induction f x‚ÇÅ ... x‚Çô y‚ÇÅ ... y‚Çò
</code></pre><p>where <code>f</code> is a function defined by non-mutual structural or well-founded recursion, is equivalent to</p><pre><code>induction y‚ÇÅ, ... y‚Çò using f.induct_unfolding x‚ÇÅ ... x‚Çô
</code></pre><p>where the arguments of <code>f</code> are used as arguments to <code>f.induct_unfolding</code> or targets of the
induction, as appropriate.</p><p>The form</p><pre><code>fun_induction f
</code></pre><p>(with no arguments to <code>f</code>) searches the goal for a unique eligible application of <code>f</code>, and uses
these arguments. An application of <code>f</code> is eligible if it is saturated and the arguments that will
become targets are free variables.</p><p>The forms <code>fun_induction f x y generalizing z‚ÇÅ ... z‚Çô</code> and
<code>fun_induction f x y with | case1 =&gt; tac‚ÇÅ | case2 x' ih =&gt; tac‚ÇÇ</code> work like with <code>induction.</code></p><p>Under <code>set_option tactic.fun_induction.unfolding true</code> (the default), <code>fun_induction</code> uses the
<code>f.induct_unfolding</code> induction principle, which will try to automatically unfold the call to <code>f</code> in
the goal. With <code>set_option tactic.fun_induction.unfolding false</code>, it uses <code>f.induct</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.funInduction">Init.Tactics</a></dd></dl></div><div id="Mathlib.Meta.FunProp.funPropTacStx"><h2>fun_prop</h2><p><p><code>fun_prop</code> solves a goal of the form <code>P f</code>, where <code>P</code> is a predicate and <code>f</code> is a function,
by decomposing <code>f</code> into a composition of elementary functions, and proving <code>P</code> on each of those
by matching against a set of <code>@[fun_prop]</code> lemmas.</p><p>If <code>fun_prop</code> fails to solve a goal with the error &quot;No theorems found&quot;, you can solve this issue
by importing or adding new theorems tagged with the <code>@[fun_prop]</code> attribute. See the module
documentation for <code><a href="./Mathlib/Tactic/FunProp.html">Mathlib/Tactic/FunProp.lean</a></code> for a detailed explanation.</p><ul><li><code>fun_prop (disch := tac)</code> uses <code>tac</code> to solve potential side goals. Setting this option is
required to solve <code>ContinuousAt/On/Within</code> goals.</li><li><code>fun_prop [c, ...]</code> will unfold the constant(s) <code>c</code>, ... before decomposing <code>f</code>.</li><li><code>fun_prop (config := cfg)</code> sets advanced configuration options using <code>cfg : FunProp.Config</code>
(see <code>FunProp.Config</code> for details).</li></ul><p>Examples:</p><pre><code class="language-lean">example : Continuous (fun x : ‚Ñù ‚Ü¶ x * sin x) := by fun_prop
</code></pre><pre><code class="language-lean">-- Specify a discharger to solve `ContinuousAt`/`Within`/`On` goals:
example (y : ‚Ñù) (hy : y ‚â† 0) : ContinuousAt (fun x : ‚Ñù ‚Ü¶ 1/x) y := by
  fun_prop (disch := assumption)

example (y : ‚Ñù) (hy : y ‚â† 0) : ContinuousAt (fun x =&gt; x * (Real.log x) ^ 2 - Real.exp x / x) y := by
  fun_prop (disch := aesop)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/FunProp/Elab.html#Mathlib.Meta.FunProp.funPropTacStx">Mathlib.Tactic.FunProp.Elab</a></dd></dl></div><div id="tacticFunext___"><h2>funext</h2><p><p>Apply function extensionality and introduce new hypotheses.
The tactic <code><a href="./Init/Core.html#funext">funext</a></code> will keep applying the <code><a href="./Init/Core.html#funext">funext</a></code> lemma until the goal target is not reducible to</p><pre><code>  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))
</code></pre><p>The variant <code><a href="./Init/Core.html#funext">funext</a> h‚ÇÅ ... h‚Çô</code> applies <code><a href="./Init/Core.html#funext">funext</a></code> <code>n</code> times, and uses the given identifiers to name the new hypotheses.
Patterns can be used like in the <code>intro</code> tactic. Example, given a goal</p><pre><code>  |-  ((fun x : <a href="./Init/Prelude.html#Nat">Nat</a> √ó <a href="./Init/Prelude.html#Bool">Bool</a> =&gt; ...) = (fun x =&gt; ...))
</code></pre><p><code><a href="./Init/Core.html#funext">funext</a> (a, b)</code> applies <code><a href="./Init/Core.html#funext">funext</a></code> once and performs pattern matching on the newly introduced pair.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#tacticFunext___">Init.NotationExtra</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.tacticGcongr___With___"><h2>gcongr</h2><p><p>The <code>gcongr</code> tactic applies &quot;generalized congruence&quot; rules, reducing a relational goal
between an LHS and RHS.  For example,</p><pre><code>example {a b x c d : ‚Ñù} (h1 : a + 1 ‚â§ b + 1) (h2 : c + 2 ‚â§ d + 2) :
    x ^ 2 * a + c ‚â§ x ^ 2 * b + d := by
  gcongr
  ¬∑ linarith
  ¬∑ linarith
</code></pre><p>This example has the goal of proving the relation <code>‚â§</code> between an LHS and RHS both of the pattern</p><pre><code>x ^ 2 * ?_ + ?_
</code></pre><p>(with inputs <code>a</code>, <code>c</code> on the left and <code>b</code>, <code>d</code> on the right); after the use of
<code>gcongr</code>, we have the simpler goals <code>a ‚â§ b</code> and <code>c ‚â§ d</code>.</p><p>A depth limit or a pattern can be provided explicitly;
this is useful if a non-maximal match is desired:</p><pre><code>example {a b c d x : ‚Ñù} (h : a + c + 1 ‚â§ b + d + 1) :
    x ^ 2 * (a + c) + 5 ‚â§ x ^ 2 * (b + d) + 5 := by
  gcongr x ^ 2 * ?_ + 5 -- or `gcongr 2`
  linarith
</code></pre><p>The &quot;generalized congruence&quot; rules are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code>add_le_add (mul_le_mul_of_nonneg_left ?_ (Even.pow_nonneg (even_two_mul 1) x)) ?_
</code></pre><p>using the generalized congruence lemmas <code>add_le_add</code> and <code>mul_le_mul_of_nonneg_left</code>.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ‚â§ x ^ 2</code> in the above application of <code>mul_le_mul_of_nonneg_left</code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code>positivity</code> but can also be extended. Side goals not discharged
in this way are left for the user.</p><p><code>gcongr</code> will descend into binders (for example sums or suprema). To name the bound variables,
use <code>with</code>:</p><pre><code>example {f g : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ n, f n ‚â§ g n) : ‚®Ü n, f n ‚â§ ‚®Ü n, g n := by
  gcongr with i
  exact h i
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr___With___">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.tacticGcongr_discharger"><h2>gcongr_discharger</h2><p><p><code>gcongr_discharger</code> is used by <code>gcongr</code> to discharge side goals.</p><p>This is an extensible tactic using <a href="https://lean-lang.org/doc/reference/4.28.0/find/?domain=Verso.Genre.Manual.section&amp;name=tactic-macro-extension"><code>macro_rules</code></a>.
By default it calls <code>positivity</code> (after importing the <code>positivity</code> tactic).
Example: <code>macro_rules | `(tactic| gcongr_discharger) =&gt; `(tactic| positivity)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.tacticGcongr_discharger">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="Lean.Parser.Tactic.generalize"><h2>generalize</h2><p><ul><li><code>generalize ([h :] e = x),+</code> replaces all occurrences <code>e</code>s in the main goal
with a fresh hypothesis <code>x</code>s. If <code>h</code> is given, <code>h : e = x</code> is introduced as well.</li><li><code>generalize e = x at h‚ÇÅ ... h‚Çô</code> also generalizes occurrences of <code>e</code>
inside <code>h‚ÇÅ</code>, ..., <code>h‚Çô</code>.</li><li><code>generalize e = x at *</code> will generalize occurrences of <code>e</code> everywhere.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.generalize">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.generalizeProofsElab"><h2>generalize_proofs</h2><p><p><code>generalize_proofs ids* [at locs]?</code> generalizes proofs in the current goal,
turning them into new local hypotheses.</p><ul><li><code>generalize_proofs</code> generalizes proofs in the target.</li><li><code>generalize_proofs at h‚ÇÅ h‚ÇÇ</code> generalized proofs in hypotheses <code>h‚ÇÅ</code> and <code>h‚ÇÇ</code>.</li><li><code>generalize_proofs at *</code> generalizes proofs in the entire local context.</li><li><code>generalize_proofs pf‚ÇÅ pf‚ÇÇ pf‚ÇÉ</code> uses names <code>pf‚ÇÅ</code>, <code>pf‚ÇÇ</code>, and <code>pf‚ÇÉ</code> for the generalized proofs.
These can be <code>_</code> to not name proofs.</li></ul><p>If a proof is already present in the local context, it will use that rather than create a new
local hypothesis.</p><p>When doing <code>generalize_proofs at h</code>, if <code>h</code> is a let binding, its value is cleared,
and furthermore if <code>h</code> duplicates a preceding local hypothesis then it is eliminated.</p><p>The tactic is able to abstract proofs from under binders, creating universally quantified
proofs in the local context.
To disable this, use <code>generalize_proofs -abstract</code>.
The tactic is also set to recursively abstract proofs from the types of the generalized proofs.
This can be controlled with the <code>maxDepth</code> configuration option,
with <code>generalize_proofs (config := { maxDepth := 0 })</code> turning this feature off.</p><p>For example:</p><pre><code class="language-lean">def List.nthLe {Œ±} (l : <a href="./Init/Prelude.html#List">List</a> Œ±) (n : ‚Ñï) (_h : n &lt; l.length) : Œ± := sorry
example : List.nthLe [1, 2] 1 (by simp) = 2 := by
  -- ‚ä¢ [1, 2].nthLe 1 ‚ãØ = 2
  generalize_proofs h
  -- h : 1 &lt; [1, 2].length
  -- ‚ä¢ [1, 2].nthLe 1 h = 2
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/GeneralizeProofs.html#Batteries.Tactic.generalizeProofsElab">Batteries.Tactic.GeneralizeProofs</a></dd></dl></div><div id="tacticGet_elem_tactic"><h2>get_elem_tactic</h2><p><p><code>get_elem_tactic</code> is the tactic automatically called by the notation <code>arr[i]</code>
to prove any side conditions that arise when constructing the term
(e.g. the index is in bounds of the array). It just delegates to
<code>get_elem_tactic_extensible</code> and gives a diagnostic error message otherwise;
users are encouraged to extend <code>get_elem_tactic_extensible</code> instead of this tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic">Init.Tactics</a></dd></dl></div><div id="tacticGet_elem_tactic_extensible"><h2>get_elem_tactic_extensible</h2><p><p><code>get_elem_tactic_extensible</code> is an extensible tactic automatically called
by the notation <code>arr[i]</code> to prove any side conditions that arise when
constructing the term (e.g. the index is in bounds of the array).
The default behavior is to try <code>simp +arith</code> and <code>omega</code>
(for doing linear arithmetic in the index).</p><p>(Note that the core tactic <code>get_elem_tactic</code> has already tried
<code>done</code> and <code>assumption</code> before the extensible tactic is called.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic_extensible">Init.Tactics</a></dd></dl></div><div id="tacticGet_elem_tactic_trivial"><h2>get_elem_tactic_trivial</h2><p><p><code>get_elem_tactic_trivial</code> has been deprecated in favour of <code>get_elem_tactic_extensible</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#tacticGet_elem_tactic_trivial">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.grewriteSeq"><h2>grewrite</h2><p><p><code>grewrite [e]</code> is like <code>grw [e]</code>, but it doesn't try to close the goal with <code><a href="./Init/Prelude.html#rfl">rfl</a></code>.
This is analogous to <code>rw</code> and <code>rewrite</code>, where <code>rewrite</code> doesn't try to close the goal with <code><a href="./Init/Prelude.html#rfl">rfl</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.grewriteSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Lean.Parser.Tactic.grind"><h2>grind</h2><p><p><code>grind</code> is a tactic inspired by modern SMT solvers. <strong>Picture a virtual whiteboard</strong>:
every time grind discovers a new equality, inequality, or logical fact,
it writes it on the board, groups together terms known to be equal,
and lets each reasoning engine read from and contribute to the shared workspace.
These engines work together to handle equality reasoning, apply known theorems,
propagate new facts, perform case analysis, and run specialized solvers
for domains like linear arithmetic and commutative rings.</p><p>See <a href="https://lean-lang.org/doc/reference/4.28.0/find/?domain=Verso.Genre.Manual.section&amp;name=grind-tactic">the reference manual's chapter on <code>grind</code></a> for more information.</p><p><code>grind</code> is <em>not</em> designed for goals whose search space explodes combinatorially,
think large pigeonhole instances, graph‚Äëcoloring reductions, high‚Äëorder N‚Äëqueens boards,
or a 200‚Äëvariable Sudoku encoded as Boolean constraints.  Such encodings require
thousands (or millions) of case‚Äësplits that overwhelm <code>grind</code>‚Äôs branching search.</p><p>For <strong>bit‚Äëlevel or combinatorial problems</strong>, consider using <strong><code>bv_decide</code></strong>.
<code>bv_decide</code> calls a state‚Äëof‚Äëthe‚Äëart SAT solver (CaDiCaL) and then returns a
<em>compact, machine‚Äëcheckable certificate</em>.</p><h3 id="Equality-reasoning" class="markdown-heading">Equality reasoning <a class="hover-link" href="#Equality-reasoning">#</a></h3><p><code>grind</code> uses <strong>congruence closure</strong> to track equalities between terms.
When two terms are known to be equal, congruence closure automatically deduces
equalities between more complex expressions built from them.
For example, if <code>a = b</code>, then congruence closure will also conclude that <code>f a</code> = <code>f b</code>
for any function <code>f</code>. This forms the foundation for efficient equality reasoning in <code>grind</code>.
Here is an example:</p><pre><code>example (f : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí Nat) (h : a = b) : f (f b) = f (f a) := by
  grind
</code></pre><h3 id="Applying-theorems-using-E-matching" class="markdown-heading">Applying theorems using E-matching <a class="hover-link" href="#Applying-theorems-using-E-matching">#</a></h3><p>To apply existing theorems, <code>grind</code> uses a technique called <strong>E-matching</strong>,
which finds matches for known theorem patterns while taking equalities into account.
Combined with congruence closure, E-matching helps <code>grind</code> discover
non-obvious consequences of theorems and equalities automatically.</p><p>Consider the following functions and theorems:</p><pre><code>def f (a : Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> :=
  a + 1

def g (a : Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> :=
  a - 1

@[grind =]
theorem gf (x : Nat) : g (f x) = x := by
  simp [f, g]
</code></pre><p>The theorem <code>gf</code> asserts that <code>g (f x) = x</code> for all natural numbers <code>x</code>.
The attribute <code>[grind =]</code> instructs <code>grind</code> to use the left-hand side of the equation,
<code>g (f x)</code>, as a pattern for E-matching.
Suppose we now have a goal involving:</p><pre><code>example {a b} (h : f b = a) : g a = b := by
  grind
</code></pre><p>Although <code>g a</code> is not an instance of the pattern <code>g (f x)</code>,
it becomes one modulo the equation <code>f b = a</code>. By substituting <code>a</code>
with <code>f b</code> in <code>g a</code>, we obtain the term <code>g (f b)</code>,
which matches the pattern <code>g (f x)</code> with the assignment <code>x := b</code>.
Thus, the theorem <code>gf</code> is instantiated with <code>x := b</code>,
and the new equality <code>g (f b) = b</code> is asserted.
<code>grind</code> then uses congruence closure to derive the implied equality
<code>g a = g (f b)</code> and completes the proof.</p><p>The pattern used to instantiate theorems affects the effectiveness of <code>grind</code>.
For example, the pattern <code>g (f x)</code> is too restrictive in the following case:
the theorem <code>gf</code> will not be instantiated because the goal does not even
contain the function symbol <code>g</code>.</p><pre><code>example (h‚ÇÅ : f b = a) (h‚ÇÇ : f c = a) : b = c := by
  grind
</code></pre><p>You can use the command <code>grind_pattern</code> to manually select a pattern for a given theorem.
In the following example, we instruct <code>grind</code> to use <code>f x</code> as the pattern,
allowing it to solve the goal automatically:</p><pre><code>grind_pattern gf =&gt; f x

example {a b c} (h‚ÇÅ : f b = a) (h‚ÇÇ : f c = a) : b = c := by
  grind
</code></pre><p>You can enable the option <code>trace.grind.ematch.instance</code> to make <code>grind</code> print a
trace message for each theorem instance it generates.</p><p>You can also specify a <strong>multi-pattern</strong> to control when <code>grind</code> should apply a theorem.
A multi-pattern requires that all specified patterns are matched in the current context
before the theorem is applied. This is useful for theorems such as transitivity rules,
where multiple premises must be simultaneously present for the rule to apply.
The following example demonstrates this feature using a transitivity axiom for a binary relation <code>R</code>:</p><pre><code>opaque R : <a href="./Init/Data/Int/Basic.html#Int">Int</a> ‚Üí <a href="./Init/Data/Int/Basic.html#Int">Int</a> ‚Üí Prop
axiom Rtrans {x y z : Int} : R x y ‚Üí R y z ‚Üí R x z

grind_pattern Rtrans =&gt; R x y, R y z

example {a b c d} : R a b ‚Üí R b c ‚Üí R c d ‚Üí R a d := by
  grind
</code></pre><p>By specifying the multi-pattern <code>R x y, R y z</code>, we instruct <code>grind</code> to
instantiate <code>Rtrans</code> only when both <code>R x y</code> and <code>R y z</code> are available in the context.
In the example, <code>grind</code> applies <code>Rtrans</code> to derive <code>R a c</code> from <code>R a b</code> and <code>R b c</code>,
and can then repeat the same reasoning to deduce <code>R a d</code> from <code>R a c</code> and <code>R c d</code>.</p><p>Instead of using <code>grind_pattern</code> to explicitly specify a pattern,
you can use the <code>@[grind]</code> attribute or one of its variants, which will use a heuristic to
generate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:</p><ul><li><code>@[grind ‚Üí]</code> will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).
In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable
(i.e. has a constant as its head) subexpression which &quot;covers&quot; (i.e. fixes the value of) an argument which was not
previously covered, it will add that subexpression as a pattern, until all arguments have been covered.</li><li><code>@[grind ‚Üê]</code> will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).
This may fail if not all the arguments to the theorem appear in the conclusion.</li><li><code>@[grind]</code> will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,
stopping when all arguments are covered.</li><li><code>@[grind =]</code> checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.
This may fail if not all of the arguments appear in the left-hand-side.</li></ul><p>Here is the previous example again but using the attribute <code>[grind ‚Üí]</code></p><pre><code>opaque R : <a href="./Init/Data/Int/Basic.html#Int">Int</a> ‚Üí <a href="./Init/Data/Int/Basic.html#Int">Int</a> ‚Üí Prop
@[grind ‚Üí] axiom Rtrans {x y z : Int} : R x y ‚Üí R y z ‚Üí R x z

example {a b c d} : R a b ‚Üí R b c ‚Üí R c d ‚Üí R a d := by
  grind
</code></pre><p>To control theorem instantiation and avoid generating an unbounded number of instances,
<code>grind</code> uses a generation counter. Terms in the original goal are assigned generation zero.
When <code>grind</code> applies a theorem using terms of generation <code>‚â§¬†n¬†n</code>, any new terms it creates
are assigned generation <code>n¬†+¬†1¬†+¬†1¬†1</code>. This limits how far the tactic explores when applying
theorems and helps prevent an excessive number of instantiations.</p><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind (ematch := &lt;num&gt;)</code> controls the number of E-matching rounds.</li><li><code>grind [&lt;name&gt;, ...]</code> instructs <code>grind</code> to use the declaration <code>name</code> during E-matching.</li><li><code>grind only [&lt;name&gt;, ...]</code> is like <code>grind [&lt;name&gt;, ...]</code> but does not use theorems tagged with <code>@[grind]</code>.</li><li><code>grind (gen := &lt;num&gt;)</code> sets the maximum generation.</li></ul><h3 id="Linear-integer-arithmetic-lia" class="markdown-heading">Linear integer arithmetic (<code>lia</code>) <a class="hover-link" href="#Linear-integer-arithmetic-lia">#</a></h3><p><code>grind</code> can solve goals that reduce to <strong>linear integer arithmetic (LIA)</strong> using an
integrated decision procedure called <strong><code>lia</code></strong>.  It understands</p><ul><li>equalities‚ÄÉ‚ÄÉ‚ÄÉ<code>p = 0</code></li><li>inequalities‚ÄÉ‚ÄÇ<code>p ‚â§ 0</code></li><li>disequalities‚ÄÇ<code>p ‚â† 0</code></li><li>divisibility‚ÄÉ‚ÄÇ<code>d ‚à£ p</code></li></ul><p>The solver incrementally assigns integer values to variables; when a partial
assignment violates a constraint it adds a new, implied constraint and retries.
This <em>model-based</em> search is <strong>complete for LIA</strong>.</p><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind -lia</code>‚ÄÉdisable the solver (useful for debugging)</li><li><code>grind +qlia</code>‚ÄÉaccept rational models (shrinks the search space but is incomplete for ‚Ñ§)</li></ul><h4 id="Examples" class="markdown-heading">Examples: <a class="hover-link" href="#Examples">#</a></h4><pre><code>-- Even + even is never odd.
example {x y : Int} : 2 * x + 4 * y ‚â† 5 := by
  grind

-- Mixing equalities and inequalities.
example {x y : Int} :
    2 * x + 3 * y = 0 ‚Üí 1 ‚â§ x ‚Üí y &lt; 1 := by
  grind

-- Reasoning with divisibility.
example (a b : Int) :
    2 ‚à£ a + 1 ‚Üí 2 ‚à£ b + a ‚Üí ¬¨ 2 ‚à£ b + 2 * a := by
  grind

example (x y : Int) :
    27 ‚â§ 11*x + 13*y ‚Üí
    11*x + 13*y ‚â§ 45 ‚Üí
    -10 ‚â§ 7*x - 9*y ‚Üí
    7*x - 9*y ‚â§ 4 ‚Üí <a href="./Init/Prelude.html#False">False</a> := by
  grind

-- Types that implement the `ToInt` type-class.
example (a b c : UInt64)
    : a ‚â§ 2 ‚Üí b ‚â§ 3 ‚Üí c - a - b = 0 ‚Üí c ‚â§ 5 := by
  grind
</code></pre><h3 id="Algebraic-solver-ring" class="markdown-heading">Algebraic solver (<code>ring</code>) <a class="hover-link" href="#Algebraic-solver-ring">#</a></h3><p><code>grind</code> ships with an algebraic solver nick-named <strong><code>ring</code></strong> for goals that can
be phrased as polynomial equations (or disequations) over commutative rings,
semirings, or fields.</p><p><em>Works out of the box</em>
All core numeric types and relevant Mathlib types already provide the required
type-class instances, so the solver is ready to use in most developments.</p><p>What it can decide:</p><ul><li>equalities of the form <code>p = q</code></li><li>disequalities <code>p ‚â† q</code></li><li>basic reasoning under field inverses (<code>a / b := a * b‚Åª¬π</code>)</li><li>goals that mix ring facts with other <code>grind</code> engines</li></ul><h4 id="Key-options" class="markdown-heading">Key options: <a class="hover-link" href="#Key-options">#</a></h4><ul><li><code>grind -ring</code>‚ÄÉturn the solver off (useful when debugging)</li><li><code>grind (ringSteps := n)</code>‚ÄÉcap the number of steps performed by this procedure.</li></ul><h4 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h4><pre><code>open Lean Grind

example [CommRing Œ±] (x : Œ±) : (x + 1) * (x - 1) = x^2 - 1 := by
  grind

-- Characteristic 256 means 16 * 16 = 0.
example [CommRing Œ±] [IsCharP Œ± 256] (x : Œ±) :
    (x + 16) * (x - 16) = x^2 := by
  grind

-- Works on built-in rings such as `UInt8`.
example (x : UInt8) : (x + 16) * (x - 16) = x^2 := by
  grind

example [CommRing Œ±] (a b c : Œ±) :
    a + b + c = 3 ‚Üí
    a^2 + b^2 + c^2 = 5 ‚Üí
    a^3 + b^3 + c^3 = 7 ‚Üí
    a^4 + b^4 = 9 - c^4 := by
  grind

example [Field Œ±] [NoNatZeroDivisors Œ±] (a : Œ±) :
    1 / a + 1 / (2 * a) = 3 / (2 * a) := by
  grind
</code></pre><h3 id="Other-options" class="markdown-heading">Other options <a class="hover-link" href="#Other-options">#</a></h3><ul><li><code>grind (splits := &lt;num&gt;)</code> caps the <em>depth</em> of the search tree.  Once a branch performs <code>num</code> splits
<code>grind</code> stops splitting further in that branch.</li><li><code>grind -splitIte</code> disables case splitting on if-then-else expressions.</li><li><code>grind -splitMatch</code> disables case splitting on <code>match</code> expressions.</li><li><code>grind +splitImp</code> instructs <code>grind</code> to split on any hypothesis <code>A ‚Üí B</code> whose antecedent <code>A</code> is <strong>propositional</strong>.</li><li><code>grind -linarith</code> disables the linear arithmetic solver for (ordered) modules and rings.</li></ul><h3 id="Additional-Examples" class="markdown-heading">Additional Examples <a class="hover-link" href="#Additional-Examples">#</a></h3><pre><code>example {a b} {as bs : <a href="./Init/Prelude.html#List">List</a> Œ±} : (as ++ bs ++ [b]).getLastD a = b := by
  grind

example (x : <a href="./Init/Prelude.html#BitVec">BitVec</a> (w+1)) : (BitVec.cons x.msb (x.setWidth w)) = x := by
  grind

example (as : <a href="./Init/Prelude.html#Array">Array</a> Œ±) (lo hi i j : Nat) :
    lo ‚â§ i ‚Üí i &lt; j ‚Üí j ‚â§ hi ‚Üí j &lt; as.size ‚Üí min lo (as.size - 1) ‚â§ i := by
  grind
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grindTrace"><h2>grind?</h2><p><p><code>grind?</code> takes the same arguments as <code>grind</code>, but reports an equivalent call to <code>grind only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the <code>grind</code>
theorems in a local invocation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace">Init.Grind.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.grobner"><h2>grobner</h2><p><p><code>grobner</code> solves goals that can be phrased as polynomial equations (with further polynomial equations as hypotheses)
over commutative (semi)rings, using the Grobner basis algorithm.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>grobner</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.grobner">Init.Grind.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Group.group"><h2>group</h2><p><p>Tactic for normalizing expressions in multiplicative groups, without assuming
commutativity, using only the group axioms without any information about which group
is manipulated.</p><p>(For additive commutative groups, use the <code>abel</code> tactic instead.)</p><p>Example:</p><pre><code class="language-lean">example {G : Type} [Group G] (a b c d : G) (h : c = (a*b^2)*((b*b)‚Åª¬π*a‚Åª¬π)*d) : a*c*d‚Åª¬π = a := by
  group at h -- normalizes `h` which becomes `h : c = d`
  rw [h]     -- the goal is now `a*d*d‚Åª¬π = a`
  group      -- which then normalized and closed
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Group.html#Mathlib.Tactic.Group.group">Mathlib.Tactic.Group</a></dd></dl></div><div id="Mathlib.Tactic.grwSeq"><h2>grw</h2><p><p><code>grw [e]</code> works just like <code>rw [e]</code>, but <code>e</code> can be a relation other than <code>=</code> or <code>‚Üî</code>.</p><p>For example:</p><pre><code class="language-lean">variable {a b c d n : ‚Ñ§}

example (h‚ÇÅ : a &lt; b) (h‚ÇÇ : b ‚â§ c) : a + d ‚â§ c + d := by
  grw [h‚ÇÅ, h‚ÇÇ]

example (h : a ‚â° b [ZMOD n]) : a ^ 2 ‚â° b ^ 2 [ZMOD n] := by
  grw [h]

example (h‚ÇÅ : a ‚à£ b) (h‚ÇÇ : b ‚à£ a ^ 2 * c) : a ‚à£ b ^ 2 * c := by
  grw [h‚ÇÅ] at *
  exact h‚ÇÇ
</code></pre><p>To replace the RHS with the LHS of the given relation, use the <code>‚Üê</code> notation (just like in <code>rw</code>):</p><pre><code>example (h‚ÇÅ : a &lt; b) (h‚ÇÇ : b ‚â§ c) : a + d ‚â§ c + d := by
  grw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÅ]
</code></pre><p>The strict inequality <code>a &lt; b</code> is turned into the non-strict inequality <code>a ‚â§ b</code> to rewrite with it.
A future version of <code>grw</code> may get special support for making better use of strict inequalities.</p><p>To rewrite only in the <code>n</code>-th position, use <code>nth_grw n</code>.
This is useful when <code>grw</code> tries to rewrite in a position that is not valid for the given relation.</p><p>To be able to use <code>grw</code>, the relevant lemmas need to be tagged with <code>@[gcongr]</code>.
To rewrite inside a transitive relation, you can also give it an <code><a href="./Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a></code> instance.</p><p>To let <code>grw</code> unfold more aggressively, as in <code>erw</code>, use <code>grw (transparency := default)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.grwSeq">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Lean.Parser.Tactic.guardExpr"><h2>guard_expr</h2><p><p>Tactic to check equality of two expressions.</p><ul><li><code>guard_expr e = e'</code> checks that <code>e</code> and <code>e'</code> are defeq at reducible transparency.</li><li><code>guard_expr e =~ e'</code> checks that <code>e</code> and <code>e'</code> are defeq at default transparency.</li><li><code>guard_expr e =‚Çõ e'</code> checks that <code>e</code> and <code>e'</code> are syntactically equal.</li><li><code>guard_expr e =‚Çê e'</code> checks that <code>e</code> and <code>e'</code> are alpha-equivalent.</li></ul><p>Both <code>e</code> and <code>e'</code> are elaborated then have their metavariables instantiated before the equality
check. Their types are unified (using <code>isDefEqGuarded</code>) before synthetic metavariables are
processed, which helps with default instance handling.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardExpr">Init.Guard</a></dd></dl></div><div id="guardGoalNums"><h2>guard_goal_nums</h2><p><p><code>guard_goal_nums n</code> succeeds if there are exactly <code>n</code> goals and fails otherwise.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GuardGoalNums.html#guardGoalNums">Mathlib.Tactic.GuardGoalNums</a></dd></dl></div><div id="Lean.Parser.Tactic.guardHyp"><h2>guard_hyp</h2><p><p>Tactic to check that a named hypothesis has a given type and/or value.</p><ul><li><code>guard_hyp h : t</code> checks the type up to reducible defeq,</li><li><code>guard_hyp h :~ t</code> checks the type up to default defeq,</li><li><code>guard_hyp h :‚Çõ t</code> checks the type up to syntactic equality,</li><li><code>guard_hyp h :‚Çê t</code> checks the type up to alpha equality.</li><li><code>guard_hyp h := v</code> checks value up to reducible defeq,</li><li><code>guard_hyp h :=~ v</code> checks value up to default defeq,</li><li><code>guard_hyp h :=‚Çõ v</code> checks value up to syntactic equality,</li><li><code>guard_hyp h :=‚Çê v</code> checks the value up to alpha equality.</li></ul><p>The value <code>v</code> is elaborated using the type of <code>h</code> as the expected type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardHyp">Init.Guard</a></dd></dl></div><div id="guardHypNums"><h2>guard_hyp_nums</h2><p><p><code>guard_hyp_nums n</code> succeeds if there are exactly <code>n</code> hypotheses and fails otherwise.</p><p>Note that, depending on what options are set, some hypotheses in the local context might
not be printed in the goal view. This tactic computes the total number of hypotheses,
not the number of visible hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GuardHypNums.html#guardHypNums">Mathlib.Tactic.GuardHypNums</a></dd></dl></div><div id="Lean.Parser.Tactic.guardTarget"><h2>guard_target</h2><p><p>Tactic to check that the target agrees with a given expression.</p><ul><li><code>guard_target = e</code> checks that the target is defeq at reducible transparency to <code>e</code>.</li><li><code>guard_target =~ e</code> checks that the target is defeq at default transparency to <code>e</code>.</li><li><code>guard_target =‚Çõ e</code> checks that the target is syntactically equal to <code>e</code>.</li><li><code>guard_target =‚Çê e</code> checks that the target is alpha-equivalent to <code>e</code>.</li></ul><p>The term <code>e</code> is elaborated with the type of the goal as the expected type, which is mostly
useful within <code>conv</code> mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Guard.html#Lean.Parser.Tactic.guardTarget">Init.Guard</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHave__"><h2>have</h2><p><p>The <code>have</code> tactic is for adding opaque definitions and hypotheses to the local context of the main goal.
The definitions forget their associated value and cannot be unfolded, unlike definitions added by the <code>let</code> tactic.</p><ul><li><code>have h : t := e</code> adds the hypothesis <code>h : t</code> if <code>e</code> is a term of type <code>t</code>.</li><li><code>have h := e</code> uses the type of <code>e</code> for <code>t</code>.</li><li><code>have : t := e</code> and <code>have := e</code> use <code>this</code> for the name of the hypothesis.</li><li><code>have pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that have only one applicable constructor.
For example, given <code>h : p ‚àß q ‚àß r</code>, <code>have ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h</code> produces the
hypotheses <code>h‚ÇÅ : p</code>, <code>h‚ÇÇ : q</code>, and <code>h‚ÇÉ : r</code>.</li><li>The syntax <code>have (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li></ul><p>The tactic supports all the same syntax variants and options as the <code>have</code> term.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li>It is not possible to unfold a variable introduced using <code>have</code>, since the definition's value is forgotten.
The <code>let</code> tactic introduces definitions that can be unfolded.</li><li>The <code>have h : t := e</code> is like doing <code>let h : t := e; clear_value h</code>.</li><li>The <code>have</code> tactic is preferred for propositions, and <code>let</code> is preferred for non-propositions.</li><li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.
Consider using the equivalent <code>let +nondep</code> to indicate the intent.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHave__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHave'"><h2>have'</h2><p><p>Similar to <code>have</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticHaveI__"><h2>haveI</h2><p><p><code>haveI</code> behaves like <code>have</code>, but inlines the value instead of producing a <code>have</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticHaveI__">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Hint.hintStx"><h2>hint</h2><p><p>The <code>hint</code> tactic tries every tactic registered using <code>register_hint &lt;prio&gt; tac</code>,
and reports any that succeed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Hint.html#Mathlib.Tactic.Hint.hintStx">Mathlib.Tactic.Hint</a></dd></dl></div><div id="Lean.Parser.Tactic.unknown"><h2>ident</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.unknown">Lean.Parser.Tactic</a></dd></dl></div><div id="Lean.Parser.Tactic.tacIfThenElse"><h2>if</h2><p><p>In tactic mode, <code>if t then tac1 else tac2</code> is alternative syntax for:</p><pre><code>by_cases t
¬∑ tac1
¬∑ tac2
</code></pre><p>It performs case distinction on <code>h‚Ä† : t</code> or <code>h‚Ä† : ¬¨t</code>, where <code>h‚Ä†</code> is an anonymous hypothesis, and
<code>tac1</code> and <code>tac2</code> are the subproofs. (It doesn't actually use nondependent <code>if</code>, since this wouldn't
add anything to the context and hence would be useless for proving theorems. To actually insert an
<code><a href="./Init/Prelude.html#ite">ite</a></code> application use <code>refine if t then ?_ else ?_</code>.)</p><p>The assumptions in each subgoal can be named. <code>if h : t then tac1 else tac2</code> can be used as
alternative syntax for:</p><pre><code>by_cases h : t
¬∑ tac1
¬∑ tac2
</code></pre><p>It performs case distinction on <code>h : t</code> or <code>h : ¬¨t</code>.</p><p>You can use <code>?_</code> or <code>_</code> for either subproof to delay the goal to after the tactic, but
if a tactic sequence is provided for <code>tac1</code> or <code>tac2</code> then it will require the goal to be closed
by the end of the block.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacIfThenElse">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.induction"><h2>induction</h2><p><p>Assuming <code>x</code> is a variable in the local context with an inductive type,
<code>induction x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code>h : P n</code> and target <code>Q n</code>,
<code>induction n</code> produces one goal with hypothesis <code>h : P 0</code> and target <code>Q 0</code>,
and one goal with hypotheses <code>h : P (Nat.succ a)</code> and <code>ih‚ÇÅ : P a ‚Üí Q a</code> and target <code>Q (Nat.succ a)</code>.
Here the names <code>a</code> and <code>ih‚ÇÅ</code> are chosen automatically and are not accessible.
You can use <code>with</code> to provide the variables names for each constructor.</p><ul><li><code>induction e</code>, where <code>e</code> is an expression instead of a variable,
generalizes <code>e</code> in the goal, and then performs induction on the resulting variable.</li><li><code>induction e using r</code> allows the user to specify the principle of induction that should be used.
Here <code>r</code> should be a term whose result type must be of the form <code>C t</code>,
where <code>C</code> is a bound variable and <code>t</code> is a (possibly empty) sequence of bound variables</li><li><code>induction e generalizing z‚ÇÅ ... z‚Çô</code>, where <code>z‚ÇÅ ... z‚Çô</code> are variables in the local context,
generalizes over <code>z‚ÇÅ ... z‚Çô</code> before applying the induction but then introduces them in each goal.
In other words, the net effect is that each inductive hypothesis is generalized.</li><li>Given <code>x : <a href="./Init/Prelude.html#Nat">Nat</a></code>, <code>induction x with | zero =&gt; tac‚ÇÅ | succ x' ih =&gt; tac‚ÇÇ</code>
uses tactic <code>tac‚ÇÅ</code> for the <code>zero</code> case, and <code>tac‚ÇÇ</code> for the <code>succ</code> case.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.induction">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticInfer_instance"><h2>infer_instance</h2><p><p><code>infer_instance</code> is an abbreviation for <code>exact <a href="./Init/Prelude.html#inferInstance">inferInstance</a></code>.
It synthesizes a value of any target type by typeclass inference.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.inferOptParam"><h2>infer_param</h2><p><p>Close a goal of the form <code><a href="./Init/Prelude.html#optParam">optParam</a> Œ± a</code> or <code><a href="./Init/Tactics.html#autoParam">autoParam</a> Œ± stx</code> by using <code>a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/InferParam.html#Mathlib.Tactic.inferOptParam">Mathlib.Tactic.InferParam</a></dd></dl></div><div id="Lean.Elab.Tactic.inhabit"><h2>inhabit</h2><p><p><code>inhabit Œ±</code> tries to derive a <code><a href="./Init/Prelude.html#Nonempty">Nonempty</a> Œ±</code> instance and
then uses it to make an <code><a href="./Init/Prelude.html#Inhabited">Inhabited</a> Œ±</code> instance.
If the target is a <code>Prop</code>, this is done constructively. Otherwise, it uses <code><a href="./Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Inhabit.html#Lean.Elab.Tactic.inhabit">Mathlib.Tactic.Inhabit</a></dd></dl></div><div id="Lean.Parser.Tactic.injection"><h2>injection</h2><p><p>The <code>injection</code> tactic is based on the fact that constructors of inductive data
types are injections.
That means that if <code>c</code> is a constructor of an inductive datatype, and if <code>(c t‚ÇÅ)</code>
and <code>(c t‚ÇÇ)</code> are two terms that are equal then  <code>t‚ÇÅ</code> and <code>t‚ÇÇ</code> are equal too.
If <code>q</code> is a proof of a statement of conclusion <code>t‚ÇÅ = t‚ÇÇ</code>, then injection applies
injectivity to derive the equality of all arguments of <code>t‚ÇÅ</code> and <code>t‚ÇÇ</code> placed in
the same positions. For example, from <code>(a::b) = (c::d)</code> we derive <code>a=c</code> and <code>b=d</code>.
To use this tactic <code>t‚ÇÅ</code> and <code>t‚ÇÇ</code> should be constructor applications of the same constructor.
Given <code>h : a::b = c::d</code>, the tactic <code>injection h</code> adds two new hypothesis with types
<code>a = c</code> and <code>b = d</code> to the main goal.
The tactic <code>injection h with h‚ÇÅ h‚ÇÇ</code> uses the names <code>h‚ÇÅ</code> and <code>h‚ÇÇ</code> to name the new hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.injection">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.injections"><h2>injections</h2><p><p><code>injections</code> applies <code>injection</code> to all hypotheses recursively
(since <code>injection</code> can produce new hypotheses). Useful for destructing nested
constructor equalities like <code>(a::b::c) = (d::e::f)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.injections">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.intervalCases"><h2>interval_cases</h2><p><p><code>interval_cases n</code> searches for upper and lower bounds on a variable <code>n</code>,
and if bounds are found,
splits into separate cases for each possible value of <code>n</code>.</p><p>As an example, in</p><pre><code>example (n : ‚Ñï) (w‚ÇÅ : n ‚â• 3) (w‚ÇÇ : n &lt; 5) : n = 3 ‚à® n = 4 := by
  interval_cases n
  all_goals simp
</code></pre><p>after <code>interval_cases n</code>, the goals are <code>3 = 3 ‚à® 3 = 4</code> and <code>4 = 3 ‚à® 4 = 4</code>.</p><p>You can also explicitly specify a lower and upper bound to use,
as <code>interval_cases using hl, hu</code>.
The hypotheses should be in the form <code>hl : a ‚â§ n</code> and <code>hu : n &lt; b</code>,
in which case <code>interval_cases</code> calls <code>fin_cases</code> on the resulting fact <code>n ‚àà <a href="./Mathlib/Order/Interval/Set/Defs.html#Set.Ico">Set.Ico</a> a b</code>.</p><p>You can specify a name <code>h</code> for the new hypothesis,
as <code>interval_cases h : n</code> or <code>interval_cases h : n using hl, hu</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/IntervalCases.html#Mathlib.Tactic.intervalCases">Mathlib.Tactic.IntervalCases</a></dd></dl></div><div id="Lean.Parser.Tactic.intro"><h2>intro</h2><p><p>Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a <code>let</code> or function type.</p><ul><li><code>intro</code> by itself introduces one anonymous hypothesis, which can be accessed
by e.g. <code>assumption</code>. It is equivalent to <code>intro _</code>.</li><li><code>intro x y</code> introduces two hypotheses and names them. Individual hypotheses
can be anonymized via <code>_</code>, given a type ascription, or matched against a pattern:<pre><code class="language-lean">-- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...
intro (a, b)
-- ..., a : Œ±, b : Œ≤ ‚ä¢ ...
</code></pre></li><li><code>intro <a href="./Init/Prelude.html#rfl">rfl</a></code> is short for <code>intro h; subst h</code>, if <code>h</code> is an equality where the left-hand or right-hand side
is a variable.</li><li>Alternatively, <code>intro</code> can be combined with pattern matching much like <code>fun</code>:<pre><code class="language-lean">intro
| n + 1, 0 =&gt; tac
| ...
</code></pre></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.intro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.intros"><h2>intros</h2><p><p><code>intros</code> repeatedly applies <code>intro</code> to introduce zero or more hypotheses
until the goal is no longer a <em>binding expression</em>
(i.e., a universal quantifier, function type, implication, or <code>have</code>/<code>let</code>),
without performing any definitional reductions (no unfolding, beta, eta, etc.).
The introduced hypotheses receive inaccessible (hygienic) names.</p><p><code>intros x y z</code> is equivalent to <code>intro x y z</code> and exists only for historical reasons.
The <code>intro</code> tactic should be preferred in this case.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li><p><code>intros</code> succeeds even when it introduces no hypotheses.</p></li><li><p><code>repeat intro</code> is like <code>intros</code>, but it performs definitional reductions
to expose binders, and as such it may introduce more hypotheses than <code>intros</code>.</p></li><li><p><code>intros</code> is equivalent to <code>intro _ _ ‚Ä¶ _</code>,
with the fewest trailing <code>_</code> placeholders needed so that the goal is no longer a binding expression.
The trailing introductions do not perform any definitional reductions.</p></li></ul><h2 id="Examples" class="markdown-heading">Examples <a class="hover-link" href="#Examples">#</a></h2><p>Implications:</p><pre><code class="language-lean">example (p q : Prop) : p ‚Üí q ‚Üí p := by
  intros
  /- Tactic state
     a‚úù¬π : p
     a‚úù : q
     ‚ä¢ p      -/
  assumption
</code></pre><p>Let-bindings:</p><pre><code class="language-lean">example : let n := 1; let k := 2; n + k = 3 := by
  intros
  /- n‚úù : <a href="./Init/Prelude.html#Nat">Nat</a> := 1
     k‚úù : <a href="./Init/Prelude.html#Nat">Nat</a> := 2
     ‚ä¢ n‚úù + k‚úù = 3 -/
  <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre><p>Does not unfold definitions:</p><pre><code class="language-lean">def AllEven (f : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí Nat) := ‚àÄ n, f n % 2 = 0

example : ‚àÄ (f : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí Nat), AllEven f ‚Üí AllEven (fun k =&gt; f (k + 1)) := by
  intros
  /- Tactic state
     f‚úù : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí <a href="./Init/Prelude.html#Nat">Nat</a>
     a‚úù : AllEven f‚úù
     ‚ä¢ AllEven fun k =&gt; f‚úù (k + 1) -/
  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.intros">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.introv"><h2>introv</h2><p><p>The tactic <code>introv</code> allows the user to automatically introduce the variables of a theorem and
explicitly name the non-dependent hypotheses.
Any dependent hypotheses are assigned their default names.</p><p>Examples:</p><pre><code>example : ‚àÄ a b : Nat, a = b ‚Üí b = a := by
  introv h,
  exact h.symm
</code></pre><p>The state after <code>introv h</code> is</p><pre><code>a b : ‚Ñï,
h : a = b
‚ä¢ b = a
</code></pre><pre><code>example : ‚àÄ a b : Nat, a = b ‚Üí ‚àÄ c, b = c ‚Üí a = c := by
  introv h‚ÇÅ h‚ÇÇ,
  exact h‚ÇÅ.trans h‚ÇÇ
</code></pre><p>The state after <code>introv h‚ÇÅ h‚ÇÇ</code> is</p><pre><code>a b : ‚Ñï,
h‚ÇÅ : a = b,
c : ‚Ñï,
h‚ÇÇ : b = c
‚ä¢ a = c
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.introv">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Filter.tacticIsBoundedDefault"><h2>isBoundedDefault</h2><p><p>Filters are automatically bounded or cobounded in complete lattices. To use the same statements
in complete and conditionally complete lattices but let automation fill automatically the
boundedness proofs in complete lattices, we use the tactic <code>isBoundedDefault</code> in the statements,
in the form <code>(hf : f.IsBounded (‚â•) := by isBoundedDefault)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Order/Filter/IsBounded.html#Filter.tacticIsBoundedDefault">Mathlib.Order.Filter.IsBounded</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticIterate____"><h2>iterate</h2><p><p><code>iterate n tac</code> runs <code>tac</code> exactly <code>n</code> times.
<code>iterate tac</code> runs <code>tac</code> repeatedly until failure.</p><p><code>iterate</code>'s argument is a tactic sequence,
so multiple tactics can be run using <code>iterate n (tac‚ÇÅ; tac‚ÇÇ; ‚ãØ)</code> or</p><pre><code class="language-lean">iterate n
  tac‚ÇÅ
  tac‚ÇÇ
  ‚ãØ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticIterate____">Init.TacticsExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.left"><h2>left</h2><p><p>Applies the first constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example : <a href="./Init/Prelude.html#True">True</a> ‚à® <a href="./Init/Prelude.html#False">False</a> := by
  left
  <a href="./Init/Core.html#trivial">trivial</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.left">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLet__"><h2>let</h2><p><p>The <code>let</code> tactic is for adding definitions to the local context of the main goal.
The definition can be unfolded, unlike definitions introduced by <code>have</code>.</p><ul><li><code>let x : t := e</code> adds the definition <code>x : t := e</code> if <code>e</code> is a term of type <code>t</code>.</li><li><code>let x := e</code> uses the type of <code>e</code> for <code>t</code>.</li><li><code>let : t := e</code> and <code>let := e</code> use <code>this</code> for the name of the hypothesis.</li><li><code>let pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,
where <code>_</code> stands for the tactics that follow this one.
It is convenient for types that let only one applicable constructor.
For example, given <code>p : Œ± √ó Œ≤ √ó Œ≥</code>, <code>let ‚ü®x, y, z‚ü© := p</code> produces the
local variables <code>x : Œ±</code>, <code>y : Œ≤</code>, and <code>z : Œ≥</code>.</li><li>The syntax <code>let (eq := h) pat := e</code> is equivalent to <code>match h : e with | pat =&gt; _</code>,
which adds the equation <code>h : e = pat</code> to the local context.</li></ul><p>The tactic supports all the same syntax variants and options as the <code>let</code> term.</p><h2 id="Properties-and-relations" class="markdown-heading">Properties and relations <a class="hover-link" href="#Properties-and-relations">#</a></h2><ul><li>Unlike <code>have</code>, it is possible to unfold definitions introduced using <code>let</code>, using tactics
such as <code>simp</code>, <code>dsimp</code>, <code>unfold</code>, and <code>subst</code>.</li><li>The <code>clear_value</code> tactic turns a <code>let</code> definition into a <code>have</code> definition after the fact.
The tactic might fail if the local context depends on the value of the variable.</li><li>The <code>let</code> tactic is preferred for data (non-propositions).</li><li>Sometimes <code>have</code> is used for non-propositions to ensure that the variable is never unfolded,
which may be important for performance reasons.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLet__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.letrec"><h2>let rec</h2><p><p><code>let rec f : t := e</code> adds a recursive definition <code>f</code> to the current goal.
The syntax is the same as term-mode <code>let rec</code>.</p><p>The tactic supports all the same syntax variants and options as the <code>let</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.letrec">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLet'__"><h2>let'</h2><p><p>Similar to <code>let</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticLetI__"><h2>letI</h2><p><p><code>letI</code> behaves like <code>let</code>, but inlines the value instead of producing a <code>let</code> term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticLetI__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.letToHave"><h2>let_to_have</h2><p><p>Transforms <code>let</code> expressions into <code>have</code> expressions when possible.</p><ul><li><code>let_to_have</code> transforms <code>let</code>s in the target.</li><li><code>let_to_have at h</code> transforms <code>let</code>s in the given local hypothesis.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.letToHave">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.lia"><h2>lia</h2><p><p><code>lia</code> solves linear integer arithmetic goals.</p><p>It is a implemented as a thin wrapper around the <code>grind</code> tactic, enabling only the <code>lia</code> solver.
Please use <code>grind</code> instead if you need additional capabilities.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Grind/Tactics.html#Lean.Parser.Tactic.lia">Init.Grind.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.lift"><h2>lift</h2><p><p>Lift an expression to another type.</p><ul><li>Usage: <code>'lift' expr 'to' expr ('using' expr)? ('with' <a href="./Init/Prelude.html#id">id</a> (id id?)?)?</code>.</li><li>If <code>n : ‚Ñ§</code> and <code>hn : n ‚â• 0</code> then the tactic <code>lift n to ‚Ñï using hn</code> creates a new
constant of type <code>‚Ñï</code>, also named <code>n</code> and replaces all occurrences of the old variable <code>(n : ‚Ñ§)</code>
with <code>‚Üën</code> (where <code>n</code> in the new variable). It will clear <code>n</code> from the context and
try to clear <code>hn</code> from the context.<ul><li>So for example the tactic <code>lift n to ‚Ñï using hn</code> transforms the goal
<code>n : ‚Ñ§, hn : n ‚â• 0, h : P n ‚ä¢ n = 3</code> to <code>n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3</code>
(here <code>P</code> is some term of type <code>‚Ñ§ ‚Üí Prop</code>).</li></ul></li><li>The argument <code>using hn</code> is optional, the tactic <code>lift n to ‚Ñï</code> does the same, but also creates a
new subgoal that <code>n ‚â• 0</code> (where <code>n</code> is the old variable).
This subgoal will be placed at the top of the goal list.<ul><li>So for example the tactic <code>lift n to ‚Ñï</code> transforms the goal
<code>n : ‚Ñ§, h : P n ‚ä¢ n = 3</code> to two goals
<code>n : ‚Ñ§, h : P n ‚ä¢ n ‚â• 0</code> and <code>n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3</code>.</li></ul></li><li>You can also use <code>lift n to ‚Ñï using e</code> where <code>e</code> is any expression of type <code>n ‚â• 0</code>.</li><li>Use <code>lift n to ‚Ñï with k</code> to specify the name of the new variable.</li><li>Use <code>lift n to ‚Ñï with k hk</code> to also specify the name of the equality <code>‚Üëk = n</code>. In this case, <code>n</code>
will remain in the context. You can use <code><a href="./Init/Prelude.html#rfl">rfl</a></code> for the name of <code>hk</code> to substitute <code>n</code> away
(i.e. the default behavior).</li><li>You can also use <code>lift e to ‚Ñï with k hk</code> where <code>e</code> is any expression of type <code>‚Ñ§</code>.
In this case, the <code>hk</code> will always stay in the context, but it will be used to rewrite <code>e</code> in
all hypotheses and the target.<ul><li>So for example the tactic <code>lift n + 3 to ‚Ñï using hn with k hk</code> transforms the goal
<code>n : ‚Ñ§, hn : n + 3 ‚â• 0, h : P (n + 3) ‚ä¢ n + 3 = 2 * n</code> to the goal
<code>n : ‚Ñ§, k : ‚Ñï, hk : ‚Üëk = n + 3, h : P ‚Üëk ‚ä¢ ‚Üëk = 2 * n</code>.</li></ul></li><li>The tactic <code>lift n to ‚Ñï using h</code> will remove <code>h</code> from the context. If you want to keep it,
specify it again as the third argument to <code>with</code>, like this: <code>lift n to ‚Ñï using h with n <a href="./Init/Prelude.html#rfl">rfl</a> h</code>.</li><li>More generally, this can lift an expression from <code>Œ±</code> to <code>Œ≤</code> assuming that there is an instance
of <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> Œ± Œ≤</code>. In this case the proof obligation is specified by <code><a href="./Mathlib/Tactic/Lift.html#CanLift.prf">CanLift.prf</a></code>.</li><li>Given an instance <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> Œ≤ Œ≥</code>, it can also lift <code>Œ± ‚Üí Œ≤</code> to <code>Œ± ‚Üí Œ≥</code>; more generally, given
<code>Œ≤ : Œ† a : Œ±, Type*</code>, <code>Œ≥ : Œ† a : Œ±, Type*</code>, and <code>[Œ† a : Œ±, <a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> (Œ≤ a) (Œ≥ a)]</code>, it
automatically generates an instance <code><a href="./Mathlib/Tactic/Lift.html#CanLift">CanLift</a> (Œ† a, Œ≤ a) (Œ† a, Œ≥ a)</code>.</li></ul><p><code>lift</code> is in some sense dual to the <code>zify</code> tactic. <code>lift (z : ‚Ñ§) to ‚Ñï</code> will change the type of an
integer <code>z</code> (in the supertype) to <code>‚Ñï</code> (the subtype), given a proof that <code>z ‚â• 0</code>;
propositions concerning <code>z</code> will still be over <code>‚Ñ§</code>. <code>zify</code> changes propositions about <code>‚Ñï</code> (the
subtype) to propositions about <code>‚Ñ§</code> (the supertype), without changing the type of any variable.</p><p>The <code>norm_cast</code> tactic can be used after <code>lift</code> to normalize introduced casts.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Lift.html#Mathlib.Tactic.lift">Mathlib.Tactic.Lift</a></dd></dl></div><div id="Lean.Parser.Tactic.liftLets"><h2>lift_lets</h2><p><p>Lifts <code>let</code> and <code>have</code> expressions within a term as far out as possible.
It is like <code>extract_lets +lift</code>, but the top-level lets at the end of the procedure
are not extracted as local hypotheses.</p><ul><li><code>lift_lets</code> lifts let expressions in the target.</li><li><code>lift_lets at h</code> lifts let expressions at the given local hypothesis.</li></ul><p>For example,</p><pre><code class="language-lean">example : (let x := 1; x) = 1 := by
  lift_lets
  -- ‚ä¢ let x := 1; x = 1
  ...
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.liftLets">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.linarith"><h2>linarith</h2><p><p><code>linarith</code> attempts to find a contradiction between hypotheses that are linear (in)equalities.
Equivalently, it can prove a linear inequality by assuming its negation and proving <code><a href="./Init/Prelude.html#False">False</a></code>.</p><p>In theory, <code>linarith</code> should prove any goal that is true in the theory of linear arithmetic over
the rationals. While there is some special handling for non-dense orders like <code><a href="./Init/Prelude.html#Nat">Nat</a></code> and <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>,
this tactic is not complete for these theories and will not prove every true goal. It will solve
goals over arbitrary types that instantiate <code><a href="./Mathlib/Algebra/Ring/Defs.html#CommRing">CommRing</a></code>, <code><a href="./Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code> and <code><a href="./Mathlib/Algebra/Order/Ring/Defs.html#IsStrictOrderedRing">IsStrictOrderedRing</a></code>.</p><p>An example:</p><pre><code class="language-lean">example (x y z : ‚Ñö) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)
        (h3 : 12*y - 4* z &lt; 0) : <a href="./Init/Prelude.html#False">False</a> := by
  linarith
</code></pre><p><code>linarith</code> will use all appropriate hypotheses and the negation of the goal, if applicable.
Disequality hypotheses require case splitting and are not normally considered
(see the <code>splitNe</code> option below).</p><p><code>linarith [t1, t2, t3]</code> will additionally use proof terms <code>t1, t2, t3</code>.</p><p><code>linarith only [h1, h2, h3, t1, t2, t3]</code> will use only the goal (if relevant), local hypotheses
<code>h1</code>, <code>h2</code>, <code>h3</code>, and proofs <code>t1</code>, <code>t2</code>, <code>t3</code>. It will ignore the rest of the local context.</p><p><code>linarith!</code> will use a stronger reducibility setting to try to identify atoms. For example,</p><pre><code class="language-lean">example (x : ‚Ñö) : <a href="./Init/Prelude.html#id">id</a> x ‚â• x := by
  linarith
</code></pre><p>will fail, because <code>linarith</code> will not identify <code>x</code> and <code><a href="./Init/Prelude.html#id">id</a> x</code>. <code>linarith!</code> will.
This can sometimes be expensive.</p><p><code>linarith (config := { .. })</code> takes a config object with five
optional arguments:</p><ul><li><code>discharger</code> specifies a tactic to be used for reducing an algebraic equation in the
proof stage. The default is <code>ring</code>. Other options include <code>simp</code> for basic
problems.</li><li><code>transparency</code> controls how hard <code>linarith</code> will try to match atoms to each other. By default
it will only unfold <code>reducible</code> definitions.</li><li>If <code>splitHypotheses</code> is true, <code>linarith</code> will split conjunctions in the context into separate
hypotheses.</li><li>If <code>splitNe</code> is <code>true</code>, <code>linarith</code> will case split on disequality hypotheses.
For a given <code>x ‚â† y</code> hypothesis, <code>linarith</code> is run with both <code>x &lt; y</code> and <code>x &gt; y</code>,
and so this runs linarith exponentially many times with respect to the number of
disequality hypotheses. (<code>false</code> by default.)</li><li>If <code>exfalso</code> is <code>false</code>, <code>linarith</code> will fail when the goal is neither an inequality nor <code><a href="./Init/Prelude.html#False">False</a></code>.
(<code>true</code> by default.)</li><li>If <code>minimize</code> is <code>false</code>, <code>linarith?</code> will report all hypotheses appearing in its initial
proof without attempting to drop redundancies. (<code>true</code> by default.)</li><li><code>restrict_type</code> (not yet implemented in mathlib4)
will only use hypotheses that are inequalities over <code>tp</code>. This is useful
if you have e.g. both integer- and rational-valued inequalities in the local context, which can
sometimes confuse the tactic.</li></ul><p>A variant, <code>nlinarith</code>, does some basic preprocessing to handle some nonlinear goals.</p><p>The option <code>set_option trace.linarith true</code> will trace certain intermediate stages of the <code>linarith</code>
routine.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Mathlib.Tactic.linarith?"><h2>linarith?</h2><p><p><code>linarith?</code> behaves like <code>linarith</code> but, on success, it prints a suggestion of
the form <code>linarith only [...]</code> listing a minimized set of hypotheses used in the
final proof.  Use <code>linarith?!</code> for the higher-reducibility variant and set the
<code>minimize</code> flag in the configuration to control whether greedy minimization is
performed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.linarith?">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Mathlib.Tactic.LinearCombination.linearCombination"><h2>linear_combination</h2><p><p>The <code>linear_combination</code> tactic attempts to prove an (in)equality goal by exhibiting it as a
specified linear combination of (in)equality hypotheses, or other (in)equality proof terms, modulo
(A) moving terms between the LHS and RHS of the (in)equalities, and (B) a normalization tactic
which by default is ring-normalization.</p><p>Example usage:</p><pre><code>example {a b : ‚Ñö} (h1 : a = 1) (h2 : b = 3) : (a + b) / 2 = 2 := by
  linear_combination (h1 + h2) / 2

example {a b : ‚Ñö} (h1 : a ‚â§ 1) (h2 : b ‚â§ 3) : (a + b) / 2 ‚â§ 2 := by
  linear_combination (h1 + h2) / 2

example {a b : ‚Ñö} : 2 * a * b ‚â§ a ^ 2 + b ^ 2 := by
  linear_combination <a href="./Mathlib/Algebra/Order/Ring/Unbundled/Basic.html#sq_nonneg">sq_nonneg</a> (a - b)

example {x y z w : ‚Ñ§} (h‚ÇÅ : x * z = y ^ 2) (h‚ÇÇ : y * w = z ^ 2) :
    z * (x * w - y * z) = 0 := by
  linear_combination w * h‚ÇÅ + y * h‚ÇÇ

example {x : ‚Ñö} (h : x ‚â• 5) : x ^ 2 &gt; 2 * x + 11 := by
  linear_combination (x + 3) * h

example {R : Type*} [CommRing R] {a b : R} (h : a = b) : a ^ 2 = b ^ 2 := by
  linear_combination (a + b) * h

example {A : Type*} [AddCommGroup A]
    {x y z : A} (h1 : x + y = 10 ‚Ä¢ z) (h2 : x - y = 6 ‚Ä¢ z) :
    2 ‚Ä¢ x = 2 ‚Ä¢ (8 ‚Ä¢ z) := by
  linear_combination (norm := abel) h1 + h2

example (x y : ‚Ñ§) (h1 : x * y + 2 * x = 1) (h2 : x = y) :
    x * y = -2 * y + 1 := by
  linear_combination (norm := ring_nf) -2 * h2
  -- leaves goal `‚ä¢ x * y + x * 2 - 1 = 0`
</code></pre><p>The input <code>e</code> in <code>linear_combination e</code> is a linear combination of proofs of (in)equalities,
given as a sum/difference of coefficients multiplied by expressions.
The coefficients may be arbitrary expressions (with nonnegativity constraints in the case of
inequalities).
The expressions can be arbitrary proof terms proving (in)equalities;
most commonly they are hypothesis names <code>h1</code>, <code>h2</code>, ....</p><p>The left and right sides of all the (in)equalities should have the same type <code>Œ±</code>, and the
coefficients should also have type <code>Œ±</code>.  For full functionality <code>Œ±</code> should be a commutative ring --
strictly speaking, a commutative semiring with &quot;cancellative&quot; addition (in the semiring case,
negation and subtraction will be handled &quot;formally&quot; as if operating in the enveloping ring). If a
nonstandard normalization is used (for example <code>abel</code> or <code>skip</code>), the tactic will work over types
<code>Œ±</code> with less algebraic structure: for equalities, the minimum is instances of
<code>[Add Œ±] [IsRightCancelAdd Œ±]</code> together with instances of whatever operations are used in the tactic
call.</p><p>The variant <code>linear_combination (norm := tac) e</code> specifies explicitly the &quot;normalization tactic&quot;
<code>tac</code> to be run on the subgoal(s) after constructing the linear combination.</p><ul><li>The default normalization tactic is <code>ring1</code> (for equalities) or <code>Mathlib.Tactic.Ring.prove{LE,LT}</code>
(for inequalities). These are finishing tactics: they close the goal or fail.</li><li>When working in algebraic categories other than commutative rings -- for example fields, abelian
groups, modules -- it is sometimes useful to use normalization tactics adapted to those categories
(<code>field_simp</code>, <code>abel</code>, <code>module</code>).</li><li>To skip normalization entirely, use <code>skip</code> as the normalization tactic.</li><li>The <code>linear_combination</code> tactic creates a linear combination by adding the provided (in)equalities
together from left to right, so if <code>tac</code> is not invariant under commutation of additive
expressions, then the order of the input hypotheses can matter.</li></ul><p>The variant <code>linear_combination (exp := n) e</code> will take the goal to the <code>n</code>th power before
subtracting the combination <code>e</code>. In other words, if the goal is <code>t1 = t2</code>,
<code>linear_combination (exp := n) e</code> will change the goal to <code>(t1 - t2)^n = 0</code> before proceeding as
above.  This variant is implemented only for linear combinations of equalities (i.e., not for
inequalities).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/LinearCombination.html#Mathlib.Tactic.LinearCombination.linearCombination">Mathlib.Tactic.LinearCombination</a></dd></dl></div><div id="Batteries.Tactic.¬´tacticMap_tacs[_;]¬ª"><h2>map_tacs</h2><p><p>Assuming there are <code>n</code> goals, <code>map_tacs [t1; t2; ...; tn]</code> applies each <code>ti</code> to the respective
goal and leaves the resulting subgoals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/SeqFocus.html#Batteries.Tactic.¬´tacticMap_tacs[_;]¬ª">Batteries.Tactic.SeqFocus</a></dd></dl></div><div id="Lean.Parser.Tactic.massumptionMacro"><h2>massumption</h2><p><p><code>massumption</code> is like <code>assumption</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : Q ‚ä¢‚Çõ P ‚Üí Q := by
  mintro _ _
  massumption
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.massumptionMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.match"><h2>match</h2><p><p><code>match</code> performs case analysis on one or more expressions.
See <a href="https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html">Induction and Recursion</a>.
The syntax for the <code>match</code> tactic is the same as term-mode <code>match</code>, except that
the match arms are tactics instead of expressions.</p><pre><code>example (n : Nat) : n = n := by
  match n with
  | 0 =&gt; <a href="./Init/Prelude.html#rfl">rfl</a>
  | i+1 =&gt; simp
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Tactic.html#Lean.Parser.Tactic.match">Lean.Parser.Tactic</a></dd></dl></div><div id="Mathlib.Tactic.Module.tacticMatch_scalars"><h2>match_scalars</h2><p><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="./Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some semiring <code>R</code>, and reduce the goal to
the respective equalities of the <code>R</code>-coefficients of each atom.</p><p>For example, this produces the goal <code>‚ä¢ a * 1 + b * 1 = (b + a) * 1</code>:</p><pre><code>example [AddCommMonoid M] [Semiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  match_scalars
</code></pre><p>This produces the two goals <code>‚ä¢ a * (a * 1) + b * (b * 1) = 1</code> (from the <code>x</code> atom) and
<code>‚ä¢ a * -(b * 1) + b * (a * 1) = 0</code> (from the <code>y</code> atom):</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ (a ‚Ä¢ x - b ‚Ä¢ y) + (b ‚Ä¢ a ‚Ä¢ y + b ‚Ä¢ b ‚Ä¢ x) = x := by
  match_scalars
</code></pre><p>This produces the goal <code>‚ä¢ -2 * (a * 1) = a * (-2 * 1)</code>:</p><pre><code>example [AddCommGroup M] [Ring R] [Module R M] (a : R) (x : M) :
    -(2:R) ‚Ä¢ a ‚Ä¢ x = a ‚Ä¢ (-2:‚Ñ§) ‚Ä¢ x  := by
  match_scalars
</code></pre><p>The scalar type for the goals produced by the <code>match_scalars</code> tactic is the largest scalar type
encountered; for example, if <code>‚Ñï</code>, <code>‚Ñö</code> and a characteristic-zero field <code>K</code> all occur as scalars, then
the goals produced are equalities in <code>K</code>.  A variant of <code>push_cast</code> is used internally in
<code>match_scalars</code> to interpret scalars from the other types in this largest type.</p><p>If the set of scalar types encountered is not totally ordered (in the sense that for all rings <code>R</code>,
<code>S</code> encountered, it holds that either <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> R S</code> or <code><a href="./Mathlib/Algebra/Algebra/Defs.html#Algebra">Algebra</a> S R</code>), then the <code>match_scalars</code>
tactic fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticMatch_scalars">Mathlib.Tactic.Module</a></dd></dl></div><div id="Mathlib.Tactic.tacticMatch_target_"><h2>match_target</h2><p><p>Deprecated: use <code>guard_target =~ t</code> instead.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticMatch_target_">Mathlib.Tactic.Basic</a></dd></dl></div><div id="Lean.Parser.Tactic.mcasesMacro"><h2>mcases</h2><p><p>Like <code>rcases</code>, but operating on stateful <code>Std.Do.SPred</code> goals.
Example: Given a goal <code>h : (P ‚àß (Q ‚à® R) ‚àß (Q ‚Üí R)) ‚ä¢‚Çõ R</code>,
<code>mcases h with ‚ü®-, ‚ü®hq | hr‚ü©, hqr‚ü©</code> will yield two goals:
<code>(hq : Q, hqr : Q ‚Üí R) ‚ä¢‚Çõ R</code> and <code>(hr : R) ‚ä¢‚Çõ R</code>.</p><p>That is, <code>mcases h with pat</code> has the following semantics, based on <code>pat</code>:</p><ul><li><code>pat=‚ñ°h'</code> renames <code>h</code> to <code>h'</code> in the stateful context, regardless of whether <code>h</code> is pure</li><li><code>pat=‚åúh'‚åù</code> introduces <code>h' : œÜ</code>  to the pure local context if <code>h : ‚åúœÜ‚åù</code>
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>)</li><li><code>pat=h'</code> is like <code>pat=‚åúh'‚åù</code> if <code>h</code> is pure
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>), otherwise it is like <code>pat=‚ñ°h'</code>.</li><li><code>pat=_</code> renames <code>h</code> to an inaccessible name</li><li><code>pat=-</code> discards <code>h</code></li><li><code>‚ü®pat‚ÇÅ, pat‚ÇÇ‚ü©</code> matches on conjunctions and existential quantifiers and recurses via
<code>pat‚ÇÅ</code> and <code>pat‚ÇÇ</code>.</li><li><code>‚ü®pat‚ÇÅ | pat‚ÇÇ‚ü©</code> matches on disjunctions, matching the left alternative via <code>pat‚ÇÅ</code> and the right
alternative via <code>pat‚ÇÇ</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mcasesMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mclearMacro"><h2>mclear</h2><p><p><code>mclear</code> is like <code>clear</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ Q ‚Üí Q := by
  mintro HP
  mintro HQ
  mclear HP
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mclearMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mconstructorMacro"><h2>mconstructor</h2><p><p><code>mconstructor</code> is like <code>constructor</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (Q : SPred œÉs) : Q ‚ä¢‚Çõ Q ‚àß Q := by
  mintro HQ
  mconstructor &lt;;&gt; mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mconstructorMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mdup"><h2>mdup</h2><p><p>Duplicate a stateful <code><a href="./Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> hypothesis.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Mathlib.Tactic.measurability"><h2>measurability</h2><p><p>The tactic <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> solves goals of the form <code>Measurable f</code>, <code>AEMeasurable f</code>,
<code>StronglyMeasurable f</code>, <code>AEStronglyMeasurable f Œº</code>, or <code>MeasurableSet s</code> by applying lemmas tagged
with the <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> user attribute.</p><p>Note that <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> uses <code>fun_prop</code> for solving measurability of functions, so statements
about <code>Measurable</code>, <code>AEMeasurable</code>, <code>StronglyMeasurable</code> and <code>AEStronglyMeasurable</code> should be tagged
with <code>fun_prop</code> rather that <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code>. The <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> attribute is equivalent to
<code>fun_prop</code> in these cases for backward compatibility with the earlier implementation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Measurability.html#Mathlib.Tactic.measurability">Mathlib.Tactic.Measurability</a></dd></dl></div><div id="Mathlib.Tactic.measurability?"><h2>measurability?</h2><p><p>The tactic <code>measurability?</code> solves goals of the form <code>Measurable f</code>, <code>AEMeasurable f</code>,
<code>StronglyMeasurable f</code>, <code>AEStronglyMeasurable f Œº</code>, or <code>MeasurableSet s</code> by applying lemmas tagged
with the <code><a href="./Mathlib/Tactic/Measurability.html#measurability">measurability</a></code> user attribute, and suggests a faster proof script that can be substituted
for the tactic call in case of success.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Measurability.html#Mathlib.Tactic.measurability?">Mathlib.Tactic.Measurability</a></dd></dl></div><div id="Lean.Parser.Tactic.mexactMacro"><h2>mexact</h2><p><p><code>mexact</code> is like <code>exact</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (Q : SPred œÉs) : Q ‚ä¢‚Çõ Q := by
  mstart
  mintro HQ
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexactMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mexfalsoMacro"><h2>mexfalso</h2><p><p><code>mexfalso</code> is like <code>exfalso</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P : SPred œÉs) : ‚åúFalse‚åù ‚ä¢‚Çõ P := by
  mintro HP
  mexfalso
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexfalsoMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mexistsMacro"><h2>mexists</h2><p><p><code>mexists</code> is like <code>exists</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (œà : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí SPred œÉs) : œà 42 ‚ä¢‚Çõ ‚àÉ x, œà x := by
  mintro H
  mexists 42
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mexistsMacro">Init.Tactics</a></dd></dl></div><div id="Tactic.MfldSetTac.mfldSetTac"><h2>mfld_set_tac</h2><p><p>A very basic tactic to show that sets showing up in manifolds coincide or are included
in one another.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Logic/Equiv/PartialEquiv.html#Tactic.MfldSetTac.mfldSetTac">Mathlib.Logic.Equiv.PartialEquiv</a></dd></dl></div><div id="Lean.Parser.Tactic.mframeMacro"><h2>mframe</h2><p><p><code>mframe</code> infers which hypotheses from the stateful context can be moved into the pure context.
This is useful because pure hypotheses &quot;survive&quot; the next application of modus ponens
(<code>Std.Do.SPred.mp</code>) and transitivity (<code>Std.Do.SPred.entails.trans</code>).</p><p>It is used as part of the <code>mspec</code> tactic.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : ‚ä¢‚Çõ ‚åúp‚åù ‚àß Q ‚àß ‚åúq‚åù ‚àß ‚åúr‚åù ‚àß P ‚àß ‚åús‚åù ‚àß ‚åút‚åù ‚Üí Q := by
  mintro _
  mframe
  /- `h : p ‚àß q ‚àß r ‚àß s ‚àß t` in the pure context -/
  mcases h with hP
  mexact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mframeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mhaveMacro"><h2>mhave</h2><p><p><code>mhave</code> is like <code>have</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ (P ‚Üí Q) ‚Üí Q := by
  mintro HP HPQ
  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mhaveMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mintroMacro"><h2>mintro</h2><p><p>Like <code>intro</code>, but introducing stateful hypotheses into the stateful context of the <code>Std.Do.SPred</code>
proof mode.
That is, given a stateful goal <code>(h·µ¢ : H·µ¢)* ‚ä¢‚Çõ P ‚Üí T</code>, <code>mintro h</code> transforms
into <code>(h·µ¢ : H·µ¢)*, (h : P) ‚ä¢‚Çõ T</code>.</p><p>Furthermore, <code>mintro ‚àÄs</code> is like <code>intro s</code>, but preserves the stateful goal.
That is, <code>mintro ‚àÄs</code> brings the topmost state variable <code>s:œÉ</code> in scope and transforms
<code>(h·µ¢ : H·µ¢)* ‚ä¢‚Çõ T</code> (where the entailment is in <code>Std.Do.SPred (œÉ::œÉs)</code>) into
<code>(h·µ¢ : H·µ¢ s)* ‚ä¢‚Çõ T s</code> (where the entailment is in <code>Std.Do.SPred œÉs</code>).</p><p>Beyond that, <code>mintro</code> supports the full syntax of <code>mcases</code> patterns
(<code>mintro pat = (mintro h; mcases h with pat</code>), and can perform multiple
introductions in sequence.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mintroMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mleaveMacro"><h2>mleave</h2><p><p>Leaves the stateful proof mode of <code>Std.Do.SPred</code>, tries to eta-expand through all definitions
related to the logic of the <code>Std.Do.SPred</code> and gently simplifies the resulting pure Lean
proposition. This is often the right thing to do after <code>mvcgen</code> in order for automation to prove
the goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mleaveMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mleftMacro"><h2>mleft</h2><p><p><code>mleft</code> is like <code>left</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ P ‚à® Q := by
  mintro HP
  mleft
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mleftMacro">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Module.tacticModule"><h2>module</h2><p><p>Given a goal which is an equality in a type <code>M</code> (with <code>M</code> an <code><a href="./Mathlib/Algebra/Group/Defs.html#AddCommMonoid">AddCommMonoid</a></code>), parse the LHS and
RHS of the goal as linear combinations of <code>M</code>-atoms over some commutative semiring <code>R</code>, and prove
the goal by checking that the LHS- and RHS-coefficients of each atom are the same up to
ring-normalization in <code>R</code>.</p><p>(If the proofs of coefficient-wise equality will require more reasoning than just
ring-normalization, use the tactic <code>match_scalars</code> instead, and then prove coefficient-wise equality
by hand.)</p><p>Example uses of the <code>module</code> tactic:</p><pre><code>example [AddCommMonoid M] [CommSemiring R] [Module R M] (a b : R) (x : M) :
    a ‚Ä¢ x + b ‚Ä¢ x = (b + a) ‚Ä¢ x := by
  module

example [AddCommMonoid M] [Field K] [CharZero K] [Module K M] (x : M) :
    (2:K)‚Åª¬π ‚Ä¢ x + (3:K)‚Åª¬π ‚Ä¢ x + (6:K)‚Åª¬π ‚Ä¢ x = x := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a : R) (v w : M) :
    (1 + a ^ 2) ‚Ä¢ (v + w) - a ‚Ä¢ (a ‚Ä¢ v - w) = v + (1 + a + a ^ 2) ‚Ä¢ w := by
  module

example [AddCommGroup M] [CommRing R] [Module R M] (a b Œº ŒΩ : R) (x y : M) :
    (Œº - ŒΩ) ‚Ä¢ a ‚Ä¢ x = (a ‚Ä¢ Œº ‚Ä¢ x + b ‚Ä¢ ŒΩ ‚Ä¢ y) - ŒΩ ‚Ä¢ (a ‚Ä¢ x + b ‚Ä¢ y) := by
  module
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Module.html#Mathlib.Tactic.Module.tacticModule">Mathlib.Tactic.Module</a></dd></dl></div><div id="Mathlib.Tactic.ComputeDegree.monicityMacro"><h2>monicity</h2><p><p><code>monicity</code> tries to solve a goal of the form <code>Monic f</code>.
It converts the goal into a goal of the form <code>natDegree f ‚â§ n</code> and one of the form <code>f.coeff n = 1</code>
and calls <code>compute_degree</code> on those two goals.</p><p>The variant <code>monicity!</code> starts like <code>monicity</code>, but calls <code>compute_degree!</code> on the two side-goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/ComputeDegree.html#Mathlib.Tactic.ComputeDegree.monicityMacro">Mathlib.Tactic.ComputeDegree</a></dd></dl></div><div id="Mathlib.Tactic.Monotonicity.mono"><h2>mono</h2><p><p><code>mono</code> applies monotonicity rules and local hypotheses repetitively.  For example,</p><pre><code class="language-lean">example (x y z k : ‚Ñ§)
    (h : 3 ‚â§ (4 : ‚Ñ§))
    (h' : z ‚â§ y) :
    (k + 3 + x) - y ‚â§ (k + 4 + x) - z := by
  mono
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Monotonicity/Basic.html#Mathlib.Tactic.Monotonicity.mono">Mathlib.Tactic.Monotonicity.Basic</a></dd></dl></div><div id="Lean.Parser.Tactic.mpureMacro"><h2>mpure</h2><p><p><code>mpure</code> moves a pure hypothesis from the stateful context into the pure context.</p><pre><code class="language-lean">example (Q : SPred œÉs) (œà : œÜ ‚Üí ‚ä¢‚Çõ Q): ‚åúœÜ‚åù ‚ä¢‚Çõ Q := by
  mintro HœÜ
  mpure HœÜ
  mexact (œà HœÜ)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mpureMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mpureIntroMacro"><h2>mpure_intro</h2><p><p><code>mpure_intro</code> operates on a stateful <code>Std.Do.SPred</code> goal of the form <code>P ‚ä¢‚Çõ ‚åúœÜ‚åù</code>.
It leaves the stateful proof mode (thereby discarding <code>P</code>), leaving the regular goal <code>œÜ</code>.</p><pre><code class="language-lean">theorem simple : ‚ä¢‚Çõ (‚åúTrue‚åù : SPred œÉs) := by
  mpure_intro
  exact <a href="./Init/Prelude.html#True.intro">True.intro</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mpureIntroMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrefineMacro"><h2>mrefine</h2><p><p>Like <code>refine</code>, but operating on stateful <code>Std.Do.SPred</code> goals.</p><pre><code class="language-lean">example (P Q R : SPred œÉs) : (P ‚àß Q ‚àß R) ‚ä¢‚Çõ P ‚àß R := by
  mintro ‚ü®HP, HQ, HR‚ü©
  mrefine ‚ü®HP, HR‚ü©

example (œà : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí SPred œÉs) : œà 42 ‚ä¢‚Çõ ‚àÉ x, œà x := by
  mintro H
  mrefine ‚ü®‚åú42‚åù, H‚ü©
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrefineMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrenameIMacro"><h2>mrename_i</h2><p><p><code>mrename_i</code> is like <code>rename_i</code>, but names inaccessible stateful hypotheses in a <code>Std.Do.SPred</code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrenameIMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mreplaceMacro"><h2>mreplace</h2><p><p><code>mreplace</code> is like <code>replace</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ (P ‚Üí Q) ‚Üí Q := by
  mintro HP HPQ
  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ
  mexact HPQ
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mreplaceMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrevertMacro"><h2>mrevert</h2><p><p><code>mrevert</code> is like <code>revert</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q R : SPred œÉs) : P ‚àß Q ‚àß R ‚ä¢‚Çõ P ‚Üí R := by
  mintro ‚ü®HP, HQ, HR‚ü©
  mrevert HR
  mrevert HP
  mintro HP'
  mintro HR'
  mexact HR'
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrevertMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mrightMacro"><h2>mright</h2><p><p><code>mright</code> is like <code>right</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ Q ‚à® P := by
  mintro HP
  mright
  mexact HP
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mrightMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecMacro"><h2>mspec</h2><p><p><code>mspec</code> is an <code>apply</code>-like tactic that applies a Hoare triple specification to the target of the
stateful goal.</p><p>Given a stateful goal <code>H ‚ä¢‚Çõ wp‚ü¶prog‚üß Q'</code>, <code>mspec foo_spec</code> will instantiate
<code>foo_spec : ... ‚Üí ‚¶ÉP‚¶Ñ foo ‚¶ÉQ‚¶Ñ</code>, match <code>foo</code> against <code>prog</code> and produce subgoals for
the verification conditions <code>?pre : H ‚ä¢‚Çõ P</code> and <code>?post : Q ‚ä¢‚Çö Q'</code>.</p><ul><li>If <code>prog = x &gt;&gt;= f</code>, then <code>mspec Specs.bind</code> is tried first so that <code>foo</code> is matched against <code>x</code>
instead. Tactic <code>mspec_no_bind</code> does not attempt to do this decomposition.</li><li>If <code>?pre</code> or <code>?post</code> follow by <code>.<a href="./Init/Prelude.html#rfl">rfl</a></code>, then they are discharged automatically.</li><li><code>?post</code> is automatically simplified into constituent <code>‚ä¢‚Çõ</code> entailments on
success and failure continuations.</li><li><code>?pre</code> and <code>?post.*</code> goals introduce their stateful hypothesis under an inaccessible name.
You can give it a name with the <code>mrename_i</code> tactic.</li><li>Any uninstantiated MVar arising from instantiation of <code>foo_spec</code> becomes a new subgoal.</li><li>If the target of the stateful goal looks like <code>fun s =&gt; _</code> then <code>mspec</code> will first <code>mintro ‚àÄs</code>.</li><li>If <code>P</code> has schematic variables that can be instantiated by doing <code>mintro ‚àÄs</code>, for example
<code>foo_spec : ‚àÄ(n:Nat), ‚¶Éfun s =&gt; ‚åún = s‚åù‚¶Ñ foo ‚¶ÉQ‚¶Ñ</code>, then <code>mspec</code> will do <code>mintro ‚àÄs</code> first to
instantiate <code>n = s</code>.</li><li>Right before applying the spec, the <code>mframe</code> tactic is used, which has the following effect:
Any hypothesis <code>H·µ¢</code> in the goal <code>h‚ÇÅ:H‚ÇÅ, h‚ÇÇ:H‚ÇÇ, ..., h‚Çô:H‚Çô ‚ä¢‚Çõ T</code> that is
pure (i.e., equivalent to some <code>‚åúœÜ·µ¢‚åù</code>) will be moved into the pure context as <code>h·µ¢:œÜ·µ¢</code>.</li></ul><p>Additionally, <code>mspec</code> can be used without arguments or with a term argument:</p><ul><li><code>mspec</code> without argument will try and look up a spec for <code>x</code> registered with <code>@[spec]</code>.</li><li><code>mspec (foo_spec blah ?bleh)</code> will elaborate its argument as a term with expected type
<code>‚¶É?P‚¶Ñ x ‚¶É?Q‚¶Ñ</code> and introduce <code>?bleh</code> as a subgoal.
This is useful to pass an invariant to e.g., <code>Specs.forIn_list</code> and leave the inductive step
as a hole.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecNoBind"><h2>mspec_no_bind</h2><p><p><code>mspec_no_simp $spec</code> first tries to decompose <code><a href="./Init/Prelude.html#Bind.bind">Bind.bind</a></code>s before applying <code>$spec</code>.
This variant of <code>mspec_no_simp</code> does not; <code>mspec_no_bind $spec</code> is defined as</p><pre><code>try with_reducible mspec_no_bind <a href="./Std/Do/Triple/SpecLemmas.html#Std.Do.Spec.bind">Std.Do.Spec.bind</a>
mspec_no_bind $spec
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecNoSimp"><h2>mspec_no_simp</h2><p><p>Like <code>mspec</code>, but does not attempt slight simplification and closing of trivial sub-goals.
<code>mspec $spec</code> is roughly (the set of simp lemmas below might not be up to date)</p><pre><code>mspec_no_simp $spec
all_goals
  ((try simp only [SPred.true_intro_simp, SPred.apply_pure]);
   (try mpure_intro; trivial))
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecializeMacro"><h2>mspecialize</h2><p><p><code>mspecialize</code> is like <code>specialize</code>, but operating on a stateful <code>Std.Do.SPred</code> goal.
It specializes a hypothesis from the stateful context with hypotheses from either the pure
or stateful context or pure terms.</p><pre><code class="language-lean">example (P Q : SPred œÉs) : P ‚ä¢‚Çõ (P ‚Üí Q) ‚Üí Q := by
  mintro HP HPQ
  mspecialize HPQ HP
  mexact HPQ

example (y : Nat) (P Q : SPred œÉs) (Œ® : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí SPred œÉs) (hP : ‚ä¢‚Çõ P) : ‚ä¢‚Çõ Q ‚Üí (‚àÄ x, P ‚Üí Q ‚Üí Œ® x) ‚Üí Œ® (y + 1) := by
  mintro HQ HŒ®
  mspecialize HŒ® (y + 1) hP HQ
  mexact HŒ®
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecializeMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mspecializePureMacro"><h2>mspecialize_pure</h2><p><p><code>mspecialize_pure</code> is like <code>mspecialize</code>, but it specializes a hypothesis from the
<em>pure</em> context with hypotheses from either the pure or stateful context or pure terms.</p><pre><code class="language-lean">example (y : Nat) (P Q : SPred œÉs) (Œ® : <a href="./Init/Prelude.html#Nat">Nat</a> ‚Üí SPred œÉs) (hP : ‚ä¢‚Çõ P) (hŒ® : ‚àÄ x, ‚ä¢‚Çõ P ‚Üí Q ‚Üí Œ® x) : ‚ä¢‚Çõ Q ‚Üí Œ® (y + 1) := by
  mintro HQ
  mspecialize_pure (hŒ® (y + 1)) hP HQ =&gt; HŒ®
  mexact HŒ®
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mspecializePureMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mstartMacro"><h2>mstart</h2><p><p>Start the stateful proof mode of <code>Std.Do.SPred</code>.
This will transform a stateful goal of the form <code>H ‚ä¢‚Çõ T</code> into <code>‚ä¢‚Çõ H ‚Üí T</code>
upon which <code>mintro</code> can be used to re-introduce <code>H</code> and give it a name.
It is often more convenient to use <code>mintro</code> directly, which will
try <code>mstart</code> automatically if necessary.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mstartMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mstopMacro"><h2>mstop</h2><p><p>Stops the stateful proof mode of <code>Std.Do.SPred</code>.
This will simply forget all the names given to stateful hypotheses and pretty-print
a bit differently.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mstopMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mvcgenMacro"><h2>mvcgen</h2><p><p><code>mvcgen</code> will break down a Hoare triple proof goal like <code>‚¶ÉP‚¶Ñ prog ‚¶ÉQ‚¶Ñ</code> into verification conditions,
provided that all functions used in <code>prog</code> have specifications registered with <code>@[spec]</code>.</p><h3 id="Verification-Conditions-and-specifications" class="markdown-heading">Verification Conditions and specifications <a class="hover-link" href="#Verification-Conditions-and-specifications">#</a></h3><p>A verification condition is an entailment in the stateful logic of <code>Std.Do.SPred</code>
in which the original program <code>prog</code> no longer occurs.
Verification conditions are introduced by the <code>mspec</code> tactic; see the <code>mspec</code> tactic for what they
look like.
When there's no applicable <code>mspec</code> spec, <code>mvcgen</code> will try and rewrite an application
<code>prog = f a b c</code> with the simp set registered via <code>@[spec]</code>.</p><h3 id="Features" class="markdown-heading">Features <a class="hover-link" href="#Features">#</a></h3><p>When used like <code>mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]</code>, <code>mvcgen</code> will additionally</p><ul><li>add a Hoare triple specification <code>foo_spec : ... ‚Üí ‚¶ÉP‚¶Ñ foo ... ‚¶ÉQ‚¶Ñ</code> to <code>spec</code> set for a
function <code>foo</code> occurring in <code>prog</code>,</li><li>unfold a definition <code>def bar_def ... := ...</code> in <code>prog</code>,</li><li>unfold any method of the <code><a href="./Init/Data/Float.html#instBEqFloat">instBEqFloat</a> : <a href="./Init/Prelude.html#BEq">BEq</a> <a href="./Init/Data/Float.html#Float">Float</a></code> instance in <code>prog</code>.</li><li>it will no longer substitute away <code>let</code>-expressions that occur at most once in <code>P</code>, <code>Q</code> or <code>prog</code>.</li></ul><h3 id="Config-options" class="markdown-heading">Config options <a class="hover-link" href="#Config-options">#</a></h3><p><code>+noLetElim</code> is just one config option of many. Check out <code>Lean.Elab.Tactic.Do.VCGen.Config</code> for all
options. Of particular note is <code>stepLimit = some 42</code>, which is useful for bisecting bugs in
<code>mvcgen</code> and tracing its execution.</p><h3 id="Extended-syntax" class="markdown-heading">Extended syntax <a class="hover-link" href="#Extended-syntax">#</a></h3><p>Often, <code>mvcgen</code> will be used like this:</p><pre><code>mvcgen [...]
case inv1 =&gt; by exact I1
case inv2 =&gt; by exact I2
all_goals (mleave; try grind)
</code></pre><p>There is special syntax for this:</p><pre><code>mvcgen [...] invariants
¬∑ I1
¬∑ I2
with grind
</code></pre><p>When <code>I1</code> and <code>I2</code> need to refer to inaccessibles (<code>mvcgen</code> will introduce a lot of them for program
variables), you can use case label syntax:</p><pre><code>mvcgen [...] invariants
| inv1 _ acc _ =&gt; I1 acc
| _ =&gt; I2
with grind
</code></pre><p>This is more convenient than the equivalent <code>¬∑ by rename_i _ acc _; exact I1 acc</code>.</p><h3 id="Invariant-suggestions" class="markdown-heading">Invariant suggestions <a class="hover-link" href="#Invariant-suggestions">#</a></h3><p><code>mvcgen</code> will suggest invariants for you if you use the <code>invariants?</code> keyword.</p><pre><code>mvcgen [...] invariants?
</code></pre><p>This is useful if you do not recall the exact syntax to construct invariants.
Furthermore, it will suggest a concrete invariant encoding &quot;this holds at the start of the loop and
this must hold at the end of the loop&quot; by looking at the corresponding VCs.
Although the suggested invariant is a good starting point, it is too strong and requires users to
interpolate it such that the inductive step can be proved. Example:</p><pre><code>def mySum (l : <a href="./Init/Prelude.html#List">List</a> Nat) : <a href="./Init/Prelude.html#Nat">Nat</a> := <a href="./Init/Control/Id.html#Id.run">Id.run</a> do
  let mut acc := 0
  for x in l do
    acc := acc + x
  return acc

/--
info: Try this:
  invariants
    ¬∑ ‚áì‚ü®xs, letMuts‚ü© =&gt; ‚åúxs.prefix = [] ‚àß letMuts = 0 ‚à® xs.suffix = [] ‚àß letMuts = l.sum‚åù
-/
#guard_msgs (info) in
theorem mySum_suggest_invariant (l : <a href="./Init/Prelude.html#List">List</a> Nat) : mySum l = l.sum := by
  generalize h : mySum l = r
  apply Id.of_wp_run_eq h
  mvcgen invariants?
  all_goals admit
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.mvcgenMacro">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.mvcgenHint"><h2>mvcgen?</h2><p><p>A hint tactic that expands to <code>mvcgen invariants?</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenHint">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticMvcgen_trivial"><h2>mvcgen_trivial</h2><p><p><code>mvcgen_trivial</code> is the tactic automatically called by <code>mvcgen</code> to discharge VCs.
It tries to discharge the VC by applying <code>(try mpure_intro); <a href="./Init/Core.html#trivial">trivial</a></code> and otherwise delegates to
<code>mvcgen_trivial_extensible</code>.
Users are encouraged to extend <code>mvcgen_trivial_extensible</code> instead of this tactic in order not to
override the default <code>(try mpure_intro); <a href="./Init/Core.html#trivial">trivial</a></code> behavior.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticMvcgen_trivial_extensible"><h2>mvcgen_trivial_extensible</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.tacticMvcgen_trivial_extensible">Std.Tactic.Do.Syntax</a></dd></dl></div><div id="Lean.Parser.Tactic.nativeDecide"><h2>native_decide</h2><p><p><code>native_decide</code> is a synonym for <code>decide +native</code>.
It will attempt to prove a goal of type <code>p</code> by synthesizing an instance
of <code><a href="./Init/Prelude.html#Decidable">Decidable</a> p</code> and then evaluating it to <code>isTrue ..</code>. Unlike <code>decide</code>, this
uses <code>#eval</code> to evaluate the decidability instance.</p><p>This should be used with care because it adds the entire lean compiler to the trusted
part, and the axiom <code><a href="./Init/Core.html#Lean.ofReduceBool">Lean.ofReduceBool</a></code> will show up in <code>#print axioms</code> for theorems using
this method or anything that transitively depends on them. Nevertheless, because it is
compiled, this can be significantly more efficient than using <code>decide</code>, and for very
large computations this is one way to run external programs and trust the result.</p><pre><code class="language-lean">example : (List.range 1000).length = 1000 := by native_decide
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.nativeDecide">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.¬´tacticNext_=&gt;_¬ª"><h2>next</h2><p><p><code>next =&gt; tac</code> focuses on the next goal and solves it using <code>tac</code>, or else fails.
<code>next x‚ÇÅ ... x‚Çô =&gt; tac</code> additionally renames the <code>n</code> most recent hypotheses with
inaccessible names to the given names.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.¬´tacticNext_=&gt;_¬ª">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.nlinarith"><h2>nlinarith</h2><p><p>An extension of <code>linarith</code> with some preprocessing to allow it to solve some nonlinear arithmetic
problems. (Based on Coq's <code>nra</code> tactic.) See <code>linarith</code> for the available syntax of options,
which are inherited by <code>nlinarith</code>; that is, <code>nlinarith!</code> and <code>nlinarith only [h1, h2]</code> all work as
in <code>linarith</code>. The preprocessing is as follows:</p><ul><li>For every subterm <code>a ^ 2</code> or <code>a * a</code> in a hypothesis or the goal,
the assumption <code>0 ‚â§ a ^ 2</code> or <code>0 ‚â§ a * a</code> is added to the context.</li><li>For every pair of hypotheses <code>a1 R1 b1</code>, <code>a2 R2 b2</code> in the context, <code>R1, R2 ‚àà {&lt;, ‚â§, =}</code>,
the assumption <code>0 R' (b1 - a1) * (b2 - a2)</code> is added to the context (non-recursively),
where <code>R ‚àà {&lt;, ‚â§, =}</code> is the appropriate comparison derived from <code>R1, R2</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Linarith/Frontend.html#Mathlib.Tactic.nlinarith">Mathlib.Tactic.Linarith.Frontend</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticNofun"><h2>nofun</h2><p><p>The tactic <code>nofun</code> is shorthand for <code>exact nofun</code>: it introduces the assumptions, then performs an
empty pattern match, closing the goal if the introduced pattern is impossible.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticNofun">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.¬´tacticNomatch_,,¬ª"><h2>nomatch</h2><p><p>The tactic <code>nomatch h</code> is shorthand for <code>exact nomatch h</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.¬´tacticNomatch_,,¬ª">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.NoncommRing.noncomm_ring"><h2>noncomm_ring</h2><p><p>A tactic for simplifying identities in not-necessarily-commutative rings.</p><p>An example:</p><pre><code class="language-lean">example {R : Type*} [Ring R] (a b c : R) : a * (b + c + c - b) = 2 * a * c := by
  noncomm_ring
</code></pre><p>You can use <code>noncomm_ring [h]</code> to also simplify using <code>h</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NoncommRing.html#Mathlib.Tactic.NoncommRing.noncomm_ring">Mathlib.Tactic.NoncommRing</a></dd></dl></div><div id="Mathlib.Tactic.Nontriviality.nontriviality"><h2>nontriviality</h2><p><p>Attempts to generate a <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code> hypothesis.</p><p>The tactic first checks to see that there is not already a <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code> instance
before trying to synthesize one using other techniques.</p><p>If the goal is an (in)equality, the type <code>Œ±</code> is inferred from the goal.
Otherwise, the type needs to be specified in the tactic invocation, as <code>nontriviality Œ±</code>.</p><p>The <code>nontriviality</code> tactic will first look for strict inequalities amongst the hypotheses,
and use these to derive the <code><a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a></code> instance directly.</p><p>Otherwise, it will perform a case split on <code><a href="./Init/Core.html#Subsingleton">Subsingleton</a> Œ± ‚à® <a href="./Mathlib/Logic/Nontrivial/Defs.html#Nontrivial">Nontrivial</a> Œ±</code>, and attempt to discharge
the <code><a href="./Init/Core.html#Subsingleton">Subsingleton</a></code> goal using <code>simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô, nontriviality]</code>, where <code>[h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]</code> is
a list of additional <code>simp</code> lemmas that can be passed to <code>nontriviality</code> using the syntax
<code>nontriviality Œ± using h‚ÇÅ, h‚ÇÇ, ..., h‚Çô</code>.</p><pre><code>example {R : Type} [OrderedRing R] {a : R} (h : 0 &lt; a) : 0 &lt; a := by
  nontriviality -- There is now a `Nontrivial R` hypothesis available.
  assumption
</code></pre><pre><code>example {R : Type} [CommRing R] {r s : R} : r * s = s * r := by
  nontriviality -- There is now a `Nontrivial R` hypothesis available.
  apply mul_comm
</code></pre><pre><code>example {R : Type} [OrderedRing R] {a : R} (h : 0 &lt; a) : (2 : ‚Ñï) ‚à£ 4 := by
  nontriviality R -- there is now a `Nontrivial R` hypothesis available.
  dec_trivial
</code></pre><pre><code>def myeq {Œ± : Type} (a b : Œ±) : Prop := a = b

example {Œ± : Type} (a b : Œ±) (h : a = b) : myeq a b := by
  success_if_fail nontriviality Œ± -- Fails
  nontriviality Œ± using myeq -- There is now a `Nontrivial Œ±` hypothesis available
  assumption
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Nontriviality/Core.html#Mathlib.Tactic.Nontriviality.nontriviality">Mathlib.Tactic.Nontriviality.Core</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticNorm_cast__"><h2>norm_cast</h2><p><p>The <code>norm_cast</code> family of tactics is used to normalize certain coercions (<em>casts</em>) in expressions.</p><ul><li><code>norm_cast</code> normalizes casts in the target.</li><li><code>norm_cast at h</code> normalizes casts in hypothesis <code>h</code>.</li></ul><p>The tactic is basically a version of <code>simp</code> with a specific set of lemmas to move casts
upwards in the expression.
Therefore even in situations where non-terminal <code>simp</code> calls are discouraged (because of fragility),
<code>norm_cast</code> is considered to be safe.
It also has special handling of numerals.</p><p>For instance, given an assumption</p><pre><code class="language-lean">a b : ‚Ñ§
h : ‚Üëa + ‚Üëb &lt; (10 : ‚Ñö)
</code></pre><p>writing <code>norm_cast at h</code> will turn <code>h</code> into</p><pre><code class="language-lean">h : a + b &lt; 10
</code></pre><p>There are also variants of basic tactics that use <code>norm_cast</code> to normalize expressions during
their operation, to make them more flexible about the expressions they accept
(we say that it is a tactic <em>modulo</em> the effects of <code>norm_cast</code>):</p><ul><li><code>exact_mod_cast</code> for <code>exact</code> and <code>apply_mod_cast</code> for <code>apply</code>.
Writing <code>exact_mod_cast h</code> and <code>apply_mod_cast h</code> will normalize casts
in the goal and <code>h</code> before using <code>exact h</code> or <code>apply h</code>.</li><li><code>rw_mod_cast</code> for <code>rw</code>. It applies <code>norm_cast</code> between rewrites.</li><li><code>assumption_mod_cast</code> for <code>assumption</code>.
This is effectively <code>norm_cast at *; assumption</code>, but more efficient.
It normalizes casts in the goal and, for every hypothesis <code>h</code> in the context,
it will try to normalize casts in <code>h</code> and use <code>exact h</code>.</li></ul><p>See also <code>push_cast</code>, which moves casts inwards rather than lifting them outwards.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticNorm_cast__">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.normCast0"><h2>norm_cast0</h2><p><p>Implementation of <code>norm_cast</code> (the full <code>norm_cast</code> calls <code><a href="./Init/Core.html#trivial">trivial</a></code> afterwards).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.normCast0">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.normNum"><h2>norm_num</h2><p><p><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> normalizes numerical expressions in the goal. By default, it supports the operations
<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>‚Åª¬π</code> <code>^</code> and <code>%</code> over types with (at least) an <code><a href="./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne">AddMonoidWithOne</a></code> instance, such as
<code>‚Ñï</code>, <code>‚Ñ§</code>, <code>‚Ñö</code>, <code>‚Ñù</code>, <code>‚ÑÇ</code>. In addition to evaluating numerical expressions, <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> will use <code>simp</code>
to simplify the goal. If the goal has the form <code>A = B</code>, <code>A ‚â† B</code>, <code>A &lt; B</code> or <code>A ‚â§ B</code>, where <code>A</code> and
<code>B</code> are numerical expressions, <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> will try to close it. It also has a relatively simple
primality prover.</p><p>This tactic is extensible. Extensions can allow <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> to evaluate more kinds of expressions, or
to prove more kinds of propositions. See the <code>@[norm_num]</code> attribute for further information on
extending <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.</p><ul><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> at l</code> normalizes at location(s) <code>l</code>.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> [h1, ...]</code> adds the arguments <code>h1, ...</code> to the <code>simp</code> set in addition to the default
<code>simp</code> set. All options for <code>simp</code> arguments are supported, in particular <code>‚Üê</code>, <code>‚Üë</code> and <code>‚Üì</code>.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only</code> does not use the default <code>simp</code> set for simplification. <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only [h1, ...]</code>
uses only the arguments <code>h1, ...</code> in addition to the routines tagged <code>@[norm_num]</code>.
<code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> only</code> still performs post-processing steps, like <code>simp only</code>, use <code>norm_num1</code> if you
exclusively want to normalize numerical expressions.</li><li><code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a> (config := cfg)</code> uses <code>cfg</code> as configuration for <code>simp</code> calls (see the <code>simp</code> tactic for
further details).</li></ul><p>Examples:</p><pre><code class="language-lean">example : 43 ‚â§ 74 + (33 : ‚Ñ§) := by <a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a>
example : ¬¨ (7-2)/(2*3) ‚â• (1:‚Ñù) + 2/(3^2) := by <a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a>
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum">Mathlib.Tactic.NormNum.Core</a></dd></dl></div><div id="Mathlib.Tactic.normNum1"><h2>norm_num1</h2><p><p><code>norm_num1</code> normalizes numerical expressions in the goal. It is a basic version of <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>
that does not call <code>simp</code>.</p><p>By default, it supports the operations <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>‚Åª¬π</code> <code>^</code> and <code>%</code> over types with (at least)
an <code><a href="./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne">AddMonoidWithOne</a></code> instance, such as <code>‚Ñï</code>, <code>‚Ñ§</code>, <code>‚Ñö</code>, <code>‚Ñù</code>, <code>‚ÑÇ</code>. If the goal has the form <code>A = B</code>,
<code>A ‚â† B</code>, <code>A &lt; B</code> or <code>A ‚â§ B</code>, where <code>A</code> and <code>B</code> are numerical expressions, <code>norm_num1</code> will try to
close it. It also has a relatively simple primality prover.
:e
This tactic is extensible. Extensions can allow <code>norm_num1</code> to evaluate more kinds of expressions,
or to prove more kinds of propositions. See the <code>@[norm_num]</code> attribute for further information on
extending <code>norm_num1</code>.</p><ul><li><code>norm_num1 at l</code> normalizes at location(s) <code>l</code>.</li></ul><p>Examples:</p><pre><code class="language-lean">example : 43 ‚â§ 74 + (33 : ‚Ñ§) := by norm_num1
example : ¬¨ (7-2)/(2*3) ‚â• (1:‚Ñù) + 2/(3^2) := by norm_num1
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NormNum/Core.html#Mathlib.Tactic.normNum1">Mathlib.Tactic.NormNum.Core</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_grewrite_____"><h2>nth_grewrite</h2><p><p><code>nth_grewrite</code> is just like <code>nth_rewrite</code>, but for <code>grewrite</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticNth_grewrite_____">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_grw_____"><h2>nth_grw</h2><p><p><code>nth_grw</code> is just like <code>nth_rw</code>, but for <code>grw</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GRewrite/Elab.html#Mathlib.Tactic.tacticNth_grw_____">Mathlib.Tactic.GRewrite.Elab</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_rewrite_____"><h2>nth_rewrite</h2><p><p><code>nth_rewrite</code> is a variant of <code>rewrite</code> that only changes the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of
the expression to be rewritten. <code>nth_rewrite n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]</code> will rewrite the
<code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of each of the <code>m</code> equalities <code>eq·µ¢</code>in that order. Occurrences are
counted beginning with <code>1</code> in order of precedence.</p><p>For example,</p><pre><code class="language-lean">example (h : a = 1) : a + a + a + a + a = 5 := by
  nth_rewrite 2 3 [h]
/-
a: ‚Ñï
h: a = 1
‚ä¢ a + 1 + 1 + a + a = 5
-/
</code></pre><p>Notice that the second and third occurrences of <code>a</code> from the left have been rewritten by
<code>nth_rewrite</code>.</p><p>To understand the importance of order of precedence, consider the example below</p><pre><code class="language-lean">example (a b c : Nat) : (a + b) + c = (b + a) + c := by
  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c
</code></pre><p>Here, although the occurrence parameter is <code>2</code>, <code>(a + b)</code> is rewritten to <code>(b + a)</code>. This happens
because in order of precedence, the first occurrence of <code>_ + _</code> is the one that adds <code>a + b</code> to <code>c</code>.
The occurrence in <code>a + b</code> counts as the second occurrence.</p><p>If a term <code>t</code> is introduced by rewriting with <code>eq·µ¢</code>, then this instance of <code>t</code> will be counted as an
<em>occurrence</em> of <code>t</code> for all subsequent rewrites of <code>t</code> with <code>eq‚±º</code> for <code>j &gt; i</code>. This behaviour is
illustrated by the example below</p><pre><code class="language-lean">example (h : a = a + b) : a + a + a + a + a = 0 := by
  nth_rewrite 3 [h, h]
/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b + b) + a + a = 0
-/
</code></pre><p>Here, the first <code>nth_rewrite</code> with <code>h</code> introduces an additional occurrence of <code>a</code> in the goal.
That is, the goal state after the first rewrite looks like below</p><pre><code class="language-lean">/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b) + a + a = 0
-/
</code></pre><p>This new instance of <code>a</code> also turns out to be the third <em>occurrence</em> of <code>a</code>.  Therefore,
the next <code>nth_rewrite</code> with <code>h</code> rewrites this <code>a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NthRewrite.html#Mathlib.Tactic.tacticNth_rewrite_____">Mathlib.Tactic.NthRewrite</a></dd></dl></div><div id="Mathlib.Tactic.tacticNth_rw_____"><h2>nth_rw</h2><p><p><code>nth_rw</code> is a variant of <code>rw</code> that only changes the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of the expression
to be rewritten. Like <code>rw</code>, and unlike <code>nth_rewrite</code>, it will try to close the goal by trying <code><a href="./Init/Prelude.html#rfl">rfl</a></code>
afterwards. <code>nth_rw n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]</code> will rewrite the <code>n‚ÇÅ, ..., n‚Çñ</code>·µó ∞ <em>occurrence</em> of
each of the <code>m</code> equalities <code>eq·µ¢</code>in that order. Occurrences are counted beginning with <code>1</code> in
order of precedence. For example,</p><pre><code class="language-lean">example (h : a = 1) : a + a + a + a + a = 5 := by
  nth_rw 2 3 [h]
/-
a: ‚Ñï
h: a = 1
‚ä¢ a + 1 + 1 + a + a = 5
-/
</code></pre><p>Notice that the second and third occurrences of <code>a</code> from the left have been rewritten by
<code>nth_rw</code>.</p><p>To understand the importance of order of precedence, consider the example below</p><pre><code class="language-lean">example (a b c : Nat) : (a + b) + c = (b + a) + c := by
  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c
</code></pre><p>Here, although the occurrence parameter is <code>2</code>, <code>(a + b)</code> is rewritten to <code>(b + a)</code>. This happens
because in order of precedence, the first occurrence of <code>_ + _</code> is the one that adds <code>a + b</code> to <code>c</code>.
The occurrence in <code>a + b</code> counts as the second occurrence.</p><p>If a term <code>t</code> is introduced by rewriting with <code>eq·µ¢</code>, then this instance of <code>t</code> will be counted as an
<em>occurrence</em> of <code>t</code> for all subsequent rewrites of <code>t</code> with <code>eq‚±º</code> for <code>j &gt; i</code>. This behaviour is
illustrated by the example below</p><pre><code class="language-lean">example (h : a = a + b) : a + a + a + a + a = 0 := by
  nth_rw 3 [h, h]
/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b + b) + a + a = 0
-/
</code></pre><p>Here, the first <code>nth_rw</code> with <code>h</code> introduces an additional occurrence of <code>a</code> in the goal. That is,
the goal state after the first rewrite looks like below</p><pre><code class="language-lean">/-
a b: ‚Ñï
h: a = a + b
‚ä¢ a + a + (a + b) + a + a = 0
-/
</code></pre><p>This new instance of <code>a</code> also turns out to be the third <em>occurrence</em> of <code>a</code>.  Therefore,
the next <code>nth_rw</code> with <code>h</code> rewrites this <code>a</code>.</p><p>Further, <code>nth_rw</code> will close the remaining goal with <code><a href="./Init/Prelude.html#rfl">rfl</a></code> if possible.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/NthRewrite.html#Mathlib.Tactic.tacticNth_rw_____">Mathlib.Tactic.NthRewrite</a></dd></dl></div><div id="Mathlib.Tactic.LibrarySearch.observe"><h2>observe</h2><p><p><code>observe hp : p</code> asserts the proposition <code>p</code> as a hypothesis named <code>hp</code>, and tries to prove it
using <code>exact?</code>.
If no proof is found, the tactic fails.
In other words, this tactic is equivalent to <code>have hp : p := by exact?</code>.</p><ul><li><code>observe : p</code> uses the name <code>this</code> for the new hypothesis.</li><li><code>observe? hp : p</code> will emit a trace message of the form <code>have hp : p := proof_term</code>.
This may be particularly useful to speed up proofs.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Observe.html#Mathlib.Tactic.LibrarySearch.observe">Mathlib.Tactic.Observe</a></dd></dl></div><div id="Lean.Parser.Tactic.obtain"><h2>obtain</h2><p><p>The <code>obtain</code> tactic is a combination of <code>have</code> and <code>rcases</code>. See <code>rcases</code> for
a description of supported patterns.</p><pre><code class="language-lean">obtain ‚ü®patt‚ü© : type := proof
</code></pre><p>is equivalent to</p><pre><code class="language-lean">have h : type := proof
rcases h with ‚ü®patt‚ü©
</code></pre><p>If <code>‚ü®patt‚ü©</code> is omitted, <code>rcases</code> will try to infer the pattern.</p><p>If <code>type</code> is omitted, <code>:= proof</code> is required.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.obtain">Init.RCases</a></dd></dl></div><div id="Lean.Parser.Tactic.omega"><h2>omega</h2><p><p>The <code>omega</code> tactic, for resolving integer and natural linear arithmetic problems.</p><p>It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),
but should be effective on many problems.</p><p>We handle hypotheses of the form <code>x = y</code>, <code>x &lt; y</code>, <code>x ‚â§ y</code>, and <code>k ‚à£ x</code> for <code>x y</code> in <code><a href="./Init/Prelude.html#Nat">Nat</a></code> or <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>
(and <code>k</code> a literal), along with negations of these statements.</p><p>We decompose the sides of the inequalities as linear combinations of atoms.</p><p>If we encounter <code>x / k</code> or <code>x % k</code> for literal integers <code>k</code> we introduce new auxiliary variables
and the relevant inequalities.</p><p>On the first pass, we do not perform case splits on natural subtraction.
If <code>omega</code> fails, we recursively perform a case split on
a natural subtraction appearing in a hypothesis, and try again.</p><p>The options</p><pre><code>omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax
</code></pre><p>can be used to:</p><ul><li><code>splitDisjunctions</code>: split any disjunctions found in the context,
if the problem is not otherwise solvable.</li><li><code>splitNatSub</code>: for each appearance of <code>((a - b : Nat) : Int)</code>, split on <code>a ‚â§ b</code> if necessary.</li><li><code>splitNatAbs</code>: for each appearance of <code><a href="./Init/Data/Int/Basic.html#Int.natAbs">Int.natAbs</a> a</code>, split on <code>0 ‚â§ a</code> if necessary.</li><li><code>splitMinMax</code>: for each occurrence of <code>min a b</code>, split on <code>min a b = a ‚à® min a b = b</code>
Currently, all of these are on by default.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.omega">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.¬´tacticOn_goal-_=&gt;_¬ª"><h2>on_goal</h2><p><p><code>on_goal n =&gt; tacSeq</code> creates a block scope for the <code>n</code>-th goal and tries the sequence
of tactics <code>tacSeq</code> on it.</p><p><code>on_goal -n =&gt; tacSeq</code> does the same, but the <code>n</code>-th goal is chosen by counting from the
bottom.</p><p>The goal is not required to be solved and any resulting subgoals are inserted back into the
list of goals, replacing the chosen goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.¬´tacticOn_goal-_=&gt;_¬ª">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Lean.Parser.Tactic.open"><h2>open</h2><p><p><code>open Foo in tacs</code> (the tactic) acts like <code>open Foo</code> at command level,
but it opens a namespace only within the tactics <code>tacs</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Command.html#Lean.Parser.Tactic.open">Lean.Parser.Command</a></dd></dl></div><div id="Mathlib.Tactic.Order.tacticOrder_"><h2>order</h2><p><p>A finishing tactic for solving goals in arbitrary <code><a href="./Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a></code>, <code><a href="./Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a></code>,
or <code><a href="./Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a></code>. Supports <code>‚ä§</code>, <code>‚ä•</code>, and lattice operations.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder_">Mathlib.Tactic.Order</a></dd></dl></div><div id="Mathlib.Tactic.Order.order_core"><h2>order_core</h2><p><p><code>order_core</code> is the part of the <code>order</code> tactic that tries to find a contradiction.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.order_core">Mathlib.Tactic.Order</a></dd></dl></div><div id="Mathlib.Tactic.Peel.peel"><h2>peel</h2><p><p>Peels matching quantifiers off of a given term and the goal and introduces the relevant variables.</p><ul><li><code>peel e</code> peels all quantifiers (at reducible transparency),
using <code>this</code> for the name of the peeled hypothesis.</li><li><code>peel e with h</code> is <code>peel e</code> but names the peeled hypothesis <code>h</code>.
If <code>h</code> is <code>_</code> then uses <code>this</code> for the name of the peeled hypothesis.</li><li><code>peel n e</code> peels <code>n</code> quantifiers (at default transparency).</li><li><code>peel n e with x y z ... h</code> peels <code>n</code> quantifiers, names the peeled hypothesis <code>h</code>,
and uses <code>x</code>, <code>y</code>, <code>z</code>, and so on to name the introduced variables; these names may be <code>_</code>.
If <code>h</code> is <code>_</code> then uses <code>this</code> for the name of the peeled hypothesis.
The length of the list of variables does not need to equal <code>n</code>.</li><li><code>peel e with x‚ÇÅ ... x‚Çô h</code> is <code>peel n e with x‚ÇÅ ... x‚Çô h</code>.</li></ul><p>There are also variants that apply to an iff in the goal:</p><ul><li><code>peel n</code> peels <code>n</code> quantifiers in an iff.</li><li><code>peel with x‚ÇÅ ... x‚Çô</code> peels <code>n</code> quantifiers in an iff and names them.</li></ul><p>Given <code>p q : ‚Ñï ‚Üí Prop</code>, <code>h : ‚àÄ x, p x</code>, and a goal <code>‚ä¢ : ‚àÄ x, q x</code>, the tactic <code>peel h with x h'</code>
will introduce <code>x : ‚Ñï</code>, <code>h' : p x</code> into the context and the new goal will be <code>‚ä¢ q x</code>. This works
with <code>‚àÉ</code>, as well as <code>‚àÄ·∂†</code> and <code>‚àÉ·∂†</code>, and it can even be applied to a sequence of quantifiers. Note
that this is a logically weaker setup, so using this tactic is not always feasible.</p><p>For a more complex example, given a hypothesis and a goal:</p><pre><code>h : ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) &lt; Œµ
‚ä¢ ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) ‚â§ Œµ
</code></pre><p>(which differ only in <code>&lt;</code>/<code>‚â§</code>), applying <code>peel h with Œµ hŒµ N n hn h_peel</code> will yield a tactic state:</p><pre><code>h : ‚àÄ Œµ &gt; (0 : ‚Ñù), ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, 1 / (n + 1 : ‚Ñù) &lt; Œµ
Œµ : ‚Ñù
hŒµ : 0 &lt; Œµ
N n : ‚Ñï
hn : N ‚â§ n
h_peel : 1 / (n + 1 : ‚Ñù) &lt; Œµ
‚ä¢ 1 / (n + 1 : ‚Ñù) ‚â§ Œµ
</code></pre><p>and the goal can be closed with <code>exact h_peel.le</code>.
Note that in this example, <code>h</code> and the goal are logically equivalent statements, but <code>peel</code>
<em>cannot</em> be immediately applied to show that the goal implies <code>h</code>.</p><p>In addition, <code>peel</code> supports goals of the form <code>(‚àÄ x, p x) ‚Üî ‚àÄ x, q x</code>, or likewise for any
other quantifier. In this case, there is no hypothesis or term to supply, but otherwise the syntax
is the same. So for such goals, the syntax is <code>peel 1</code> or <code>peel with x</code>, and after which the
resulting goal is <code>p x ‚Üî q x</code>. The <code>congr!</code> tactic can also be applied to goals of this form using
<code>congr! 1 with x</code>. While <code>congr!</code> applies congruence lemmas in general, <code>peel</code> can be relied upon
to only apply to outermost quantifiers.</p><p>Finally, the user may supply a term <code>e</code> via <code>... using e</code> in order to close the goal
immediately. In particular, <code>peel h using e</code> is equivalent to <code>peel h; exact e</code>. The <code>using</code> syntax
may be paired with any of the other features of <code>peel</code>.</p><p>This tactic works by repeatedly applying lemmas such as <code><a href="./Init/PropLemmas.html#forall_imp">forall_imp</a></code>, <code><a href="./Init/PropLemmas.html#Exists.imp">Exists.imp</a></code>,
<code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Eventually.mp">Filter.Eventually.mp</a></code>, <code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Frequently.mp">Filter.Frequently.mp</a></code>, and <code><a href="./Mathlib/Order/Filter/Basic.html#Filter.Eventually.of_forall">Filter.Eventually.of_forall</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Peel.html#Mathlib.Tactic.Peel.peel">Mathlib.Tactic.Peel</a></dd></dl></div><div id="Batteries.Tactic.¬´tacticPick_goal-_¬ª"><h2>pick_goal</h2><p><p><code>pick_goal n</code> will move the <code>n</code>-th goal to the front.</p><p><code>pick_goal -n</code> will move the <code>n</code>-th goal (counting from the bottom) to the front.</p><p>See also <code>Tactic.rotate_goals</code>, which moves goals from the front to the back and vice-versa.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.¬´tacticPick_goal-_¬ª">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="plausibleSyntax"><h2>plausible</h2><p><p><code>plausible</code> considers a proof goal and tries to generate examples
that would contradict the statement.</p><p>Let's consider the following proof goal.</p><pre><code class="language-lean">xs : <a href="./Init/Prelude.html#List">List</a> Nat,
h : ‚àÉ (x : Nat) (H : x ‚àà xs), x &lt; 3
‚ä¢ ‚àÄ (y : Nat), y ‚àà xs ‚Üí y &lt; 5
</code></pre><p>The local constants will be reverted and an instance will be found for
<code>Testable (‚àÄ (xs : <a href="./Init/Prelude.html#List">List</a> Nat), (‚àÉ x ‚àà xs, x &lt; 3) ‚Üí (‚àÄ y ‚àà xs, y &lt; 5))</code>.
The <code>Testable</code> instance is supported by an instance of <code>Sampleable (List Nat)</code>,
<code><a href="./Init/Prelude.html#Decidable">Decidable</a> (x &lt; 3)</code> and <code><a href="./Init/Prelude.html#Decidable">Decidable</a> (y &lt; 5)</code>.</p><p>Examples will be created in ascending order of size (more or less)</p><p>The first counter-examples found will be printed and will result in an error:</p><pre><code>===================
Found problems!
xs := [1, 28]
x := 1
y := 28
-------------------
</code></pre><p>If <code>plausible</code> successfully tests 100 examples, it acts like
admit. If it gives up or finds a counter-example, it reports an error.</p><p>For more information on writing your own <code>Sampleable</code> and <code>Testable</code>
instances, see <code>Testing.Plausible.Testable</code>.</p><p>Optional arguments given with <code>plausible (config : { ... })</code></p><ul><li><code>numInst</code> (default 100): number of examples to test properties with</li><li><code>maxSize</code> (default 100): final size argument</li></ul><p>Options:</p><ul><li><code>set_option trace.plausible.decoration true</code>: print the proposition with quantifier annotations</li><li><code>set_option trace.plausible.discarded true</code>: print the examples discarded because they do not
satisfy assumptions</li><li><code>set_option trace.plausible.shrink.steps true</code>: trace the shrinking of counter-example</li><li><code>set_option trace.plausible.shrink.candidates true</code>: print the lists of candidates considered
when shrinking each variable</li><li><code>set_option trace.plausible.instance true</code>: print the instances of <code>testable</code> being used to test
the proposition</li><li><code>set_option trace.plausible.success true</code>: print the tested samples that satisfy a property</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Plausible/Tactic.html#plausibleSyntax">Plausible.Tactic</a></dd></dl></div><div id="Mathlib.Tactic.Positivity.positivity"><h2>positivity</h2><p><p>Tactic solving goals of the form <code>0 ‚â§ x</code>, <code>0 &lt; x</code> and <code>x ‚â† 0</code>.  The tactic works recursively
according to the syntax of the expression <code>x</code>, if the atoms composing the expression all have
numeric lower bounds which can be proved positive/nonnegative/nonzero by <code><a href="./Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.  This tactic
either closes the goal or fails.</p><p><code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a> [t‚ÇÅ, ‚Ä¶, t‚Çô]</code> first executes <code>have := t‚ÇÅ; ‚Ä¶; have := t‚Çô</code> in the current goal,
then runs <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code>. This is useful when <code><a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a></code> needs derived premises such as <code>0 &lt; y</code>
for division/reciprocal, or <code>0 ‚â§ x</code> for real powers.</p><p>Examples:</p><pre><code>example {a : ‚Ñ§} (ha : 3 &lt; a) : 0 ‚â§ a ^ 3 + a := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {a : ‚Ñ§} (ha : 1 &lt; a) : 0 &lt; |(3:‚Ñ§) + a| := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {b : ‚Ñ§} : 0 ‚â§ max (-3) (b ^ 2) := by <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a>

example {a b c d : ‚Ñù} (hab : 0 &lt; a * b) (hb : 0 ‚â§ b) (hcd : c &lt; d) :
    0 &lt; a ^ c + 1 / (d - c) := by
  <a href="./Mathlib/Tactic/Positivity/Core.html#positivity">positivity</a> [sub_pos_of_lt hcd, <a href="./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.html#pos_of_mul_pos_left">pos_of_mul_pos_left</a> hab hb]
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Positivity/Core.html#Mathlib.Tactic.Positivity.positivity">Mathlib.Tactic.Positivity.Core</a></dd></dl></div><div id="Mathlib.Tactic.Push.pull"><h2>pull</h2><p><p><code>pull c</code> rewrites the goal by pulling the constant <code>c</code> closer to the head of the expression.
For instance, <code>pull _ ‚àà _</code> rewrites <code>x ‚àà y ‚à® ¬¨ x ‚àà z</code> into <code>x ‚àà y ‚à™ z·∂ú</code>.
More precisely, the <code>pull</code> tactic repeatedly rewrites an expression by applying lemmas
of the form <code>... (c ...) = c ...</code> (where <code>c</code> can appear 1 or more times on the left hand side).
<code>pull</code> is the inverse tactic to <code>push</code>. To extend the <code>pull</code> tactic, you can tag a lemma
with the <code>@[push]</code> attribute. <code>pull</code> works as both a tactic and a conv tactic.</p><p>A lemma is considered a <code>pull</code> lemma if its reverse direction is a <code>push</code> lemma
that actually moves the given constant away from the head. For example</p><ul><li><code><a href="./Init/PropLemmas.html#not_or">not_or</a> : ¬¨ (p ‚à® q) ‚Üî ¬¨ p ‚àß ¬¨ q</code> is a <code>pull</code> lemma, but <code>not_not : ¬¨ ¬¨ p ‚Üî p</code> is not.</li><li><code>log_mul : log (x * y) = log x + log y</code> is a <code>pull</code> lemma, but <code>log_abs : log |x| = log x</code> is not.</li><li><code>Pi.mul_def : f * g = fun (i : Œπ) =&gt; f i * g i</code> and <code>Pi.one_def : 1 = fun (x : Œπ) =&gt; 1</code> are both
<code>pull</code> lemmas for <code>fun</code>, because every <code>push fun _ ‚Ü¶ _</code> lemma is also considered a <code>pull</code> lemma.</li></ul><p>TODO: define a <code>@[pull]</code> attribute for tagging <code>pull</code> lemmas that are not <code>push</code> lemmas.</p><ul><li><code>pull _ ~ _</code> pulls the operator or relation <code>~</code>.</li><li><code>pull c at l1 l2 ...</code> rewrites at the given locations.</li><li><code>pull c at *</code> rewrites at all hypotheses and the goal.</li><li><code>pull (disch := tac) c</code> uses the tactic <code>tac</code> to discharge any hypotheses for <code>@[push]</code> lemmas.</li></ul><p>Examples:</p><ul><li><code>pull _ ‚àà _</code> rewrites <code>x ‚àà y ‚à® ¬¨ x ‚àà z</code> into <code>x ‚àà y ‚à™ z·∂ú</code>.</li><li><code>pull (disch := positivity) Real.log</code> rewrites <code>log a + 2 * log b</code> into <code>log (a * b ^ 2)</code>.</li><li><code>pull fun _ ‚Ü¶ _</code> rewrites <code>f ^ 2 + 5</code> into <code>fun x =&gt; f x ^ 2 + 5</code> where <code>f</code> is a function.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull">Mathlib.Tactic.Push</a></dd></dl></div><div id="Mathlib.Tactic.Push.pushStx"><h2>push</h2><p><p><code>push c</code> rewrites the goal by pushing the constant <code>c</code> deeper into an expression.
For instance, <code>push _ ‚àà _</code> rewrites <code>x ‚àà {y} ‚à™ z·∂ú</code> into <code>x = y ‚à® ¬¨ x ‚àà z</code>.
More precisely, the <code>push</code> tactic repeatedly rewrites an expression by applying lemmas
of the form <code>c ... = ... (c ...)</code> (where <code>c</code> can appear 0 or more times on the right hand side).
To extend the <code>push</code> tactic, you can tag a lemma of this form with the <code>@[push]</code> attribute.</p><p>To instead move a constant closer to the head of the expression, use the <code>pull</code> tactic.</p><p><code>push</code> works as both a tactic and a conv tactic.</p><ul><li><code>push _ ~ _</code> pushes the (binary) operator <code>~</code>, <code>push ~ _</code> pushes the (unary) operator <code>~</code>.</li><li><code>push c at l1 l2 ...</code> rewrites at the given locations.</li><li><code>push c at *</code> rewrites at all hypotheses and the goal.</li><li><code>push (disch := tac) c</code> uses the tactic <code>tac</code> to discharge any hypotheses for <code>@[push]</code> lemmas.</li></ul><p>Examples:</p><ul><li><code>push _ ‚àà _</code> rewrites <code>x ‚àà {y} ‚à™ z·∂ú</code> into <code>x = y ‚à® ¬¨ x ‚àà z</code>.</li><li><code>push (disch := positivity) Real.log</code> rewrites <code>log (a * b ^ 2)</code> into <code>log a + 2 * log b</code>.</li><li><code>push ¬¨ _</code> is the same as <code>push_neg</code> or <code>push <a href="./Init/Prelude.html#Not">Not</a></code>, and it rewrites
<code>¬¨ ‚àÄ Œµ &gt; 0, ‚àÉ Œ¥ &gt; 0, Œ¥ &lt; Œµ</code> into <code>‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, Œµ ‚â§ Œ¥</code>.</li><li><code>push fun _ ‚Ü¶ _</code> rewrites <code>fun x =&gt; f x ^ 2 + 5</code> into <code>f ^ 2 + 5</code></li><li><code>push ‚àÄ _, _</code> rewrites <code>‚àÄ a, p a ‚àß q a</code> into <code>(‚àÄ a, p a) ‚àß (‚àÄ a, q a)</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStx">Mathlib.Tactic.Push</a></dd></dl></div><div id="Lean.Parser.Tactic.pushCast"><h2>push_cast</h2><p><p><code>push_cast</code> rewrites the goal to move certain coercions (<em>casts</em>) inward, toward the leaf nodes.
This uses <code>norm_cast</code> lemmas in the forward direction.
For example, <code>‚Üë(a + b)</code> will be written to <code>‚Üëa + ‚Üëb</code>.</p><ul><li><code>push_cast</code> moves casts inward in the goal.</li><li><code>push_cast at h</code> moves casts inward in the hypothesis <code>h</code>.
It can be used with extra simp lemmas with, for example, <code>push_cast [Int.add_zero]</code>.</li></ul><p>Example:</p><pre><code class="language-lean">example (a b : Nat)
    (h1 : ((a + b : Nat) : Int) = 10)
    (h2 : ((a + b + 0 : Nat) : Int) = 10) :
    ((a + b : Nat) : Int) = 10 := by
  /-
  h1 : ‚Üë(a + b) = 10
  h2 : ‚Üë(a + b + 0) = 10
  ‚ä¢ ‚Üë(a + b) = 10
  -/
  push_cast
  /- Now
  ‚ä¢ ‚Üëa + ‚Üëb = 10
  -/
  push_cast at h1
  push_cast [Int.add_zero] at h2
  /- Now
  h1 h2 : ‚Üëa + ‚Üëb = 10
  -/
  exact h1
</code></pre><p>See also <code>norm_cast</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.pushCast">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Push.push_neg"><h2>push_neg</h2><p><p><code>push_neg</code> rewrites the goal by pushing negations deeper into an expression.
For instance, the goal <code>¬¨ ‚àÄ x, ‚àÉ y, x ‚â§ y</code> will be transformed by <code>push_neg</code> into
<code>‚àÉ x, ‚àÄ y, y &lt; x</code>. Binder names are preserved (contrary to what would happen with <code>simp</code>
using the relevant lemmas). <code>push_neg</code> works as both a tactic and a conv tactic.</p><p><code>push_neg</code> is a special case of the more general <code>push</code> tactic, namely <code>push <a href="./Init/Prelude.html#Not">Not</a></code>.
The <code>push</code> tactic can be extended using the <code>@[push]</code> attribute. <code>push</code> has special-casing
built in for <code>push <a href="./Init/Prelude.html#Not">Not</a></code>.</p><p>Tactics that introduce a negation usually have a version that automatically calls <code>push_neg</code> on
that negation. These include <code>by_cases!</code>, <code>contrapose!</code> and <code>by_contra!</code>.</p><ul><li><code>push_neg at l1 l2 ...</code> rewrites at the given locations.</li><li><code>push_neg at *</code> rewrites at each hypothesis and the goal.</li><li><code>push_neg +distrib</code> rewrites <code>¬¨ (p ‚àß q)</code> into <code>¬¨ p ‚à® ¬¨ q</code> (by default, the tactic rewrites it
into <code>p ‚Üí ¬¨ q</code> instead).</li></ul><p>Example:</p><pre><code class="language-lean">example (h : ¬¨ ‚àÄ Œµ &gt; 0, ‚àÉ Œ¥ &gt; 0, ‚àÄ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚Üí |f x - y‚ÇÄ| ‚â§ Œµ) :
    ‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, ‚àÉ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚àß Œµ &lt; |f x - y‚ÇÄ| := by
  push_neg at h
  -- Now we have the hypothesis `h : ‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, ‚àÉ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚àß Œµ &lt; |f x - y‚ÇÄ|`
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg">Mathlib.Tactic.Push</a></dd></dl></div><div id="Lean.Parser.Tactic.rcases"><h2>rcases</h2><p><p><code>rcases</code> is a tactic that will perform <code>cases</code> recursively, according to a pattern. It is used to
destructure hypotheses or expressions composed of inductive types like <code>h1 : a ‚àß b ‚àß c ‚à® d</code> or
<code>h2 : ‚àÉ x y, trans_rel R x y</code>. Usual usage might be <code>rcases h1 with ‚ü®ha, hb, hc‚ü© | hd</code> or
<code>rcases h2 with ‚ü®x, y, _ | ‚ü®z, hxz, hzy‚ü©‚ü©</code> for these examples.</p><p>Each element of an <code>rcases</code> pattern is matched against a particular local hypothesis (most of which
are generated during the execution of <code>rcases</code> and represent individual elements destructured from
the input expression). An <code>rcases</code> pattern has the following grammar:</p><ul><li>A name like <code>x</code>, which names the active hypothesis as <code>x</code>.</li><li>A blank <code>_</code>, which does nothing (letting the automatic naming system used by <code>cases</code> name the
hypothesis).</li><li>A hyphen <code>-</code>, which clears the active hypothesis and any dependents.</li><li>The keyword <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, which expects the hypothesis to be <code>h : a = b</code>, and calls <code>subst</code> on the
hypothesis (which has the effect of replacing <code>b</code> with <code>a</code> everywhere or vice versa).</li><li>A type ascription <code>p : ty</code>, which sets the type of the hypothesis to <code>ty</code> and then matches it
against <code>p</code>. (Of course, <code>ty</code> must unify with the actual type of <code>h</code> for this to work.)</li><li>A tuple pattern <code>‚ü®p1, p2, p3‚ü©</code>, which matches a constructor with many arguments, or a series
of nested conjunctions or existentials. For example if the active hypothesis is <code>a ‚àß b ‚àß c</code>,
then the conjunction will be destructured, and <code>p1</code> will be matched against <code>a</code>, <code>p2</code> against <code>b</code>
and so on.</li><li>A <code>@</code> before a tuple pattern as in <code>@‚ü®p1, p2, p3‚ü©</code> will bind all arguments in the constructor,
while leaving the <code>@</code> off will only use the patterns on the explicit arguments.</li><li>An alternation pattern <code>p1 | p2 | p3</code>, which matches an inductive type with multiple constructors,
or a nested disjunction like <code>a ‚à® b ‚à® c</code>.</li></ul><p>A pattern like <code>‚ü®a, b, c‚ü© | ‚ü®d, e‚ü©</code> will do a split over the inductive datatype,
naming the first three parameters of the first constructor as <code>a,b,c</code> and the
first two of the second constructor <code>d,e</code>. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as <code>‚ü®‚ü®a‚ü©, b | c‚ü© | d</code> then these will cause more case splits as necessary.
If there are too many arguments, such as <code>‚ü®a, b, c‚ü©</code> for splitting on
<code>‚àÉ x, ‚àÉ y, p x</code>, then it will be treated as <code>‚ü®a, ‚ü®b, c‚ü©‚ü©</code>, splitting the last
parameter as necessary.</p><p><code>rcases</code> also has special support for quotient types: quotient induction into Prop works like
matching on the constructor <code>quot.mk</code>.</p><p><code>rcases h : e with PAT</code> will do the same as <code>rcases e with PAT</code> with the exception that an
assumption <code>h : e = PAT</code> will be added to the context.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.rcases">Init.RCases</a></dd></dl></div><div id="Batteries.Tactic.rcongr"><h2>rcongr</h2><p><p>Repeatedly apply <code><a href="./Init/Prelude.html#congr">congr</a></code> and <code>ext</code>, using the given patterns as arguments for <code>ext</code>.</p><p>There are two ways this tactic stops:</p><ul><li><code><a href="./Init/Prelude.html#congr">congr</a></code> fails (makes no progress), after having already applied <code>ext</code>.</li><li><code><a href="./Init/Prelude.html#congr">congr</a></code> canceled out the last usage of <code>ext</code>. In this case, the state is reverted to before
the <code><a href="./Init/Prelude.html#congr">congr</a></code> was applied.</li></ul><p>For example, when the goal is</p><pre><code>‚ä¢ (fun x =&gt; f x + 3) '' s = (fun x =&gt; g x + 3) '' s
</code></pre><p>then <code>rcongr x</code> produces the goal</p><pre><code>x : Œ± ‚ä¢ f x = g x
</code></pre><p>This gives the same result as <code>congr; ext x; <a href="./Init/Prelude.html#congr">congr</a></code>.</p><p>In contrast, <code><a href="./Init/Prelude.html#congr">congr</a></code> would produce</p><pre><code>‚ä¢ (fun x =&gt; f x + 3) = (fun x =&gt; g x + 3)
</code></pre><p>and <code><a href="./Init/Prelude.html#congr">congr</a> with x</code> (or <code>congr; ext x</code>) would produce</p><pre><code>x : Œ± ‚ä¢ f x + 3 = g x + 3
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Congr.html#Batteries.Tactic.rcongr">Batteries.Tactic.Congr</a></dd></dl></div><div id="Mathlib.Tactic.tacticRecover_"><h2>recover</h2><p><p><code>recover tacs</code> applies the tactic (sequence) <code>tacs</code> and then re-adds goals that were
incorrectly marked as closed. This helps to debug issues where a tactic closes goals without
solving them (i.e. goals were removed from the MetaM state without the metavariable
being assigned), resulting in the error &quot;(kernel) declaration has metavariables&quot;.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Recover.html#Mathlib.Tactic.tacticRecover_">Mathlib.Tactic.Recover</a></dd></dl></div><div id="Mathlib.Tactic.tacticReduce__"><h2>reduce</h2><p><p><code>reduce at loc</code> completely reduces the given location.
This also exists as a <code>conv</code>-mode tactic.</p><p>This does the same transformation as the <code>#reduce</code> command.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Lean.Parser.Tactic.refine"><h2>refine</h2><p><p><code>refine e</code> behaves like <code>exact e</code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>)
holes in <code>e</code> that are not solved by unification with the main goal's target type
are converted into new goals, using the hole's name, if any, as the goal case name.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.refine">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.refine'"><h2>refine'</h2><p><p><code>refine' e</code> behaves like <code>refine e</code>, except that unsolved placeholders (<code>_</code>)
and implicit parameters are also converted into new goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.refine'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRefine_lift_"><h2>refine_lift</h2><p><p>Auxiliary macro for lifting have/suffices/let/...
It makes sure the &quot;continuation&quot; <code>?_</code> is the main goal after refining.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRefine_lift'_"><h2>refine_lift'</h2><p><p>Similar to <code>refine_lift</code>, but using <code>refine'</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.refoldLetStx"><h2>refold_let</h2><p><p><code>refold_let x y z at loc</code> looks for the bodies of local definitions <code>x</code>, <code>y</code>, and <code>z</code> at the given
location and replaces them with <code>x</code>, <code>y</code>, or <code>z</code>. This is the inverse of &quot;zeta reduction.&quot;
This also exists as a <code>conv</code>-mode tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª"><h2>rel</h2><p><p>The <code>rel</code> tactic applies &quot;generalized congruence&quot; rules to solve a relational goal by
&quot;substitution&quot;.  For example,</p><pre><code>example {a b x c d : ‚Ñù} (h1 : a ‚â§ b) (h2 : c ‚â§ d) :
    x ^ 2 * a + c ‚â§ x ^ 2 * b + d := by
  rel [h1, h2]
</code></pre><p>In this example we &quot;substitute&quot; the hypotheses <code>a ‚â§ b</code> and <code>c ‚â§ d</code> into the LHS <code>x ^ 2 * a + c</code> of
the goal and obtain the RHS <code>x ^ 2 * b + d</code>, thus proving the goal.</p><p>The &quot;generalized congruence&quot; rules used are the library lemmas which have been tagged with the
attribute <code>@[gcongr]</code>.  For example, the first example constructs the proof term</p><pre><code>add_le_add (mul_le_mul_of_nonneg_left h1 (pow_bit0_nonneg x 1)) h2
</code></pre><p>using the generalized congruence lemmas <code>add_le_add</code> and <code>mul_le_mul_of_nonneg_left</code>.  If there are
no applicable generalized congruence lemmas, the tactic fails.</p><p>The tactic attempts to discharge side goals to these &quot;generalized congruence&quot; lemmas (such as the
side goal <code>0 ‚â§ x ^ 2</code> in the above application of <code>mul_le_mul_of_nonneg_left</code>) using the tactic
<code>gcongr_discharger</code>, which wraps <code>positivity</code> but can also be extended. If the side goals cannot
be discharged in this way, the tactic fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/GCongr/Core.html#Mathlib.Tactic.GCongr.¬´tacticRel[_]¬ª">Mathlib.Tactic.GCongr.Core</a></dd></dl></div><div id="Lean.Parser.Tactic.rename"><h2>rename</h2><p><p><code>rename t =&gt; x</code> renames the most recent hypothesis whose type matches <code>t</code>
(which may contain placeholders) to <code>x</code>, or fails if no such hypothesis could be found.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rename">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.rename'"><h2>rename'</h2><p><p><code>rename' h =&gt; hnew</code> renames the hypothesis named <code>h</code> to <code>hnew</code>.
To rename several hypothesis, use <code>rename' h‚ÇÅ =&gt; h‚ÇÅnew, h‚ÇÇ =&gt; h‚ÇÇnew</code>.
You can use <code>rename' a =&gt; b, b =&gt; a</code> to swap two variables.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Rename.html#Mathlib.Tactic.rename'">Mathlib.Tactic.Rename</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª"><h2>rename_bvar</h2><p><ul><li><code>rename_bvar old ‚Üí new</code> renames all bound variables named <code>old</code> to <code>new</code> in the target.</li><li><code>rename_bvar old ‚Üí new at h</code> does the same in hypothesis <code>h</code>.</li></ul><pre><code class="language-lean">example (P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop) (h : ‚àÄ n, ‚àÉ m, P n m) : ‚àÄ l, ‚àÉ m, P l m := by
  rename_bvar n ‚Üí q at h -- h is now ‚àÄ (q : ‚Ñï), ‚àÉ (m : ‚Ñï), P q m,
  rename_bvar m ‚Üí n -- target is now ‚àÄ (l : ‚Ñï), ‚àÉ (n : ‚Ñï), P k n,
  exact h -- Lean does not care about those bound variable names
</code></pre><p>Note: name clashes are resolved automatically.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/RenameBVar.html#Mathlib.Tactic.¬´tacticRename_bvar_‚Üí__¬ª">Mathlib.Tactic.RenameBVar</a></dd></dl></div><div id="Lean.Parser.Tactic.renameI"><h2>rename_i</h2><p><p><code>rename_i x_1 ... x_n</code> renames the last <code>n</code> inaccessible names using the given names.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.renameI">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRepeat_"><h2>repeat</h2><p><p><code>repeat tac</code> repeatedly applies <code>tac</code> so long as it succeeds.
The tactic <code>tac</code> may be a tactic sequence, and if <code>tac</code> fails at any point in its execution,
<code>repeat</code> will revert any partial changes that <code>tac</code> made to the tactic state.</p><p>The tactic <code>tac</code> should eventually fail, otherwise <code>repeat tac</code> will run indefinitely.</p><p>See also:</p><ul><li><code>try tac</code> is like <code>repeat tac</code> but will apply <code>tac</code> at most once.</li><li><code>repeat' tac</code> recursively applies <code>tac</code> to each goal.</li><li><code>first | tac1 | tac2</code> implements the backtracking used by <code>repeat</code></li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.repeat'"><h2>repeat'</h2><p><p><code>repeat' tac</code> recursively applies <code>tac</code> on all of the goals so long as it succeeds.
That is to say, if <code>tac</code> produces multiple subgoals, then <code>repeat' tac</code> is applied to each of them.</p><p>See also:</p><ul><li><code>repeat tac</code> simply repeatedly applies <code>tac</code>.</li><li><code>repeat1' tac</code> is <code>repeat' tac</code> but requires that <code>tac</code> succeed for some goal at least once.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.repeat'">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.tacticRepeat1_"><h2>repeat1</h2><p><p><code>repeat1 tac</code> applies <code>tac</code> to main goal at least once. If the application succeeds,
the tactic is applied recursively to the generated subgoals until it eventually fails.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Core.html#Mathlib.Tactic.tacticRepeat1_">Mathlib.Tactic.Core</a></dd></dl></div><div id="Lean.Parser.Tactic.repeat1'"><h2>repeat1'</h2><p><p><code>repeat1' tac</code> recursively applies to <code>tac</code> on all of the goals so long as it succeeds,
but <code>repeat1' tac</code> fails if <code>tac</code> succeeds on none of the initial goals.</p><p>See also:</p><ul><li><code>repeat tac</code> simply applies <code>tac</code> repeatedly.</li><li><code>repeat' tac</code> is like <code>repeat1' tac</code> but it does not require that <code>tac</code> succeed at least once.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.repeat1'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.replace"><h2>replace</h2><p><p>Acts like <code>have</code>, but removes a hypothesis with the same name as
this one if possible. For example, if the state is:</p><pre><code class="language-lean">f : Œ± ‚Üí Œ≤
h : Œ±
‚ä¢ goal
</code></pre><p>Then after <code>replace h := f h</code> the state will be:</p><pre><code class="language-lean">f : Œ± ‚Üí Œ≤
h : Œ≤
‚ä¢ goal
</code></pre><p>whereas <code>have h := f h</code> would result in:</p><pre><code class="language-lean">f : Œ± ‚Üí Œ≤
h‚Ä† : Œ±
h : Œ≤
‚ä¢ goal
</code></pre><p>This can be used to simulate the <code>specialize</code> and <code>apply at</code> tactics of Coq.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.replace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.revert"><h2>revert</h2><p><p><code>revert x...</code> is the inverse of <code>intro x...</code>: it moves the given hypotheses
into the main goal's target type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.revert">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rewriteSeq"><h2>rewrite</h2><p><p><code>rewrite [e]</code> applies identity <code>e</code> as a rewrite rule to the target of the main goal.
If <code>e</code> is preceded by left arrow (<code>‚Üê</code> or <code>&lt;-</code>), the rewrite is applied in the reverse direction.
If <code>e</code> is a defined constant, then the equational theorems associated with <code>e</code> are used.
This provides a convenient way to unfold <code>e</code>.</p><ul><li><code>rewrite [e‚ÇÅ, ..., e‚Çô]</code> applies the given rules sequentially.</li><li><code>rewrite [e] at l</code> rewrites <code>e</code> at location(s) <code>l</code>, where <code>l</code> is either <code>*</code> or a
list of hypotheses in the local context. In the latter case, a turnstile <code>‚ä¢</code> or <code>|-</code>
can also be used, to signify the target of the goal.</li></ul><p>Using <code>rw (occs := .pos L) [e]</code>,
where <code>L : <a href="./Init/Prelude.html#List">List</a> <a href="./Init/Prelude.html#Nat">Nat</a></code>, you can control which &quot;occurrences&quot; are rewritten.
(This option applies to each rule, so usually this will only be used with a single rule.)
Occurrences count from <code>1</code>.
At each allowed occurrence, arguments of the rewrite rule <code>e</code> may be instantiated,
restricting which later rewrites can be found.
(Disallowed occurrences do not result in instantiation.)
<code>(occs := .neg L)</code> allows skipping specified occurrences.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.DepRewrite.depRewriteSeq"><h2>rewrite!</h2><p><p><code>rewrite!</code> is like <code>rewrite</code>,
but can also insert casts to adjust types that depend on the LHS of a rewrite.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p><p>The sort of casts that are inserted is controlled by the <code>castMode</code> configuration option.
By default, only proof terms are casted;
by proof irrelevance, this adds no observable complexity.</p><p>With <code>rewrite! +letAbs (castMode := .all)</code>, casts are inserted whenever necessary.
This means that the 'motive is not type correct' error never occurs,
at the expense of creating potentially complicated terms.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRewriteSeq">Mathlib.Tactic.DepRewrite</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRfl"><h2>rfl</h2><p><p>This tactic applies to a goal whose target has the form <code>x ~ x</code>,
where <code>~</code> is equality, heterogeneous equality or any relation that
has a reflexivity lemma tagged with the attribute @[refl].</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRfl'"><h2>rfl'</h2><p><p><code>rfl'</code> is similar to <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.right"><h2>right</h2><p><p>Applies the second constructor when
the goal is an inductive type with exactly two constructors, or fails otherwise.</p><pre><code>example {p q : Prop} (h : q) : p ‚à® q := by
  right
  exact h
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.right">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.RingNF.ring"><h2>ring</h2><p><p><code>ring</code> solves equations in <em>commutative</em> (semi)rings, allowing for variables in the
exponent. If the goal is not appropriate for <code>ring</code> (e.g. not an equality) <code>ring_nf</code> will be
suggested. See also <code>ring1</code>, which fails if the goal is not an equality.</p><ul><li><code>ring!</code> will use a more aggressive reducibility setting to determine equality of atoms.</li></ul><p>Examples:</p><pre><code>example (n : ‚Ñï) (m : ‚Ñ§) : 2^(n+1) * m = 2 * 2^n * m := by ring
example (a b : ‚Ñ§) (n : ‚Ñï) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring
example (x y : ‚Ñï) : x + <a href="./Init/Prelude.html#id">id</a> y = y + <a href="./Init/Prelude.html#id">id</a> x := by ring!
example (x : ‚Ñï) (h : x * 2 &gt; 5): x + x &gt; 5 := by ring; assumption -- suggests ring_nf
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring">Mathlib.Tactic.Ring.RingNF</a></dd></dl></div><div id="Mathlib.Tactic.Ring.ring1"><h2>ring1</h2><p><p><code>ring1</code> solves the goal when it is an equality in <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><p>This version of <code>ring</code> fails if the target is not an equality.</p><ul><li><code>ring1!</code> uses a more aggressive reducibility setting to determine equality of atoms.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">Mathlib.Tactic.Ring.Basic</a></dd></dl></div><div id="Mathlib.Tactic.RingNF.ringNF"><h2>ring_nf</h2><p><p><code>ring_nf</code> simplifies expressions in the language of commutative (semi)rings,
which rewrites all ring expressions into a normal form, allowing variables in the exponents.</p><p><code>ring_nf</code> works as both a tactic and a conv tactic.</p><p>See also the <code>ring</code> tactic for solving a goal which is an equation in the language
of commutative (semi)rings.</p><ul><li><code>ring_nf!</code> will use a more aggressive reducibility setting to identify atoms.</li><li><code>ring_nf (config := cfg)</code> allows for additional configuration (see <code>RingNF.Config</code>):<ul><li><code>red</code>: the reducibility setting (overridden by <code>!</code>)</li><li><code>zetaDelta</code>: if true, local let variables can be unfolded (overridden by <code>!</code>)</li><li><code>recursive</code>: if true, <code>ring_nf</code> will also recurse into atoms</li></ul></li><li><code>ring_nf at l1 l2 ...</code> can be used to rewrite at the given locations.</li></ul><p>Examples:
This can be used non-terminally to normalize ring expressions in the goal such as
<code>‚ä¢ P (x + x + x)</code> ~&gt; <code>‚ä¢ P (x * 3)</code>, as well as being able to prove some equations that
<code>ring</code> cannot because they involve ring reasoning inside a subterm, such as
<code>sin (x + y) + sin (y + x) = 2 * sin (x + y)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF">Mathlib.Tactic.Ring.RingNF</a></dd></dl></div><div id="Lean.Parser.Tactic.rintro"><h2>rintro</h2><p><p>The <code>rintro</code> tactic is a combination of the <code>intros</code> tactic with <code>rcases</code> to
allow for destructuring patterns while introducing variables. See <code>rcases</code> for
a description of supported patterns. For example, <code>rintro (a | ‚ü®b, c‚ü©) ‚ü®d, e‚ü©</code>
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables <code>a d e</code> and the other with <code>b c d e</code>.</p><p><code>rintro</code>, unlike <code>rcases</code>, also supports the form <code>(x y : ty)</code> for introducing
and type-ascripting multiple variables at once, similar to binders.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/RCases.html#Lean.Parser.Tactic.rintro">Init.RCases</a></dd></dl></div><div id="Lean.Parser.Tactic.rotateLeft"><h2>rotate_left</h2><p><p><code>rotate_left n</code> rotates goals to the left by <code>n</code>. That is, <code>rotate_left 1</code>
takes the main goal and puts it to the back of the subgoal list.
If <code>n</code> is omitted, it defaults to <code>1</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rotateRight"><h2>rotate_right</h2><p><p>Rotate the goals to the right by <code>n</code>. That is, take the goal at the back
and push it to the front <code>n</code> times. If <code>n</code> is omitted, it defaults to <code>1</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rotateRight">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.rsuffices"><h2>rsuffices</h2><p><p>The <code>rsuffices</code> tactic is an alternative version of <code>suffices</code>, that allows the usage
of any syntax that would be valid in an <code>obtain</code> block. This tactic just calls <code>obtain</code>
on the expression, and then <code>rotate_left</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/RSuffices.html#Mathlib.Tactic.rsuffices">Mathlib.Tactic.RSuffices</a></dd></dl></div><div id="Lean.Parser.Tactic.runTac"><h2>run_tac</h2><p><p>The <code>run_tac doSeq</code> tactic executes code in <code>TacticM <a href="./Init/Prelude.html#Unit">Unit</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.runTac">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.rwSeq"><h2>rw</h2><p><p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by &quot;cheap&quot; (reducible) <code><a href="./Init/Prelude.html#rfl">rfl</a></code> afterwards.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rwSeq">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.DepRewrite.depRwSeq"><h2>rw!</h2><p><p><code>rw!</code> is like <code>rewrite!</code>, but also cleans up introduced refl-casts after every substitution.
It is available as an ordinary tactic and a <code>conv</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DepRewrite.html#Mathlib.Tactic.DepRewrite.depRwSeq">Mathlib.Tactic.DepRewrite</a></dd></dl></div><div id="Lean.Parser.Tactic.rewrites?"><h2>rw?</h2><p><p><code>rw?</code> tries to find a lemma which can rewrite the goal.</p><p><code>rw?</code> should not be left in proofs; it is a search tool, like <code>apply?</code>.</p><p>Suggestions are printed as <code>rw [h]</code> or <code>rw [‚Üê h]</code>.</p><p>You can use <code>rw? [-my_lemma, -my_theorem]</code> to prevent <code>rw?</code> using the named lemmas.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.rewrites?">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.LibraryRewrite.tacticRw??"><h2>rw??</h2><p><p><code>rw??</code> is an interactive tactic that suggests rewrites for any expression selected by the user.
To use it, shift-click an expression in the goal or a hypothesis that you want to rewrite.
Clicking on one of the rewrite suggestions will paste the relevant rewrite tactic into the editor.</p><p>The rewrite suggestions are grouped and sorted by the pattern that the rewrite lemmas match with.
Rewrites that don't change the goal and rewrites that create the same goal as another rewrite
are filtered out, as well as rewrites that have new metavariables in the replacement expression.
To see all suggestions, click on the filter button (‚ñº) in the top right.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/LibraryRewrite.html#Mathlib.Tactic.LibraryRewrite.tacticRw??">Mathlib.Tactic.Widget.LibraryRewrite</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRw_mod_cast___"><h2>rw_mod_cast</h2><p><p>Rewrites with the given rules, normalizing casts prior to each step.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/TacticsExtra.html#Lean.Parser.Tactic.tacticRw_mod_cast___">Init.TacticsExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticRwa__"><h2>rwa</h2><p><p><code>rwa</code> is short-hand for <code>rw; assumption</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticRwa__">Init.Tactics</a></dd></dl></div><div id="Aesop.Frontend.saturate"><h2>saturate</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Saturate.html#Aesop.Frontend.saturate">Aesop.Frontend.Saturate</a></dd></dl></div><div id="Aesop.Frontend.saturate?"><h2>saturate?</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Aesop/Frontend/Saturate.html#Aesop.Frontend.saturate?">Aesop.Frontend.Saturate</a></dd></dl></div><div id="Mathlib.Tactic.Says.says"><h2>says</h2><p><p>If you write <code>X says</code>, where <code>X</code> is a tactic that produces a &quot;Try this: Y&quot; message,
then you will get a message &quot;Try this: X says Y&quot;.
Once you've clicked to replace <code>X says</code> with <code>X says Y</code>,
afterwards <code>X says Y</code> will only run <code>Y</code>.</p><p>The typical usage case is:</p><pre><code>simp? [X] says simp only [X, Y, Z]
</code></pre><p>If you use <code>set_option says.verify true</code> (set automatically during CI) then <code>X says Y</code>
runs <code>X</code> and verifies that it still prints &quot;Try this: Y&quot;.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Says.html#Mathlib.Tactic.Says.says">Mathlib.Tactic.Says</a></dd></dl></div><div id="Mathlib.Tactic.setTactic"><h2>set</h2><p><p><code>set a := t with h</code> is a variant of <code>let a := t</code>. It adds the hypothesis <code>h : a = t</code> to
the local context and replaces <code>t</code> with <code>a</code> everywhere it can.</p><p><code>set a := t with ‚Üê h</code> will add <code>h : t = a</code> instead.</p><p><code>set! a := t with h</code> does not do any replacing.</p><pre><code class="language-lean">example (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by
  set y := x with ‚Üê h2
  sorry
/-
x : <a href="./Init/Prelude.html#Nat">Nat</a>
y : <a href="./Init/Prelude.html#Nat">Nat</a> := x
h : y + y - y = 3
h2 : x = y
‚ä¢ y + y - y = 3
-/
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Set.html#Mathlib.Tactic.setTactic">Mathlib.Tactic.Set</a></dd></dl></div><div id="Lean.Parser.Tactic.set_option"><h2>set_option</h2><p><p><code>set_option opt val in tacs</code> (the tactic) acts like <code>set_option opt val</code> at the command level,
but it sets the option only within the tactics <code>tacs</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Parser/Command.html#Lean.Parser.Tactic.set_option">Lean.Parser.Command</a></dd></dl></div><div id="Lean.Parser.Tactic.show"><h2>show</h2><p><p><code>show t</code> finds the first goal whose target unifies with <code>t</code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code>t</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.show">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.showTerm"><h2>show_term</h2><p><p><code>show_term tac</code> runs <code>tac</code>, then prints the generated term in the form
&quot;exact X Y Z&quot; or &quot;refine X ?_ Z&quot; (prefixed by <code>expose_names</code> if necessary)
if there are remaining subgoals.</p><p>(For some tactics, the printed term will not be human readable.)</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.showTerm">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simp"><h2>simp</h2><p><p>The <code>simp</code> tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:</p><ul><li><code>simp</code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li><li><code>simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code> and the given <code>h·µ¢</code>'s, where the <code>h·µ¢</code>'s are expressions.-</li><li>If an <code>h·µ¢</code> is a defined constant <code>f</code>, then <code>f</code> is unfolded. If <code>f</code> has equational lemmas associated
with it (and is not a projection or a <code>reducible</code> definition), these are used to rewrite with <code>f</code>.</li><li><code>simp [*]</code> simplifies the main goal target using the lemmas tagged with the
attribute <code>[simp]</code> and all hypotheses.</li><li><code>simp only [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]</code> is like <code>simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]</code> but does not use <code>[simp]</code> lemmas.</li><li><code>simp [-id‚ÇÅ, ..., -id‚Çô]</code> simplifies the main goal target using the lemmas tagged
with the attribute <code>[simp]</code>, but removes the ones named <code>id·µ¢</code>.</li><li><code>simp at h‚ÇÅ h‚ÇÇ ... h‚Çô</code> simplifies the hypotheses <code>h‚ÇÅ : T‚ÇÅ</code> ... <code>h‚Çô : T‚Çô</code>. If
the target or another hypothesis depends on <code>h·µ¢</code>, a new simplified hypothesis
<code>h·µ¢</code> is introduced, but the old one remains in the local context.</li><li><code>simp at *</code> simplifies all the hypotheses and the target.</li><li><code>simp [*] at *</code> simplifies target and all (propositional) hypotheses using the
other hypotheses.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simp">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAutoUnfold"><h2>simp!</h2><p><p><code>simp!</code> is shorthand for <code>simp</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpTrace"><h2>simp?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimp?!_"><h2>simp?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp?!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAll"><h2>simp_all</h2><p><p><code>simp_all</code> is a stronger version of <code>simp [*] at *</code> where the hypotheses and target
are simplified multiple times until no simplification is applicable.
Only non-dependent propositional hypotheses are considered.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpAll">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllAutoUnfold"><h2>simp_all!</h2><p><p><code>simp_all!</code> is shorthand for <code>simp_all</code> with <code>autoUnfold := true</code>.
This will unfold applications of functions defined by pattern matching, when one of the patterns applies.
This can be used to partially evaluate many definitions.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllAutoUnfold">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllTrace"><h2>simp_all?</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpAllTrace">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimp_all?!_"><h2>simp_all?!</h2><p><p><code>simp?</code> takes the same arguments as <code>simp</code>, but reports an equivalent call to <code>simp only</code>
that would be sufficient to close the goal. This is useful for reducing the size of the simp
set in a local invocation to speed up processing.</p><pre><code>example (x : Nat) : (if <a href="./Init/Prelude.html#True">True</a> then x + 2 else 3) = x + 2 := by
  simp? -- prints &quot;Try this: simp only [ite_true]&quot;
</code></pre><p>This command can also be used in <code>simp_all</code> and <code>dsimp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimp_all?!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllArith"><h2>simp_all_arith</h2><p><p><code>simp_all_arith</code> has been deprecated. It was a shorthand for <code>simp_all +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllArith">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpAllArithBang"><h2>simp_all_arith!</h2><p><p><code>simp_all_arith!</code> has been deprecated. It was a shorthand for <code>simp_all! +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpAllArithBang">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpArith"><h2>simp_arith</h2><p><p><code>simp_arith</code> has been deprecated. It was a shorthand for <code>simp +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpArith">Init.Meta</a></dd></dl></div><div id="Lean.Parser.Tactic.simpArithBang"><h2>simp_arith!</h2><p><p><code>simp_arith!</code> has been deprecated. It was a shorthand for <code>simp! +arith +decide</code>.
Note that <code>+decide</code> is not needed for reducing arithmetic terms since simprocs have been added to Lean.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Meta.html#Lean.Parser.Tactic.simpArithBang">Init.Meta</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª"><h2>simp_intro</h2><p><p>The <code>simp_intro</code> tactic is a combination of <code>simp</code> and <code>intro</code>: it will simplify the types of
variables as it introduces them and uses the new variables to simplify later arguments
and the goal.</p><ul><li><code>simp_intro x y z</code> introduces variables named <code>x y z</code></li><li><code>simp_intro x y z ..</code> introduces variables named <code>x y z</code> and then keeps introducing <code>_</code> binders</li><li><code>simp_intro (config := cfg) (discharger := tac) x y .. only [h‚ÇÅ, h‚ÇÇ]</code>:
<code>simp_intro</code> takes the same options as <code>simp</code> (see <code>simp</code>)</li></ul><pre><code>example : x + 0 = y ‚Üí x = z := by
  simp_intro h
  -- h: x = y ‚ä¢ y = z
  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SimpIntro.html#Mathlib.Tactic.¬´tacticSimp_intro_____..Only_¬ª">Mathlib.Tactic.SimpIntro</a></dd></dl></div><div id="Mathlib.Tactic.tacticSimp_rw___"><h2>simp_rw</h2><p><p><code>simp_rw</code> functions as a mix of <code>simp</code> and <code>rw</code>. Like <code>rw</code>, it applies each
rewrite rule in the given order, but like <code>simp</code> it repeatedly applies these
rules and also under binders like <code>‚àÄ x, ...</code>, <code>‚àÉ x, ...</code> and <code>fun x ‚Ü¶...</code>.
Usage:</p><ul><li><code>simp_rw [lemma_1, ..., lemma_n]</code> will rewrite the goal by applying the
lemmas in that order. A lemma preceded by <code>‚Üê</code> is applied in the reverse direction.</li><li><code>simp_rw [lemma_1, ..., lemma_n] at h‚ÇÅ ... h‚Çô</code> will rewrite the given hypotheses.</li><li><code>simp_rw [...] at *</code> rewrites in the whole context: all hypotheses and the goal.</li></ul><p>Lemmas passed to <code>simp_rw</code> must be expressions that are valid arguments to <code>simp</code>.
For example, neither <code>simp</code> nor <code>rw</code> can solve the following, but <code>simp_rw</code> can:</p><pre><code class="language-lean">example {a : ‚Ñï}
    (h1 : ‚àÄ a b : ‚Ñï, a - 1 ‚â§ b ‚Üî a ‚â§ b + 1)
    (h2 : ‚àÄ a b : ‚Ñï, a ‚â§ b ‚Üî ‚àÄ c, c &lt; a ‚Üí c &lt; b) :
    (‚àÄ b, a - 1 ‚â§ b) = ‚àÄ b c : ‚Ñï, c &lt; a ‚Üí c &lt; b + 1 := by
  simp_rw [h1, h2]
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SimpRw.html#Mathlib.Tactic.tacticSimp_rw___">Mathlib.Tactic.SimpRw</a></dd></dl></div><div id="tacticSimp_wf"><h2>simp_wf</h2><p><p>Unfold definitions commonly used in well founded relation definitions.</p><p>Since Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the
user, and this tactic should no longer be necessary. Calls to <code>simp_wf</code> can be removed or replaced
by plain calls to <code>simp</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/WFTactics.html#tacticSimp_wf">Init.WFTactics</a></dd></dl></div><div id="Lean.Parser.Tactic.simpa"><h2>simpa</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ‚ãØ] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ‚ãØ]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.simpa">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa!_"><h2>simpa!</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ‚ãØ] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ‚ãØ]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa!_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa?_"><h2>simpa?</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ‚ãØ] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ‚ãØ]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSimpa?!_"><h2>simpa?!</h2><p><p>This is a &quot;finishing&quot; tactic modification of <code>simp</code>. It has two forms.</p><ul><li><code>simpa [rules, ‚ãØ] using e</code> will simplify the goal and the type of
<code>e</code> using <code>rules</code>, then try to close the goal using <code>e</code>.</li></ul><p>Simplifying the type of <code>e</code> makes it more likely to match the goal
(which has also been simplified). This construction also tends to be
more robust under changes to the simp lemma set.</p><ul><li><code>simpa [rules, ‚ãØ]</code> will simplify the goal and the type of a
hypothesis <code>this</code> if present in the context, then try to close the goal using
the <code>assumption</code> tactic.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSimpa?!_">Init.Tactics</a></dd></dl></div><div id="List.tacticSizeOf_list_dec"><h2>sizeOf_list_dec</h2><p><p>This tactic, added to the <code>decreasing_trivial</code> toolbox, proves that
<code>sizeOf a &lt; sizeOf as</code> when <code>a ‚àà as</code>, which is useful for well founded recursions
over a nested inductive like <code>inductive T | mk : <a href="./Init/Prelude.html#List">List</a> T ‚Üí T</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Data/List/BasicAux.html#List.tacticSizeOf_list_dec">Init.Data.List.BasicAux</a></dd></dl></div><div id="Lean.Parser.Tactic.skip"><h2>skip</h2><p><p><code>skip</code> does nothing.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.skip">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.sleep"><h2>sleep</h2><p><p>The tactic <code>sleep ms</code> sleeps for <code>ms</code> milliseconds and does nothing.
It is used for debugging purposes only.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.sleep">Init.Tactics</a></dd></dl></div><div id="Lean.solveTactic"><h2>solve</h2><p><p>Similar to <code>first</code>, but succeeds only if one the given tactics solves the current goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/NotationExtra.html#Lean.solveTactic">Init.NotationExtra</a></dd></dl></div><div id="Lean.Parser.Tactic.solveByElim"><h2>solve_by_elim</h2><p><p><code>solve_by_elim</code> calls <code>apply</code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code>apply</code> on the generated subgoals until no subgoals remain,
performing at most <code>maxDepth</code> (defaults to 6) recursive steps.</p><p><code>solve_by_elim</code> discharges the current goal or fails.</p><p><code>solve_by_elim</code> performs backtracking if subgoals can not be solved.</p><p>By default, the assumptions passed to <code>apply</code> are the local context, <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>,
<code><a href="./Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code>.</p><p>The assumptions can be modified with similar syntax as for <code>simp</code>:</p><ul><li><code>solve_by_elim [h‚ÇÅ, h‚ÇÇ, ..., h·µ£]</code> also applies the given expressions.</li><li><code>solve_by_elim only [h‚ÇÅ, h‚ÇÇ, ..., h·µ£]</code> does not include the local context,
<code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code><a href="./Init/Core.html#trivial">trivial</a></code>, <code><a href="./Init/Prelude.html#congrFun">congrFun</a></code>, or <code><a href="./Init/Prelude.html#congrArg">congrArg</a></code> unless they are explicitly included.</li><li><code>solve_by_elim [-h‚ÇÅ, ... -h‚Çô]</code> removes the given local hypotheses.</li><li><code>solve_by_elim using [a‚ÇÅ, ...]</code> uses all lemmas which have been labelled
with the attributes <code>a·µ¢</code> (these attributes must be created using <code>register_label_attr</code>).</li></ul><p><code>solve_by_elim*</code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p><p>Optional arguments passed via a configuration argument as <code>solve_by_elim (config := { ... })</code></p><ul><li><code>maxDepth</code>: number of attempts at discharging generated subgoals</li><li><code>symm</code>: adds all hypotheses derived by <code>symm</code> (defaults to <code>true</code>).</li><li><code>exfalso</code>: allow calling <code>exfalso</code> and trying again if <code>solve_by_elim</code> fails
(defaults to <code>true</code>).</li><li><code>transparency</code>: change the transparency mode when calling <code>apply</code>. Defaults to <code>.default</code>,
but it is often useful to change to <code>.reducible</code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</li></ul><p>See also the doc-comment for <code>Lean.Meta.Tactic.Backtrack.BacktrackConfig</code> for the options
<code>proc</code>, <code>suspend</code>, and <code>discharge</code> which allow further customization of <code>solve_by_elim</code>.
Both <code>apply_assumption</code> and <code>apply_rules</code> are implemented via these hooks.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.solveByElim">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSorry"><h2>sorry</h2><p><p>The <code>sorry</code> tactic is a temporary placeholder for an incomplete tactic proof,
closing the main goal using <code>exact sorry</code>.</p><p>This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.
Lean will give a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it,
but you can double check if a theorem depends on <code>sorry</code> by looking for <code><a href="./Init/Prelude.html#sorryAx">sorryAx</a></code> in the output
of the <code>#print axioms my_thm</code> command, the axiom used by the implementation of <code>sorry</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.specialize"><h2>specialize</h2><p><p>The tactic <code>specialize h a‚ÇÅ ... a‚Çô</code> works on local hypothesis <code>h</code>.
The premises of this hypothesis, either universal quantifications or
non-dependent implications, are instantiated by concrete terms coming
from arguments <code>a‚ÇÅ</code> ... <code>a‚Çô</code>.
The tactic adds a new hypothesis with the same name <code>h := h a‚ÇÅ ... a‚Çô</code>
and tries to clear the previous one.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.specialize">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.TautoSet.specialize_all"><h2>specialize_all</h2><p><p><code>specialize_all x</code> runs <code>specialize h x</code> for all hypotheses <code>h</code> where this tactic succeeds.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TautoSet.html#Mathlib.Tactic.TautoSet.specialize_all">Mathlib.Tactic.TautoSet</a></dd></dl></div><div id="Lean.Parser.Tactic.split"><h2>split</h2><p><p>The <code>split</code> tactic is useful for breaking nested if-then-else and <code>match</code> expressions into separate cases.
For a <code>match</code> expression with <code>n</code> cases, the <code>split</code> tactic generates at most <code>n</code> subgoals.</p><p>For example, given <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code>, and a target <code>if n = 0 then Q else R</code>, <code>split</code> will generate
one goal with hypothesis <code>n = 0</code> and target <code>Q</code>, and a second goal with hypothesis
<code>¬¨n = 0</code> and target <code>R</code>.  Note that the introduced hypothesis is unnamed, and is commonly
renamed using the <code>case</code> or <code>next</code> tactics.</p><ul><li><code>split</code> will split the goal (target).</li><li><code>split at h</code> will split the hypothesis <code>h</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.split">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticSplit_ands"><h2>split_ands</h2><p><p><code>split_ands</code> applies <code><a href="./Init/Prelude.html#And.intro">And.intro</a></code> until it does not make progress.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.tacticSplit_ands">Batteries.Tactic.Init</a></dd></dl></div><div id="Mathlib.Tactic.splitIfs"><h2>split_ifs</h2><p><p>Splits all if-then-else-expressions into multiple goals.
Given a goal of the form <code>g (if p then x else y)</code>, <code>split_ifs</code> will produce
two goals: <code>p ‚ä¢ g x</code> and <code>¬¨p ‚ä¢ g y</code>.
If there are multiple ite-expressions, then <code>split_ifs</code> will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.
<code>split_ifs at *</code> splits all ite-expressions in all hypotheses as well as the goal.
<code>split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ</code> overrides the default names for the hypotheses.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SplitIfs.html#Mathlib.Tactic.splitIfs">Mathlib.Tactic.SplitIfs</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticStop_"><h2>stop</h2><p><p><code>stop</code> is a helper tactic for &quot;discarding&quot; the rest of a proof:
it is defined as <code>repeat sorry</code>.
It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.subsingletonStx"><h2>subsingleton</h2><p><p>The <code>subsingleton</code> tactic tries to prove a goal of the form <code>x = y</code> or <code>x ‚âç y</code>
using the fact that the types involved are <em>subsingletons</em>
(a type with exactly zero or one terms).
To a first approximation, it does <code>apply <a href="./Init/Core.html#Subsingleton.elim">Subsingleton.elim</a></code>.
As a nicety, <code>subsingleton</code> first runs the <code>intros</code> tactic.</p><ul><li>If the goal is an equality, it either closes the goal or fails.</li><li><code>subsingleton [inst1, inst2, ...]</code> can be used to add additional <code><a href="./Init/Core.html#Subsingleton">Subsingleton</a></code> instances
to the local context. This can be more flexible than
<code>have := inst1; have := inst2; ...; subsingleton</code> since the tactic does not require that
all placeholders be solved for.</li></ul><p>Techniques the <code>subsingleton</code> tactic can apply:</p><ul><li>proof irrelevance</li><li>heterogeneous proof irrelevance (via <code><a href="./Init/PropLemmas.html#proof_irrel_heq">proof_irrel_heq</a></code>)</li><li>using <code><a href="./Init/Core.html#Subsingleton">Subsingleton</a></code> (via <code><a href="./Init/Core.html#Subsingleton.elim">Subsingleton.elim</a></code>)</li><li>proving <code><a href="./Init/Prelude.html#BEq">BEq</a></code> instances are equal if they are both lawful (via <code><a href="./Mathlib/Logic/Basic.html#lawful_beq_subsingleton">lawful_beq_subsingleton</a></code>)</li></ul><h3 id="Properties" class="markdown-heading">Properties <a class="hover-link" href="#Properties">#</a></h3><p>The tactic is careful not to accidentally specialize <code>Sort _</code> to <code>Prop</code>,
avoiding the following surprising behavior of <code>apply <a href="./Init/Core.html#Subsingleton.elim">Subsingleton.elim</a></code>:</p><pre><code class="language-lean">example (Œ± : Sort _) (x y : Œ±) : x = y := by apply <a href="./Init/Core.html#Subsingleton.elim">Subsingleton.elim</a>
</code></pre><p>The reason this <code>example</code> goes through is that
it applies the <code>‚àÄ (p : Prop), <a href="./Init/Core.html#Subsingleton">Subsingleton</a> p</code> instance,
specializing the universe level metavariable in <code>Sort _</code> to <code>0</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Subsingleton.html#Mathlib.Tactic.subsingletonStx">Mathlib.Tactic.Subsingleton</a></dd></dl></div><div id="Lean.Parser.Tactic.subst"><h2>subst</h2><p><p><code>subst x...</code> substitutes each hypothesis <code>x</code> with a definition found in the local context,
then eliminates the hypothesis.</p><ul><li>If <code>x</code> is a local definition, then its definition is used.</li><li>Otherwise, if there is a hypothesis of the form <code>x = e</code> or <code>e = x</code>,
then <code>e</code> is used for the definition of <code>x</code>.</li></ul><p>If <code>h : a = b</code>, then <code>subst h</code> may be used if either <code>a</code> or <code>b</code> unfolds to a local hypothesis.
This is similar to the <code>cases h</code> tactic.</p><p>See also: <code>subst_vars</code> for substituting all local hypotheses that have a defining equation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.subst">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.substEqs"><h2>subst_eqs</h2><p><p><code>subst_eq</code> repeatedly substitutes according to the equality proof hypotheses in the context,
replacing the left side of the equality with the right, until no more progress can be made.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.substEqs">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.substVars"><h2>subst_vars</h2><p><p>Applies <code>subst</code> to all hypotheses of the form <code>h : x = t</code> or <code>h : t = x</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.substVars">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Substs.substs"><h2>substs</h2><p><p>Applies the <code>subst</code> tactic to all given hypotheses from left to right.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Substs.html#Mathlib.Tactic.Substs.substs">Mathlib.Tactic.Substs</a></dd></dl></div><div id="Mathlib.Tactic.successIfFailWithMsg"><h2>success_if_fail_with_msg</h2><p><p><code>success_if_fail_with_msg msg tacs</code> runs <code>tacs</code> and succeeds only if they fail with the message
<code>msg</code>.</p><p><code>msg</code> can be any term that evaluates to an explicit <code><a href="./Init/Prelude.html#String">String</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SuccessIfFailWithMsg.html#Mathlib.Tactic.successIfFailWithMsg">Mathlib.Tactic.SuccessIfFailWithMsg</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticSuffices_"><h2>suffices</h2><p><p>Given a main goal <code>ctx ‚ä¢ t</code>, <code>suffices h : t' from e</code> replaces the main goal with <code>ctx ‚ä¢ t'</code>,
<code>e</code> must have type <code>t</code> in the context <code>ctx, h : t'</code>.</p><p>The variant <code>suffices h : t' by tac</code> is a shorthand for <code>suffices h : t' from by tac</code>.
If <code>h :</code> is omitted, the name <code>this</code> is used.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.suggestions"><h2>suggestions</h2><p><p><code>#suggestions</code> will suggest relevant theorems from the library for the current goal,
using the currently registered library suggestion engine.</p><p>The suggestions are printed in the order of their confidence, from highest to lowest.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.suggestions">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticSwap"><h2>swap</h2><p><p><code>swap</code> is a shortcut for <code>pick_goal 2</code>, which interchanges the 1st and 2nd goals.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/PermuteGoals.html#Batteries.Tactic.tacticSwap">Batteries.Tactic.PermuteGoals</a></dd></dl></div><div id="Mathlib.Tactic.¬´tacticSwap_var__,,¬ª"><h2>swap_var</h2><p><p><code>swap_var swap_rule‚ÇÅ, swap_rule‚ÇÇ, ‚ãØ</code> applies <code>swap_rule‚ÇÅ</code> then <code>swap_rule‚ÇÇ</code> then <code>‚ãØ</code>.</p><p>A <em>swap_rule</em> is of the form <code>x y</code> or <code>x ‚Üî y</code>, and &quot;applying it&quot; means swapping the variable name
<code>x</code> by <code>y</code> and vice-versa on all hypotheses and the goal.</p><pre><code class="language-lean">example {P Q : Prop} (q : P) (p : Q) : P ‚àß Q := by
  swap_var p ‚Üî q
  exact ‚ü®p, q‚ü©
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/SwapVar.html#Mathlib.Tactic.¬´tacticSwap_var__,,¬ª">Mathlib.Tactic.SwapVar</a></dd></dl></div><div id="Lean.Parser.Tactic.symm"><h2>symm</h2><p><ul><li><code>symm</code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a symmetric relation,
that is, a relation which has a symmetry lemma tagged with the attribute [symm].
It replaces the target with <code>u ~ t</code>.</li><li><code>symm at h</code> will rewrite a hypothesis <code>h : t ~ u</code> to <code>h : u ~ t</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.symm">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.symmSaturate"><h2>symm_saturate</h2><p><p>For every hypothesis <code>h : a ~ b</code> where a <code>@[symm]</code> lemma is available,
add a hypothesis <code>h_symm : b ~ a</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.symmSaturate">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.Tauto.tauto"><h2>tauto</h2><p><p><code>tauto</code> breaks down assumptions of the form <code>_ ‚àß _</code>, <code>_ ‚à® _</code>, <code>_ ‚Üî _</code> and <code>‚àÉ _, _</code>
and splits a goal of the form <code>_ ‚àß _</code>, <code>_ ‚Üî _</code> or <code>‚àÉ _, _</code> until it can be discharged
using <code><a href="./Init/Prelude.html#rfl">rfl</a></code> or <code>solve_by_elim</code>.
This is a finishing tactic: it either closes the goal or raises an error.</p><p>The Lean 3 version of this tactic by default attempted to avoid classical reasoning
where possible. This Lean 4 version makes no such attempt. The <code>itauto</code> tactic
is designed for that purpose.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Tauto.html#Mathlib.Tactic.Tauto.tauto">Mathlib.Tactic.Tauto</a></dd></dl></div><div id="Mathlib.Tactic.TautoSet.tacticTauto_set"><h2>tauto_set</h2><p><p><code>tauto_set</code> attempts to prove tautologies involving hypotheses and goals of the form <code>X ‚äÜ Y</code>
or <code>X = Y</code>, where <code>X</code>, <code>Y</code> are expressions built using ‚à™, ‚à©, , and ·∂ú from finitely many
variables of type <code><a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±</code>. It also unfolds expressions of the form <code><a href="./Mathlib/Order/Disjoint.html#Disjoint">Disjoint</a> A B</code> and
<code><a href="./Mathlib/Order/SymmDiff.html#symmDiff">symmDiff</a> A B</code>.</p><p>Examples:</p><pre><code class="language-lean">example {Œ±} (A B C D : <a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±) (h1 : A ‚äÜ B) (h2 : C ‚äÜ D) : C \ B ‚äÜ D \ A := by
  tauto_set

example {Œ±} (A B C : <a href="./Mathlib/Data/Set/Defs.html#Set">Set</a> Œ±) (h1 : A ‚äÜ B ‚à™ C) : (A ‚à© B) ‚à™ (A ‚à© C) = A := by
  tauto_set
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TautoSet.html#Mathlib.Tactic.TautoSet.tacticTauto_set">Mathlib.Tactic.TautoSet</a></dd></dl></div><div id="Mathlib.Tactic.TFAE.tfaeFinish"><h2>tfae_finish</h2><p><p><code>tfae_finish</code> closes goals of the form <code>TFAE [P‚ÇÅ, P‚ÇÇ, ...]</code> once a sufficient collection
of hypotheses of the form <code>P·µ¢ ‚Üí P‚±º</code> or <code>P·µ¢ ‚Üî P‚±º</code> have been introduced to the local context.</p><p><code>tfae_have</code> can be used to conveniently introduce these hypotheses; see <code>tfae_have</code>.</p><p>Example:</p><pre><code class="language-lean4">example : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/
  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/
  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/
  tfae_finish
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish">Mathlib.Tactic.TFAE</a></dd></dl></div><div id="Mathlib.Tactic.TFAE.tfaeHave"><h2>tfae_have</h2><p><p><code>tfae_have i ‚Üí j := t</code>, where the goal is <code>TFAE [P‚ÇÅ, P‚ÇÇ, ...]</code> introduces a hypothesis
<code>tfae_i_to_j : P·µ¢ ‚Üí P‚±º</code> and proof <code>t</code> to the local context. Note that <code>i</code> and <code>j</code> are
natural number literals (beginning at 1) used as indices to specify the propositions
<code>P‚ÇÅ, P‚ÇÇ, ...</code> that appear in the goal.</p><p>Once sufficient hypotheses have been introduced by <code>tfae_have</code>, <code>tfae_finish</code> can be used to close
the goal.</p><p>All features of <code>have</code> are supported by <code>tfae_have</code>, including naming, matching,
destructuring, and goal creation.</p><ul><li><code>tfae_have i ‚Üê j := t</code> adds a hypothesis in the reverse direction, of type <code>P‚±º ‚Üí P·µ¢</code>.</li><li><code>tfae_have i ‚Üî j := t</code> adds a hypothesis in the both directions, of type <code>P·µ¢ ‚Üî P‚±º</code>.</li><li><code>tfae_have hij : i ‚Üí j := t</code> names the introduced hypothesis <code>hij</code> instead of <code>tfae_i_to_j</code>.</li><li><code>tfae_have i j | p‚ÇÅ =&gt; t‚ÇÅ | ...</code> matches on the assumption <code>p : P·µ¢</code>.</li><li><code>tfae_have ‚ü®hij, hji‚ü© : i ‚Üî j := t</code> destructures the bi-implication into <code>hij : P·µ¢ ‚Üí P‚±º</code>
and <code>hji : P‚±º ‚Üí P‚±º</code>.</li><li><code>tfae_have i ‚Üí j := t ?a</code> creates a new goal for <code>?a</code>.</li></ul><p>Examples:</p><pre><code class="language-lean4">example (h : P ‚Üí R) : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 3 := h
  -- The resulting context now includes `tfae_1_to_3 : P ‚Üí R`.
  sorry
</code></pre><pre><code class="language-lean4">-- An example of `tfae_have` and `tfae_finish`:
example : TFAE [P, Q, R] := by
  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/
  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/
  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/
  tfae_finish
</code></pre><pre><code class="language-lean4">-- All features of `have` are supported by `tfae_have`:
example : TFAE [P, Q] := by
  -- assert `tfae_1_to_2 : P ‚Üí Q`:
  tfae_have 1 ‚Üí 2 := sorry

  -- assert `hpq : P ‚Üí Q`:
  tfae_have hpq : 1 ‚Üí 2 := sorry

  -- match on `p : P` and prove `Q` via `f p`:
  tfae_have 1 ‚Üí 2
  | p =&gt; f p

  -- assert `pq : P ‚Üí Q`, `qp : Q ‚Üí P`:
  tfae_have ‚ü®pq, qp‚ü© : 1 ‚Üî 2 := sorry

  -- assert `h : P ‚Üí Q`; `?a` is a new goal:
  tfae_have h : 1 ‚Üí 2 := f ?a

  sorry
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave">Mathlib.Tactic.TFAE</a></dd></dl></div><div id="Set.tacticToFinite_tac"><h2>toFinite_tac</h2><p><p>A tactic (for use in default params) that applies <code><a href="./Mathlib/Data/Finite/Defs.html#Set.toFinite">Set.toFinite</a></code> to synthesize a <code><a href="./Mathlib/Data/Finite/Defs.html#Set.Finite">Set.Finite</a></code>
term.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Set/Card.html#Set.tacticToFinite_tac">Mathlib.Data.Set.Card</a></dd></dl></div><div id="Set.tacticTo_encard_tac"><h2>to_encard_tac</h2><p><p>A tactic useful for transferring proofs for <code>encard</code> to their corresponding <code>card</code> statements</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Data/Set/Card.html#Set.tacticTo_encard_tac">Mathlib.Data.Set.Card</a></dd></dl></div><div id="Lean.Parser.Tactic.trace"><h2>trace</h2><p><p>Evaluates a term to a string (when possible), and prints it as a trace message.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Trace.html#Lean.Parser.Tactic.trace">Mathlib.Tactic.Trace</a></dd></dl></div><div id="Lean.Parser.Tactic.traceMessage"><h2>trace</h2><p><p><code>trace msg</code> displays <code>msg</code> in the info view.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.traceMessage">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.traceState"><h2>trace_state</h2><p><p><code>trace_state</code> displays the current state in the info view.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.traceState">Init.Tactics</a></dd></dl></div><div id="Batteries.Tactic.tacticTrans___"><h2>trans</h2><p><p><code>trans</code> applies to a goal whose target has the form <code>t ~ u</code> where <code>~</code> is a transitive relation,
that is, a relation which has a transitivity lemma tagged with the attribute [trans].</p><ul><li><code>trans s</code> replaces the goal with the two subgoals <code>t ~ s</code> and <code>s ~ u</code>.</li><li>If <code>s</code> is omitted, then a metavariable is used instead.</li></ul><p>Additionally, <code>trans</code> also applies to a goal whose target has the form <code>t ‚Üí u</code>,
in which case it replaces the goal with <code>t ‚Üí s</code> and <code>s ‚Üí u</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTrans___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.tacticTransitivity___"><h2>transitivity</h2><p><p>Synonym for <code>trans</code> tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Trans.html#Batteries.Tactic.tacticTransitivity___">Batteries.Tactic.Trans</a></dd></dl></div><div id="Batteries.Tactic.triv"><h2>triv</h2><p><p>Deprecated variant of <code><a href="./Init/Core.html#trivial">trivial</a></code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Init.html#Batteries.Tactic.triv">Batteries.Tactic.Init</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticTrivial"><h2>trivial</h2><p><p><code><a href="./Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, <code>contradiction</code>, ...)
to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) =&gt; `(tactic| simp)
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticTry_"><h2>try</h2><p><p><code>try tac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.tryTrace"><h2>try?</h2><p><p>This tactic has no documentation.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.tryTrace">Init.Try</a></dd></dl></div><div id="Lean.Parser.Tactic.tryResult"><h2>try_suggestions</h2><p><p>Helper internal tactic used to implement <code>evalSuggest</code> in <code>try?</code></p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#Lean.Parser.Tactic.tryResult">Init.Try</a></dd></dl></div><div id="Mathlib.Tactic.tacticTry_this__"><h2>try_this</h2><p><p>Produces the text <code>Try this: &lt;tac&gt;</code> with the given tactic, and then executes it.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TryThis.html#Mathlib.Tactic.tacticTry_this__">Mathlib.Tactic.TryThis</a></dd></dl></div><div id="tacticType_check_"><h2>type_check</h2><p><p>Type check the given expression, and trace its type.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/TypeCheck.html#tacticType_check_">Mathlib.Tactic.TypeCheck</a></dd></dl></div><div id="Lean.Parser.Tactic.unfold"><h2>unfold</h2><p><ul><li><code>unfold <a href="./Init/Prelude.html#id">id</a></code> unfolds all occurrences of definition <code><a href="./Init/Prelude.html#id">id</a></code> in the target.</li><li><code>unfold id1 id2 ...</code> is equivalent to <code>unfold id1; unfold id2; ...</code>.</li><li><code>unfold <a href="./Init/Prelude.html#id">id</a> at h</code> unfolds at the hypothesis <code>h</code>.</li></ul><p>Definitions can be either global or local definitions.</p><p>For non-recursive global definitions, this tactic is identical to <code>delta</code>.
For recursive global definitions, it uses the &quot;unfolding lemma&quot; <code>id.eq_def</code>,
which is generated for each recursive definition, to unfold according to the recursive definition given by the user.
Only one level of unfolding is performed, in contrast to <code>simp only [id]</code>, which unfolds definition <code><a href="./Init/Prelude.html#id">id</a></code> recursively.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.unfold">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.InteractiveUnfold.tacticUnfold?"><h2>unfold?</h2><p><p>Replace the selected expression with a definitional unfolding.</p><ul><li>After each unfolding, we apply <code>whnfCore</code> to simplify the expression.</li><li>Explicit natural number expressions are evaluated.</li><li>Unfolds of class projections of instances marked with <code>@[default_instance]</code> are not shown.
This is relevant for notational type classes like <code>+</code>: we don't want to suggest <code><a href="./Init/Prelude.html#Add.add">Add.add</a> a b</code>
as an unfolding of <code>a + b</code>. Similarly for <code><a href="./Init/Prelude.html#OfNat">OfNat</a> n : <a href="./Init/Prelude.html#Nat">Nat</a></code> which unfolds into <code>n : <a href="./Init/Prelude.html#Nat">Nat</a></code>.</li></ul><p>To use <code>unfold?</code>, shift-click an expression in the tactic state.
This gives a list of rewrite suggestions for the selected expression.
Click on a suggestion to replace <code>unfold?</code> by a tactic that performs this rewrite.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Widget/InteractiveUnfold.html#Mathlib.Tactic.InteractiveUnfold.tacticUnfold?">Mathlib.Tactic.Widget.InteractiveUnfold</a></dd></dl></div><div id="Mathlib.Tactic.unfoldProjsStx"><h2>unfold_projs</h2><p><p><code>unfold_projs at loc</code> unfolds projections of class instances at the given location.
This also exists as a <code>conv</code>-mode tactic.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Lean.Parser.Tactic.tacticUnhygienic_"><h2>unhygienic</h2><p><p><code>unhygienic tacs</code> runs <code>tacs</code> with name hygiene disabled.
This means that tactics that would normally create inaccessible names will instead
make regular variables. <strong>Warning</strong>: Tactics may change their variable naming
strategies at any time, so code that depends on autogenerated names is brittle.
Users should try not to use <code>unhygienic</code> if possible.</p><pre><code>example : ‚àÄ x : Nat, x = x := by unhygienic
  intro            -- x would normally be intro'd as inaccessible
  exact <a href="./Init/Prelude.html#Eq.refl">Eq.refl</a> x  -- refer to x
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_">Init.Tactics</a></dd></dl></div><div id="Tactic.Interactive.tacticUnit_interval"><h2>unit_interval</h2><p><p>A tactic that solves <code>0 ‚â§ ‚Üëx</code>, <code>0 ‚â§ 1 - ‚Üëx</code>, <code>‚Üëx ‚â§ 1</code>, and <code>1 - ‚Üëx ‚â§ 1</code> for <code>x : I</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Topology/UnitInterval.html#Tactic.Interactive.tacticUnit_interval">Mathlib.Topology.UnitInterval</a></dd></dl></div><div id="Batteries.Tactic.unreachable"><h2>unreachable!</h2><p><p>This tactic causes a panic when run (at compile time).
(This is distinct from <code>exact unreachable!</code>, which inserts code which will panic at run time.)</p><p>It is intended for tests to assert that a tactic will never be executed, which is otherwise an
unusual thing to do (and the <code>unreachableTactic</code> linter will give a warning if you do).</p><p>The <code>unreachableTactic</code> linter has a special exception for uses of <code>unreachable!</code>.</p><pre><code>example : <a href="./Init/Prelude.html#True">True</a> := by <a href="./Init/Core.html#trivial">trivial</a> &lt;;&gt; unreachable!
</code></pre></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Batteries/Tactic/Unreachable.html#Batteries.Tactic.unreachable">Batteries.Tactic.Unreachable</a></dd></dl></div><div id="Mathlib.Tactic.useSyntax"><h2>use</h2><p><p><code>use e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> is similar to <code>exists</code>, but unlike <code>exists</code> it is equivalent to applying the tactic
<code>refine ‚ü®e‚ÇÅ, e‚ÇÇ, ‚ãØ, ?_, ‚ãØ, ?_‚ü©</code> with any number of placeholders (rather than just one) and
then trying to close goals associated to the placeholders with a configurable discharger (rather
than just <code>try <a href="./Init/Core.html#trivial">trivial</a></code>).</p><p>Examples:</p><pre><code class="language-lean">example : ‚àÉ x : Nat, x = x := by use 42

example : ‚àÉ x : Nat, ‚àÉ y : Nat, x = y := by use 42, 42

example : <a href="./Init/Prelude.html#Nonempty">Nonempty</a> <a href="./Init/Prelude.html#Nat">Nat</a> := by use 5

example : <a href="./Init/Prelude.html#Nonempty">Nonempty</a> (PNat ‚âÉ Nat) := by
  use PNat.natPred, Nat.succPNat
  ¬∑ exact PNat.succPNat_natPred
  ¬∑ intro; <a href="./Init/Prelude.html#rfl">rfl</a>
</code></pre><p><code>use! e‚ÇÅ, e‚ÇÇ, ‚ãØ</code> is similar but it applies constructors everywhere rather than just for
goals that correspond to the last argument of a constructor. This gives the effect that
nested constructors are being flattened out, with the supplied values being used along the
leaves and nodes of the tree of constructors.
With <code>use!</code> one can feed in each <code>42</code> one at a time:</p><pre><code class="language-lean">example : ‚àÉ n : {n : <a href="./Init/Prelude.html#Nat">Nat</a> // n % 2 = 0}, n.val &gt; 10 := by use! 20; simp

example : ‚àÉ p : <a href="./Init/Prelude.html#Nat">Nat</a> √ó Nat, p.1 = p.2 := by use! (42, 42)
</code></pre><p>The second line makes use of the fact that <code>use!</code> tries refining with the argument before
applying a constructor. Also note that <code>use</code>/<code>use!</code> by default uses a tactic
called <code>use_discharger</code> to discharge goals, so <code>use! 42</code> will close the goal in this example since
<code>use_discharger</code> applies <code><a href="./Init/Prelude.html#rfl">rfl</a></code>, which as a consequence solves for the other <code><a href="./Init/Prelude.html#Nat">Nat</a></code> metavariable.</p><p>These tactics take an optional discharger to handle remaining explicit <code>Prop</code> constructor arguments.
By default it is <code>use (discharger := try with_reducible use_discharger) e‚ÇÅ, e‚ÇÇ, ‚ãØ</code>.
To turn off the discharger and keep all goals, use <code>(discharger := skip)</code>.
To allow &quot;heavy refls&quot;, use <code>(discharger := try use_discharger)</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Use.html#Mathlib.Tactic.useSyntax">Mathlib.Tactic.Use</a></dd></dl></div><div id="Mathlib.Tactic.tacticUse_discharger"><h2>use_discharger</h2><p><p>Default discharger to try to use for the <code>use</code> and <code>use!</code> tactics.
This is similar to the <code><a href="./Init/Core.html#trivial">trivial</a></code> tactic but doesn't do things like <code>contradiction</code> or <code>decide</code>.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Use.html#Mathlib.Tactic.tacticUse_discharger">Mathlib.Tactic.Use</a></dd></dl></div><div id="tacticUse_finite_instance"><h2>use_finite_instance</h2><p><p>Try using <code><a href="./Mathlib/Data/Finite/Defs.html#Set.toFinite">Set.toFinite</a></code> to dispatch a <code><a href="./Mathlib/Data/Finite/Defs.html#Set.Finite">Set.Finite</a></code> goal.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/LinearAlgebra/Dual/Basis.html#tacticUse_finite_instance">Mathlib.LinearAlgebra.Dual.Basis</a></dd></dl></div><div id="MeasureTheory.tacticVolume_tac"><h2>volume_tac</h2><p><p>The tactic <code>exact volume</code>, to be used in optional (<code><a href="./Init/Tactics.html#autoParam">autoParam</a></code>) arguments.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/MeasureTheory/Measure/MeasureSpaceDef.html#MeasureTheory.tacticVolume_tac">Mathlib.MeasureTheory.Measure.MeasureSpaceDef</a></dd></dl></div><div id="Lean.Server.Test.Cancel.tacticWait_for_unblock_async"><h2>wait_for_unblock_async</h2><p><p>Spawns a <code>logSnapshotTask</code> that waits for <code>unblock</code> to be called, which is expected to happen in a
subsequent document version that does not invalidate this tactic. Complains if cancellation token
was set before unblocking, i.e. if the tactic was invalidated after all.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Lean/Server/Test/Cancel.html#Lean.Server.Test.Cancel.tacticWait_for_unblock_async">Lean.Server.Test.Cancel</a></dd></dl></div><div id="Mathlib.Tactic.tacticWhnf__"><h2>whnf</h2><p><p><code>whnf at loc</code> puts the given location into weak-head normal form.
This also exists as a <code>conv</code>-mode tactic.</p><p>Weak-head normal form is when the outer-most expression has been fully reduced, the expression
may contain subexpressions which have not been reduced.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__">Mathlib.Tactic.DefEqTransformations</a></dd></dl></div><div id="Lean.Parser.Tactic.withReducible"><h2>with_reducible</h2><p><p><code>with_reducible tacs</code> executes <code>tacs</code> using the reducible transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withReducible">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withReducibleAndInstances"><h2>with_reducible_and_instances</h2><p><p><code>with_reducible_and_instances tacs</code> executes <code>tacs</code> using the <code>.instances</code> transparency setting.
In this setting only definitions tagged as <code>[reducible]</code> or type class instances are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withUnfoldingAll"><h2>with_unfolding_all</h2><p><p><code>with_unfolding_all tacs</code> executes <code>tacs</code> using the <code>.all</code> transparency setting.
In this setting all definitions that are not opaque are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">Init.Tactics</a></dd></dl></div><div id="Lean.Parser.Tactic.withUnfoldingNone"><h2>with_unfolding_none</h2><p><p><code>with_unfolding_none tacs</code> executes <code>tacs</code> using the <code>.none</code> transparency setting.
In this setting no definitions are unfolded.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingNone">Init.Tactics</a></dd></dl></div><div id="Mathlib.Tactic.wlog"><h2>wlog</h2><p><p><code>wlog h : P</code> adds an assumption <code>h : P</code> to the main goal, and adds a side goal that
requires showing that the case <code>h : ¬¨ P</code> can be reduced to the case where <code>P</code> holds
(typically by symmetry). The side goal will be at the top of the stack. In this side goal,
there will be two additional assumptions:</p><ul><li><code>h : ¬¨ P</code>: the assumption that <code>P</code> does not hold</li><li><code>this</code>: which is the statement that in the old context <code>P</code> suffices to prove the goal.
By default, the entire context is reverted to produce <code>this</code>.</li></ul><ul><li><code>wlog h : P with H</code> gives the name <code>H</code> to the statement that <code>P</code> proves the goal.</li><li><code>wlog h : P generalizing x y ...</code> reverts certain parts of the context before creating the new
goal. In this way, the wlog-claim <code>this</code> can be applied to <code>x</code> and <code>y</code> in different orders
(exploiting symmetry, which is the typical use case).</li><li><code>wlog! h : P</code> also calls <code>push_neg</code> at the generated hypothesis <code>h</code>.
<code>wlog! h : P ‚àß Q</code> will transform <code>¬¨ (P ‚àß Q)</code> to <code>P ‚Üí ¬¨ Q</code></li><li><code>wlog! +distrib h : P</code> also calls <code>push_neg +distrib</code> at the generated hypothesis <code>h</code>.
<code>wlog! +distrib h : P ‚àß Q</code> will transform <code>¬¨ (P ‚àß Q)</code> to <code>¬¨P ‚à® ¬¨Q</code>.</li></ul></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/WLOG.html#Mathlib.Tactic.wlog">Mathlib.Tactic.WLOG</a></dd></dl></div><div id="Mathlib.Tactic.Zify.zify"><h2>zify</h2><p><p>The <code>zify</code> tactic is used to shift propositions from <code><a href="./Init/Prelude.html#Nat">Nat</a></code> to <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>.
This is often useful since <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code> has well-behaved subtraction.</p><pre><code>example (a b c x y z : Nat) (h : ¬¨ x*y*z &lt; 0) : c &lt; a + 3*b := by
  zify
  zify at h
  /-
  h : ¬¨‚Üëx * ‚Üëy * ‚Üëz &lt; 0
  ‚ä¢ ‚Üëc &lt; ‚Üëa + 3 * ‚Üëb
  -/
</code></pre><p><code>zify</code> can be given extra lemmas to use in simplification. This is especially useful in the
presence of nat subtraction: passing <code>‚â§</code> arguments will allow <code>push_cast</code> to do more work.</p><pre><code>example (a b c : Nat) (h : a - b &lt; c) (hab : b ‚â§ a) : false := by
  zify [hab] at h
  /- h : ‚Üëa - ‚Üëb &lt; ‚Üëc -/
</code></pre><p><code>zify</code> makes use of the <code>@[zify_simps]</code> attribute to move propositions,
and the <code>push_cast</code> tactic to simplify the <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>-valued expressions.
<code>zify</code> is in some sense dual to the <code>lift</code> tactic.
<code>lift (z : Int) to <a href="./Init/Prelude.html#Nat">Nat</a></code> will change the type of an
integer <code>z</code> (in the supertype) to <code><a href="./Init/Prelude.html#Nat">Nat</a></code> (the subtype), given a proof that <code>z ‚â• 0</code>;
propositions concerning <code>z</code> will still be over <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code>.
<code>zify</code> changes propositions about <code><a href="./Init/Prelude.html#Nat">Nat</a></code> (the subtype) to propositions about <code><a href="./Init/Data/Int/Basic.html#Int">Int</a></code> (the supertype),
without changing the type of any variable.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Mathlib/Tactic/Zify.html#Mathlib.Tactic.Zify.zify">Mathlib.Tactic.Zify</a></dd></dl></div><div id="¬´tactic‚àé¬ª"><h2>‚àé</h2><p><p><code>‚àé</code> (typed as <code>\qed</code>) is a macro that expands to <code>try?</code> in tactic mode.</p></p><dl><dt>Tags:</dt><dd></dd><dt>Defined in module:</dt><dd><a href="./Init/Try.html#¬´tactic‚àé¬ª">Init.Try</a></dd></dl></div></main>
<nav class="nav"><iframe src="./navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>